[
  {
    "id": "topic1_1",
    "question": "What is the input language of ProVerif primarily based on?",
    "options": {
      "A": "The original pi calculus by Milner",
      "B": "The applied pi calculus introduced by Abadi and Fournet (2001) and updated in 2016",
      "C": "The spi calculus by Abadi and Gordon",
      "D": "The λ-calculus with cryptographic extensions"
    },
    "answer": "B"
  },
  {
    "id": "topic1_2",
    "question": "How does the applied pi calculus extend the original pi calculus?",
    "options": {
      "A": "By introducing probabilistic computation",
      "B": "By allowing function symbols defined by an equational theory",
      "C": "By removing concurrency constructs",
      "D": "By replacing messages with integers only"
    },
    "answer": "B"
  },
  {
    "id": "topic1_3",
    "question": "Which feature is used by ProVerif that differs from the equational theories in the applied pi calculus?",
    "options": {
      "A": "ProVerif uses only equality checks",
      "B": "ProVerif uses destructors in addition to equational theories",
      "C": "ProVerif removes all destructors for simplification",
      "D": "ProVerif uses probabilistic encryption exclusively"
    },
    "answer": "B"
  },
  {
    "id": "topic1_4",
    "question": "What is ProVerif’s built-in construct that is not present in the applied pi calculus?",
    "options": {
      "A": "A repeat loop construct",
      "B": "Error-handling through the else branch of expression evaluation",
      "C": "Non-deterministic choice operators",
      "D": "Higher-order functions support"
    },
    "answer": "B"
  },
  {
    "id": "topic1_5",
    "question": "What types of security properties can ProVerif verify?",
    "options": {
      "A": "Only secrecy properties",
      "B": "Only authentication properties",
      "C": "Secrecy, authentication (correspondences), and some observational equivalence properties",
      "D": "Only observational equivalence properties"
    },
    "answer": "C"
  },
  {
    "id": "topic1_6",
    "question": "What kind of mathematical objects model cryptographic primitives in ProVerif?",
    "options": {
      "A": "Probabilistic automata",
      "B": "Automata with states only",
      "C": "Rewrite rules or equations",
      "D": "Simple term algebras without functions"
    },
    "answer": "C"
  },
  {
    "id": "topic1_7",
    "question": "How is the ProVerif input language related to the applied pi calculus?",
    "options": {
      "A": "It is a completely unrelated language specialized for cryptography",
      "B": "It is a minimal core extension of the applied pi calculus language",
      "C": "It is only superficially similar but semantically different",
      "D": "It restricts the applied pi calculus to only names, not variables"
    },
    "answer": "B"
  },
  {
    "id": "topic1_8",
    "question": "What is the importance of 'differential equivalence' (diff-equivalence) in ProVerif compared to observational equivalence?",
    "options": {
      "A": "Diff-equivalence is a weaker condition than observational equivalence",
      "B": "ProVerif proves diff-equivalence, which is stronger than observational equivalence",
      "C": "Neither diff-equivalence nor observational equivalence is supported by ProVerif",
      "D": "Diff-equivalence and observational equivalence are equivalent notions in ProVerif"
    },
    "answer": "B"
  },
  {
    "id": "topic1_9",
    "question": "In the context of substitutions in ProVerif, what do substitutions map?",
    "options": {
      "A": "Variables and names to constants only",
      "B": "Variables (but not names) to terms or expressions",
      "C": "Names only to processes",
      "D": "Neither variables nor names are substituted"
    },
    "answer": "B"
  },
  {
    "id": "topic1_10",
    "question": "What underlying formal method tool does ProVerif use to resolve derivability queries?",
    "options": {
      "A": "Model checking with BDDs",
      "B": "Resolution with selection on Horn clauses",
      "C": "SAT solving over propositional formulas",
      "D": "Linear programming"
    },
    "answer": "B"
  },
  {
    "id": "topic2_1",
    "question": "What is the primary goal of ProVerif?",
    "options": {
      "A": "To implement cryptographic protocols efficiently.",
      "B": "To verify cryptographic protocols for properties like secrecy and authentication.",
      "C": "To simulate cryptographic algorithms on different platforms.",
      "D": "To generate cryptographic keys automatically."
    },
    "answer": "B"
  },
  {
    "id": "topic2_2",
    "question": "Which formalism does ProVerif use to represent protocols?",
    "options": {
      "A": "Lambda calculus without extensions.",
      "B": "An extension of the pi calculus with cryptography.",
      "C": "Finite state machines.",
      "D": "First-order logic without extensions."
    },
    "answer": "B"
  },
  {
    "id": "topic2_3",
    "question": "What kind of channels are assumed in ProVerif's threat model?",
    "options": {
      "A": "Secure, private channels.",
      "B": "Fully trusted communication channels.",
      "C": "Public communication channels controlled by an attacker with Dolev-Yao capabilities.",
      "D": "Encrypted channels that cannot be intercepted."
    },
    "answer": "C"
  },
  {
    "id": "topic2_4",
    "question": "Which of the following properties can ProVerif automatically verify?",
    "options": {
      "A": "Secrecy and authentication only.",
      "B": "Only secrecy properties.",
      "C": "Secrecy, authentication, reachability, correspondence, and observational equivalence.",
      "D": "Only the correctness of cryptographic primitives."
    },
    "answer": "C"
  },
  {
    "id": "topic2_5",
    "question": "How does ProVerif internally represent protocols and security properties?",
    "options": {
      "A": "As state machines and transition graphs.",
      "B": "Using Horn clauses and derivability queries.",
      "C": "In source code of executable implementations.",
      "D": "As a set of logical propositions in propositional logic."
    },
    "answer": "B"
  },
  {
    "id": "topic2_6",
    "question": "Which of the following protocols was NOT explicitly mentioned as an application case study for ProVerif?",
    "options": {
      "A": "Certified email protocol.",
      "B": "E-voting protocols.",
      "C": "Block cipher implementation.",
      "D": "The ad-hoc routing protocol ARAN."
    },
    "answer": "C"
  },
  {
    "id": "topic2_7",
    "question": "What is a key advantage of ProVerif compared to interactive verification tools?",
    "options": {
      "A": "It requires detailed user interaction on each verification step.",
      "B": "It offers a fully manual protocol simulation environment.",
      "C": "It provides more automation and can handle an unbounded number of sessions.",
      "D": "It only verifies protocols with a fixed number of sessions."
    },
    "answer": "C"
  },
  {
    "id": "topic2_8",
    "question": "ProVerif has been used as a back-end for other verification tools primarily because:",
    "options": {
      "A": "It can generate C code for secure implementations.",
      "B": "It provides a powerful automated reasoning engine for protocol verification.",
      "C": "It enforces compliance with encryption standards.",
      "D": "It simulates network delays for testing protocols."
    },
    "answer": "B"
  },
  {
    "id": "topic2_9",
    "question": "Why is it important for ProVerif to verify both the specification and the implementation of protocols?",
    "options": {
      "A": "Because specifications are usually correct but implementations may have vulnerabilities.",
      "B": "Implementations do not affect security if specifications are correct.",
      "C": "Verification is only useful at specification level, not implementation.",
      "D": "The tool does not support implementation verification at all."
    },
    "answer": "A"
  },
  {
    "id": "topic2_10",
    "question": "What is one limitation of ProVerif mentioned in the content?",
    "options": {
      "A": "It cannot handle secrecy properties.",
      "B": "Termination of the verification process is not guaranteed in general.",
      "C": "It only supports a fixed message space size.",
      "D": "It can only verify protocols offline, not online."
    },
    "answer": "B"
  },
  {
    "id": "topic3_1",
    "question": "Which of the following statements accurately describes the first character rule for identifiers in the given specification?",
    "options": {
      "A": "The first character can be any digit or letter.",
      "B": "The first character must always be a letter.",
      "C": "The first character can be a letter or underscore.",
      "D": "The first character can be any ASCII character except reserved words."
    },
    "answer": "B"
  },
  {
    "id": "topic3_2",
    "question": "In the identifier specification provided, what characters are allowed after the first character?",
    "options": {
      "A": "Only letters (a-z, A-Z)",
      "B": "Letters and digits only",
      "C": "Letters, digits, underscores (_), single-quotes ('), and accented letters from ISO Latin 1",
      "D": "Letters, digits, underscores (_), and spaces"
    },
    "answer": "C"
  },
  {
    "id": "topic3_3",
    "question": "Which of the following is true about the case sensitivity of identifiers according to the content?",
    "options": {
      "A": "Identifiers are case-insensitive (e.g., ‘Var’ and ‘var’ are the same).",
      "B": "Identifiers must be all lowercase.",
      "C": "Identifiers are case-sensitive (e.g., ‘Var’ and ‘var’ are different).",
      "D": "Identifiers must be all uppercase."
    },
    "answer": "C"
  },
  {
    "id": "topic3_4",
    "question": "Which of the following is NOT allowed as an identifier because it is a reserved keyword?",
    "options": {
      "A": "process",
      "B": "private",
      "C": "myVar",
      "D": "alpha123"
    },
    "answer": "A"
  },
  {
    "id": "topic3_5",
    "question": "Why is it important that identifiers do not match any reserved words in the language?",
    "options": {
      "A": "To allow their use both as functions and variables simultaneously.",
      "B": "To avoid ambiguity and parsing errors during compilation or interpretation.",
      "C": "To enable easier human readability.",
      "D": "Because reserved words can only be lowercase identifiers."
    },
    "answer": "B"
  },
  {
    "id": "topic3_6",
    "question": "Which character set forms the basis for all valid identifiers in this formalism?",
    "options": {
      "A": "Unicode characters only",
      "B": "ASCII characters with additional accented letters from ISO Latin 1",
      "C": "Digits and symbols only",
      "D": "Only English alphabet letters (A-Z, a-z)"
    },
    "answer": "B"
  },
  {
    "id": "topic3_7",
    "question": "According to the description, which of these could serve as a valid identifier?",
    "options": {
      "A": "'_myVar' (underscore as first character)",
      "B": "'1stVar' (starts with a digit)",
      "C": "'var_123’ (letter first, followed by underscore and digits)",
      "D": "'for' (reserved keyword)"
    },
    "answer": "C"
  },
  {
    "id": "topic3_8",
    "question": "When names and variables are declared, what additional information accompanies their identifier?",
    "options": {
      "A": "Their value",
      "B": "Their type",
      "C": "Their length",
      "D": "Their scope"
    },
    "answer": "B"
  },
  {
    "id": "topic3_9",
    "question": "Which of the following best summarizes the restrictions on identifier naming?",
    "options": {
      "A": "Identifiers must start with a digit and contain only letters and digits.",
      "B": "Identifiers can start with any character but must be unique.",
      "C": "Identifiers must start with a letter, may contain letters, digits, certain symbols, and must not be reserved words.",
      "D": "Identifiers must be a sequence of digits only."
    },
    "answer": "C"
  },
  {
    "id": "topic3_10",
    "question": "Why do the authors discourage reusing built-in identifiers such as ‘bool’, ‘attacker’, or ‘message’ as user identifiers?",
    "options": {
      "A": "Because they will cause performance issues.",
      "B": "Because this practice may lead to confusion or errors in proofs and outputs.",
      "C": "Because these names are deprecated and not recognized.",
      "D": "Because reserved keywords can only be reused in specific modules."
    },
    "answer": "B"
  },
  {
    "id": "topic4_1",
    "question": "In the described grammar, what is a key restriction on the first character of an identifier?",
    "options": {
      "A": "It can be any symbol or digit.",
      "B": "It must be a letter.",
      "C": "It must be a digit.",
      "D": "It must be a reserved word."
    },
    "answer": "B"
  },
  {
    "id": "topic4_2",
    "question": "Which of the following is NOT allowed as an identifier in the given formalism?",
    "options": {
      "A": "`data1`",
      "B": "`_private`",
      "C": "`channel` (as an identifier)",
      "D": "`if`"
    },
    "answer": "D"
  },
  {
    "id": "topic4_3",
    "question": "What does the non-terminal ⟨nat⟩ represent in this grammar?",
    "options": {
      "A": "Integer numbers including negative values.",
      "B": "Natural numbers (non-negative integers).",
      "C": "Floating-point numbers.",
      "D": "Identifiers starting with a digit."
    },
    "answer": "B"
  },
  {
    "id": "topic4_4",
    "question": "Which of the following best describes ⟨typeid⟩ in the formalism?",
    "options": {
      "A": "It only represents reserved words.",
      "B": "It represents types denoted by identifiers or the reserved word `channel`.",
      "C": "It denotes numeric types only.",
      "D": "It represents any keyword or identifier."
    },
    "answer": "B"
  },
  {
    "id": "topic4_5",
    "question": "Given the precedence rules in the grammar, which operator has the lowest precedence?",
    "options": {
      "A": "==>",
      "B": "+",
      "C": "&&",
      "D": "||"
    },
    "answer": "A"
  },
  {
    "id": "topic4_6",
    "question": "In the formal syntax, how are sequences of identifiers (seq+⟨ident⟩) defined?",
    "options": {
      "A": "Zero or more identifiers separated by spaces.",
      "B": "One or more identifiers separated by commas.",
      "C": "Exactly one identifier.",
      "D": "Identifiers separated by semicolons."
    },
    "answer": "B"
  },
  {
    "id": "topic4_7",
    "question": "What is the semantic role of the reserved word `event` in this context?",
    "options": {
      "A": "Declaring a new type.",
      "B": "Defining events with associated parameters and optional annotations.",
      "C": "Defining private data.",
      "D": "Creating conditional branches in processes."
    },
    "answer": "B"
  },
  {
    "id": "topic4_8",
    "question": "Which of the following choices correctly describes the form of a pattern (⟨pattern⟩)?",
    "options": {
      "A": "Only identifiers without type annotations.",
      "B": "Identifiers optionally annotated with types, natural numbers, or combinations thereof.",
      "C": "Identifiers starting with digits only.",
      "D": "Only type identifiers enclosed in brackets."
    },
    "answer": "B"
  },
  {
    "id": "topic4_9",
    "question": "Which of the following is an example of a valid ⟨gbinding⟩ declaration?",
    "options": {
      "A": "`123 = someTerm;`",
      "B": "`!42 = someTerm; ident = anotherTerm`",
      "C": "`function name = call`",
      "D": "`channel = someValue`"
    },
    "answer": "B"
  },
  {
    "id": "topic4_10",
    "question": "What does a lemma typically include according to the given formalism?",
    "options": {
      "A": "Only conditional statements.",
      "B": "Only function definitions.",
      "C": "One or more guarded terms possibly qualified by public or secret variable declarations.",
      "D": "Reserved words redefined as identifiers."
    },
    "answer": "C"
  },
  {
    "id": "topic5_1",
    "question": "In ProVerif, which of the following operators represents the term equality check between two terms M and N?",
    "options": {
      "A": "M <> N",
      "B": "M = N",
      "C": "not(M)",
      "D": "M && N"
    },
    "answer": "B"
  },
  {
    "id": "topic5_2",
    "question": "Which operator in ProVerif is used to express the negation of a term M?",
    "options": {
      "A": "M || N",
      "B": "M && N",
      "C": "not(M)",
      "D": "M <> N"
    },
    "answer": "C"
  },
  {
    "id": "topic5_3",
    "question": "What is the purpose of the operator ‘new n : t; P’ in ProVerif processes?",
    "options": {
      "A": "To declare a constant named n of type t used globally",
      "B": "To create a fresh name n of type t restricted to process P",
      "C": "To output the name n of type t to process P",
      "D": "To declare a variable n of type t used in process P"
    },
    "answer": "B"
  },
  {
    "id": "topic5_4",
    "question": "In the context of ProVerif, what does the operator ‘if M then P else Q’ accomplish?",
    "options": {
      "A": "It loops executing process P while M holds true",
      "B": "It conditionally executes process P if M evaluates to true, else executes Q",
      "C": "It defines a non-deterministic choice between P and Q",
      "D": "It outputs messages M to processes P and Q"
    },
    "answer": "B"
  },
  {
    "id": "topic5_5",
    "question": "Which operator correctly represents the conjunction (logical AND) of two terms M and N in ProVerif?",
    "options": {
      "A": "M || N",
      "B": "M && N",
      "C": "not(M)",
      "D": "M = N"
    },
    "answer": "B"
  },
  {
    "id": "topic5_6",
    "question": "When modeling message transmission in ProVerif, which operator is used to represent sending a message N on channel M followed by process P?",
    "options": {
      "A": "in(M, N); P",
      "B": "out(M, N); P",
      "C": "new M; out(N, P)",
      "D": "get(M, N); P"
    },
    "answer": "B"
  },
  {
    "id": "topic5_7",
    "question": "What kind of ProVerif process does the operator ‘!P’ denote?",
    "options": {
      "A": "A conditional statement depending on P",
      "B": "The null process that does nothing",
      "C": "The replication of process P indefinitely",
      "D": "Parallel composition of process P with itself"
    },
    "answer": "C"
  },
  {
    "id": "topic5_8",
    "question": "Which of the following operators is used in ProVerif to represent the disjunction (logical OR) of two terms M and N?",
    "options": {
      "A": "M && N",
      "B": "M || N",
      "C": "not(M)",
      "D": "M = N"
    },
    "answer": "B"
  },
  {
    "id": "topic5_9",
    "question": "If you want to represent parallel execution of two processes P and Q in ProVerif, which operator do you use?",
    "options": {
      "A": "P ; Q",
      "B": "P | Q",
      "C": "!P | Q",
      "D": "new P; Q"
    },
    "answer": "B"
  },
  {
    "id": "topic5_10",
    "question": "In ProVerif, what does the operator ‘in(M, x: t); P’ represent?",
    "options": {
      "A": "Receiving a message from channel M and storing it in variable x of type t before executing P",
      "B": "Sending a message M with payload x of type t followed by P",
      "C": "Declaring a new input channel M of type t used by P",
      "D": "Replicating process P x times on channel M"
    },
    "answer": "A"
  },
  {
    "id": "topic6_1",
    "question": "In the grammar described, which of the following characters can the first character of an identifier ⟨ident⟩ be?",
    "options": {
      "A": "Digit (0-9)",
      "B": "Underscore (_)",
      "C": "A letter (a-z, A-Z)",
      "D": "Single-quote (’)"
    },
    "answer": "C"
  },
  {
    "id": "topic6_2",
    "question": "According to the provided grammar, which of the following is *not* allowed inside an identifier ⟨ident⟩ after the first character?",
    "options": {
      "A": "Accented letters from the ISO Latin 1 character set",
      "B": "Digits (0-9)",
      "C": "Reserved words of the language",
      "D": "Underscores (_)"
    },
    "answer": "C"
  },
  {
    "id": "topic6_3",
    "question": "What kind of comment syntax does the described language support?",
    "options": {
      "A": "Single line comments starting with //",
      "B": "Comments surrounded by (* and *), with support for nested comments",
      "C": "Block comments with /* and */, no nesting",
      "D": "Comments starting with # until the end of the line"
    },
    "answer": "B"
  },
  {
    "id": "topic6_4",
    "question": "Which symbol set correctly represents the precedences of infix operators from low to high in the grammar?",
    "options": {
      "A": "&&, ||, =, <>, <=, >=, <, >, +, -",
      "B": "||, &&, =, <>, <=, >=, <, >, +, -",
      "C": "=, ||, &&, <>, <=, >=, <, >, +, -",
      "D": "||, &&, <>, =, <=, >=, <, >, +, -"
    },
    "answer": "B"
  },
  {
    "id": "topic6_5",
    "question": "In the grammar, what is the associativity of the + and - operators?",
    "options": {
      "A": "Right associative",
      "B": "Left associative",
      "C": "Non-associative",
      "D": "Both left and right associative depending on context"
    },
    "answer": "B"
  },
  {
    "id": "topic6_6",
    "question": "According to the grammar rules, which function symbols are *disallowed* in reduc and equation declarations after parsing?",
    "options": {
      "A": "Constructors such as f, g, h",
      "B": "Logical operators like ||, &&, =, <>, <=, >=, <, >, - and not",
      "C": "Names representing atomic data such as keys and nonces",
      "D": "Variables substituted by terms"
    },
    "answer": "B"
  },
  {
    "id": "topic6_7",
    "question": "What do the delimiters {{ and }} represent in the structural grammar of processes?",
    "options": {
      "A": "They mark the start and end of sequences in terms.",
      "B": "They denote sets or multisets of processes.",
      "C": "They group function symbols for application.",
      "D": "They separate elements inside an identifier."
    },
    "answer": "B"
  },
  {
    "id": "topic6_8",
    "question": "In the process grammar, which inference rule corresponds to restricting a name in the environment, i.e., binding a new name?",
    "options": {
      "A": "(PAR) E,P∪{{P |Q}},A− → E,P∪{{P,Q}},A",
      "B": "(REPL) E,P∪{{!P}},A− → E,P∪{{P,!P}},A",
      "C": "(RESTR) E,P∪{{new a; P}},A− → E∪{a′},P∪{{P{a′/a}}},A if a′̸∈E",
      "D": "(I/O) E,P∪{{out(N,M); P,in(N,x); Q}},A → …"
    },
    "answer": "C"
  },
  {
    "id": "topic6_9",
    "question": "How are variables and names differentiated in the grammar regarding their roles?",
    "options": {
      "A": "Variables range over names, and names range over variables.",
      "B": "Names represent atomic data such as keys/nonces; variables can be substituted by terms.",
      "C": "Both variables and names are interchangeable in declarations.",
      "D": "Variables represent atomic data, and names can be substituted by terms."
    },
    "answer": "B"
  },
  {
    "id": "topic6_10",
    "question": "Which of the following delimiters are used for grouping optional sequences of identifiers as options in the grammar?",
    "options": {
      "A": "()",
      "B": "[]",
      "C": "{{}}",
      "D": ";;"
    },
    "answer": "B"
  },
  {
    "id": "topic7_1",
    "question": "In ProVerif, which of the following is used to start a single-line comment?",
    "options": {
      "A": "/*",
      "B": "//",
      "C": "#",
      "D": "--"
    },
    "answer": "C"
  },
  {
    "id": "topic7_2",
    "question": "How does ProVerif treat multiple spaces, tabs, or newlines between tokens in its input language?",
    "options": {
      "A": "They change the meaning of the code significantly.",
      "B": "They are ignored and treated as whitespace.",
      "C": "Tabs are allowed but spaces are not.",
      "D": "Newlines terminate statements like in some programming languages."
    },
    "answer": "B"
  },
  {
    "id": "topic7_3",
    "question": "What is the primary role of whitespace (spaces, tabs, newlines) in ProVerif scripts?",
    "options": {
      "A": "To separate tokens and improve readability without affecting semantics.",
      "B": "To indent code blocks and define scope.",
      "C": "To indicate line breaks that terminate statements.",
      "D": "To mark comments in the code."
    },
    "answer": "A"
  },
  {
    "id": "topic7_4",
    "question": "Which of the following best describes multiline comments in ProVerif?",
    "options": {
      "A": "Enclosed between /* and */",
      "B": "Enclosed between <!-- and -->",
      "C": "ProVerif supports only single-line comments starting with #",
      "D": "Enclosed between /** and **/"
    },
    "answer": "C"
  },
  {
    "id": "topic7_5",
    "question": "If a syntax error occurs at a certain character position, how does ProVerif help the user locate it?",
    "options": {
      "A": "ProVerif fixes the error automatically.",
      "B": "It provides the line and column number of the error.",
      "C": "It prints the entire file with error highlights.",
      "D": "It only shows a generic error message without location."
    },
    "answer": "B"
  },
  {
    "id": "topic7_6",
    "question": "In ProVerif, can identifiers be separated by any amount of whitespace including multiple newlines?",
    "options": {
      "A": "No, only a single space is allowed between tokens.",
      "B": "Yes, any number of spaces, tabs, or newlines can separate tokens.",
      "C": "Only newlines but not tabs are allowed between tokens.",
      "D": "Tokens must be adjacent without any whitespace."
    },
    "answer": "B"
  },
  {
    "id": "topic7_7",
    "question": "Regarding line continuation, how does ProVerif interpret a process declaration that spans multiple lines?",
    "options": {
      "A": "It treats each line as a separate statement unless terminated by a semicolon.",
      "B": "Whitespace allows statements to continue over multiple lines without special characters.",
      "C": "Newlines must be escaped with backslashes to continue lines.",
      "D": "Statements cannot span multiple lines in ProVerif."
    },
    "answer": "B"
  },
  {
    "id": "topic7_8",
    "question": "Why is it important to use whitespace correctly in ProVerif models?",
    "options": {
      "A": "Because incorrect whitespace can cause runtime errors during protocol execution.",
      "B": "Because ProVerif uses whitespace to infer data types.",
      "C": "Because whitespace separates tokens; incorrect spacing can cause syntax errors.",
      "D": "Whitespace is not important at all in ProVerif."
    },
    "answer": "C"
  },
  {
    "id": "topic7_9",
    "question": "Which of the following is NOT a reserved keyword in ProVerif and thus can be used as an identifier?",
    "options": {
      "A": "new",
      "B": "if",
      "C": "channel",
      "D": "handshake"
    },
    "answer": "D"
  },
  {
    "id": "topic7_10",
    "question": "How does ProVerif treat tabs within the source code?",
    "options": {
      "A": "Tabs are converted automatically to spaces and are treated as whitespace.",
      "B": "Tabs cause errors and must be avoided.",
      "C": "Tabs indicate block indentation and affect parsing.",
      "D": "Tabs are ignored completely and stripped from input."
    },
    "answer": "A"
  },
  {
    "id": "topic8_1",
    "question": "In ProVerif, how is a constant defined in terms of arity and declaration syntax?",
    "options": {
      "A": "A constant is a function of arity 1 and declared using `fun c(t) : t.`",
      "B": "A constant is a function of arity 0 and declared using `fun c() : t.`",
      "C": "A constant is declared only by `const c : t .` without involving functions.",
      "D": "A constant must be declared as a free name using `free c : t .`"
    },
    "answer": "B"
  },
  {
    "id": "topic8_2",
    "question": "What role do names such as a, b, c, and k play in the ProVerif modeling language?",
    "options": {
      "A": "They represent variables that can be substituted by terms.",
      "B": "They represent atomic data such as keys and nonces.",
      "C": "They are only used as types in function declarations.",
      "D": "They are channels used for communication between processes."
    },
    "answer": "B"
  },
  {
    "id": "topic8_3",
    "question": "Which of the following correctly describes the difference between names and variables in ProVerif?",
    "options": {
      "A": "Names and variables are interchangeable and can be substituted freely.",
      "B": "Names represent atomic data and cannot be substituted, whereas variables can be substituted by terms.",
      "C": "Variables represent atomic data, and names are substituted by terms.",
      "D": "Both are declared without types and function symbols."
    },
    "answer": "B"
  },
  {
    "id": "topic8_4",
    "question": "How are types declared in ProVerif?",
    "options": {
      "A": "They are declared using `var t.`",
      "B": "They are declared using `free t : type.`",
      "C": "They are declared using `type t .`",
      "D": "They are declared implicitly when variables or names are declared."
    },
    "answer": "C"
  },
  {
    "id": "topic8_5",
    "question": "Which construct is used to declare a free name in ProVerif, and what is its syntax?",
    "options": {
      "A": "`const n : t .` where n is a constant name.",
      "B": "`free n : t .` where n is a free name of type t.",
      "C": "`fun n() : t .` defining a function with zero arity.",
      "D": "`letfun n = t .` which defines a let function."
    },
    "answer": "B"
  },
  {
    "id": "topic8_6",
    "question": "What does the function symbol declaration `h(T1,...,Tn) : T` mean in ProVerif?",
    "options": {
      "A": "`h` is a constant symbol with type T.",
      "B": "`h` is a function taking n arguments where each has types T1 to Tn, returning type T.",
      "C": "`h` is a variable that can hold any of the types T1 to Tn.",
      "D": "`h` is a destructor that breaks down types T into T1 to Tn."
    },
    "answer": "B"
  },
  {
    "id": "topic8_7",
    "question": "Which of the following statements about free names in an input file is TRUE?",
    "options": {
      "A": "Free names do not require declaration before use.",
      "B": "Multiple free names of the same type can be declared in a single `free` declaration.",
      "C": "Free names can only be used as function parameters.",
      "D": "Free names represent destructors in the language."
    },
    "answer": "B"
  },
  {
    "id": "topic8_8",
    "question": "What is discouraged by the authors regarding the use of built-in identifiers like `true`, `false`, `attacker` in ProVerif?",
    "options": {
      "A": "Modifying their definitions to suit protocol needs.",
      "B": "Declaring them as constants.",
      "C": "Reusing these built-in identifiers as user-defined identifiers.",
      "D": "Using them as function names only."
    },
    "answer": "C"
  },
  {
    "id": "topic8_9",
    "question": "What is the primary purpose of constructors and destructors in ProVerif's function symbols?",
    "options": {
      "A": "Constructors build complex data from simpler ones; destructors extract components from data.",
      "B": "Both constructors and destructors are used only for variable substitution.",
      "C": "Destructors create new types; constructors delete them.",
      "D": "They are placeholders for types and have no computational semantics."
    },
    "answer": "A"
  },
  {
    "id": "topic8_10",
    "question": "According to the grammar for declarations, which of the following is NOT a valid declaration form?",
    "options": {
      "A": "`free seq+⟨ident⟩: ⟨typeid⟩ ⟨options⟩.`",
      "B": "`const seq+⟨ident⟩: ⟨typeid⟩ ⟨options⟩.`",
      "C": "`fun ⟨ident⟩(seq⟨typeid⟩): ⟨typeid⟩ ⟨options⟩.`",
      "D": "`newtype ⟨ident⟩ : ⟨typeid⟩.`"
    },
    "answer": "D"
  },
  {
    "id": "topic9_1",
    "question": "In the formalism described, what do the identifiers a, b, c, and k mainly represent?",
    "options": {
      "A": "Variables that can be substituted by terms.",
      "B": "Function symbols for constructors and destructors.",
      "C": "Names representing atomic data such as keys and nonces.",
      "D": "Types declared by the user."
    },
    "answer": "C"
  },
  {
    "id": "topic9_2",
    "question": "Which of the following best describes the role of variables like x, y, and z in the system?",
    "options": {
      "A": "They are atomic data elements that cannot be changed.",
      "B": "They can be substituted by terms during process execution.",
      "C": "They represent constant values with fixed types.",
      "D": "They must always be free names declared at the start."
    },
    "answer": "B"
  },
  {
    "id": "topic9_3",
    "question": "How are user-defined types declared in the system?",
    "options": {
      "A": "`type t.`",
      "B": "`free t: var.`",
      "C": "`fun t() : type.`",
      "D": "`const t : var.`"
    },
    "answer": "A"
  },
  {
    "id": "topic9_4",
    "question": "What is the correct syntax to declare free names appearing in an input file?",
    "options": {
      "A": "`var n : t .`",
      "B": "`free n : t .`",
      "C": "`const n : t .`",
      "D": "`fun n() : t .`"
    },
    "answer": "B"
  },
  {
    "id": "topic9_5",
    "question": "Which term best describes the purpose of constructors in this formalism?",
    "options": {
      "A": "Functions that manipulate terms only as constants.",
      "B": "Functions that combine terms into more complex terms.",
      "C": "Operators that only appear in expressions to manipulate variables.",
      "D": "Rewrite rules used for destructors to modify terms."
    },
    "answer": "B"
  },
  {
    "id": "topic9_6",
    "question": "Destructors are defined by which of the following mechanisms in this system?",
    "options": {
      "A": "Declaration of new variables and types.",
      "B": "Application of constructor functions to terms.",
      "C": "An ordered list of rewrite rules of the form `g(U₁,...,Uₙ) → U`.",
      "D": "Assigning constant values to names and variables."
    },
    "answer": "C"
  },
  {
    "id": "topic9_7",
    "question": "What happens if a destructor function symbol's rewrite rules fail to match a term?",
    "options": {
      "A": "The term is left unchanged.",
      "B": "The destructor returns the constant `fail`.",
      "C": "The process aborts immediately without output.",
      "D": "The first rewrite rule is reapplied indefinitely."
    },
    "answer": "B"
  },
  {
    "id": "topic9_8",
    "question": "How does the formalism model constants within the declaration framework?",
    "options": {
      "A": "As functions with no arguments (arity 0), e.g., `fun c() : t.`",
      "B": "As variables declared without type annotations.",
      "C": "Using the `free c : var.` syntax.",
      "D": "As destructors applied to empty terms."
    },
    "answer": "A"
  },
  {
    "id": "topic9_9",
    "question": "Which of the following correctly describes the difference between built-in and user-defined destructors?",
    "options": {
      "A": "Built-in destructors are declared with `fun` only, user-defined with `type`.",
      "B": "User-defined destructors use rewrite rules, built-in have fixed semantic behavior (e.g. not, &&).",
      "C": "Built-in destructors can only return constants, user-defined always return terms.",
      "D": "There is no distinction; all destructors are declared similarly."
    },
    "answer": "B"
  },
  {
    "id": "topic9_10",
    "question": "Why can't modular exponentiation operations be directly represented using destructor rewrite rules in this formalism?",
    "options": {
      "A": "Because rewrite rules can only represent boolean operations.",
      "B": "Because some operations require equations beyond simple rewrite rules.",
      "C": "Because variables cannot be substituted by modular expressions.",
      "D": "Because constructors cannot accept modular exponents as arguments."
    },
    "answer": "B"
  },
  {
    "id": "topic10_1",
    "question": "In the context of ProVerif expressions, what does the evaluation relation \\(D \\Downarrow V\\) represent?",
    "options": {
      "A": "The expression \\(D\\) is syntactically valid and \\(V\\) is a variable.",
      "B": "The expression \\(D\\) evaluates to the value \\(V\\) where \\(V\\) is either a ground term or fail.",
      "C": "\\(D\\) is a destructor that transforms \\(V\\) into \\(D\\).",
      "D": "\\(D\\) and \\(V\\) are equivalent terms by syntactic equality."
    },
    "answer": "B"
  },
  {
    "id": "topic10_2",
    "question": "Which of the following best describes a ground term in the ProVerif syntax?",
    "options": {
      "A": "A term that contains at least one variable.",
      "B": "A constructor with at least one argument that is a variable.",
      "C": "A term that contains no variables.",
      "D": "An expression that always evaluates to fail."
    },
    "answer": "C"
  },
  {
    "id": "topic10_3",
    "question": "What is the role of the constant 'fail' in terms and expressions?",
    "options": {
      "A": "It represents a successful computation result.",
      "B": "It denotes the failure of computation or evaluation.",
      "C": "It is a special constant that stands for true conditions.",
      "D": "It acts as a constructor for tuples."
    },
    "answer": "B"
  },
  {
    "id": "topic10_4",
    "question": "How are expressions extended in ProVerif to include process constructs?",
    "options": {
      "A": "By allowing expressions to reference global variables only.",
      "B": "By including restrictions, expression evaluations (let), and conditionals within expressions.",
      "C": "By replacing variables with constants only.",
      "D": "By restricting the use of destructors in expressions."
    },
    "answer": "B"
  },
  {
    "id": "topic10_5",
    "question": "In the syntax of processes, what does the construct `let x: T = D in P else Q` mean?",
    "options": {
      "A": "It declares variable \\(x\\) as an unrestricted variable.",
      "B": "It defines \\(x\\) by evaluating \\(D\\); if evaluation fails, process \\(Q\\) is executed; otherwise, process \\(P\\).",
      "C": "It runs both \\(P\\) and \\(Q\\) in parallel after evaluating \\(D\\).",
      "D": "It duplicates process \\(P\\) with and without \\(x\\)."
    },
    "answer": "B"
  },
  {
    "id": "topic10_6",
    "question": "Consider the destructor \\(g(U_1,...,U_n) \\to U\\). What happens if no rewrite rule applies during evaluation?",
    "options": {
      "A": "The evaluation proceeds to the next rule.",
      "B": "The evaluation returns a variable.",
      "C": "The evaluation fails and yields the constant fail.",
      "D": "The evaluation returns \\(U\\) by default."
    },
    "answer": "C"
  },
  {
    "id": "topic10_7",
    "question": "How is pattern-matching incorporated in ProVerif’s input constructs?",
    "options": {
      "A": "It is only allowed in output expressions.",
      "B": "It enriches inputs with `in(D, pat); P` to match expressions against patterns during input.",
      "C": "It replaces variables with constants automatically.",
      "D": "Pattern-matching is not supported in process inputs."
    },
    "answer": "B"
  },
  {
    "id": "topic10_8",
    "question": "What is the difference between a term \\(M\\) and an expression \\(D\\) in the ProVerif core language?",
    "options": {
      "A": "\\(M\\) can include process constructs, but \\(D\\) cannot.",
      "B": "\\(M\\) is always ground, while \\(D\\) always contains variables.",
      "C": "\\(M\\) is a term without process constructs, while \\(D\\) can include expressions such as restriction, let, and conditionals.",
      "D": "\\(D\\) only consists of variables, and \\(M\\) only of constants."
    },
    "answer": "C"
  },
  {
    "id": "topic10_9",
    "question": "What is the meaning of `new a: T; D` in expressions?",
    "options": {
      "A": "It deletes the name \\(a\\) from the scope of \\(D\\).",
      "B": "It creates a new name \\(a\\) of type \\(T\\) and then evaluates the enriched term \\(D\\).",
      "C": "It declares a constant \\(a\\) that cannot be used in \\(D\\).",
      "D": "It starts a new process with a fresh variable \\(a\\)."
    },
    "answer": "B"
  },
  {
    "id": "topic10_10",
    "question": "When expressing a process input with pattern matching `in(D, pat); P`, what happens if the received message does not match the pattern?",
    "options": {
      "A": "The process immediately fails.",
      "B": "The input blocks until a matching message is received.",
      "C": "The process continues with \\(P\\) ignoring the input.",
      "D": "The unmatched message is discarded and the process restarts."
    },
    "answer": "B"
  },
  {
    "id": "topic11_1",
    "question": "Which of the following constructs in ProVerif is used to model a process that does nothing?",
    "options": {
      "A": "`!P` (replication)",
      "B": "`0` (nil/null process)",
      "C": "`in(M, x); P` (input process)",
      "D": "`out(M, N); P` (output process)"
    },
    "answer": "B"
  },
  {
    "id": "topic11_2",
    "question": "What is the purpose of the `new n: t; P` construct in a ProVerif process?",
    "options": {
      "A": "To output the name `n` of type `t` on a public channel.",
      "B": "To introduce a fresh name `n` of type `t` with restricted scope in process `P`.",
      "C": "To replicate process `P` infinitely many times.",
      "D": "To test if `n` equals type `t`."
    },
    "answer": "B"
  },
  {
    "id": "topic11_3",
    "question": "In ProVerif, which construct allows conditional execution depending on some term `M`?",
    "options": {
      "A": "`if M then P else Q`",
      "B": "`let x = M in P`",
      "C": "`new M; P`",
      "D": "`event(M); P`"
    },
    "answer": "A"
  },
  {
    "id": "topic11_4",
    "question": "What does the `out(M, N); P` process do in ProVerif?",
    "options": {
      "A": "Outputs message `N` on channel `M`, then continues as process `P`.",
      "B": "Inputs message `N` from channel `M`, then continues as process `P`.",
      "C": "Defines a constant `M` equal to `N`, then executes `P`.",
      "D": "Replicates process `P` with messages `M` and `N`."
    },
    "answer": "A"
  },
  {
    "id": "topic11_5",
    "question": "How does ProVerif represent infinite replication of a process `P`?",
    "options": {
      "A": "`0`",
      "B": "`!P`",
      "C": "`P | P`",
      "D": "`phase n; P`"
    },
    "answer": "B"
  },
  {
    "id": "topic11_6",
    "question": "The `in(M, x: t); P` construct is used to:",
    "options": {
      "A": "Send the value `x` of type `t` on channel `M` and then run `P`.",
      "B": "Receive a message on channel `M`, bind it to variable `x` of type `t`, then run `P`.",
      "C": "Restrict name `x` of type `t` globally.",
      "D": "Test whether `M` equals `x` before executing `P`."
    },
    "answer": "B"
  },
  {
    "id": "topic11_7",
    "question": "What happens inside ProVerif when an `event(e(M1, ..., Mn)); P` construct executes?",
    "options": {
      "A": "The execution of event `e(M1, ..., Mn)` is logged but does not affect the process flow, then `P` runs.",
      "B": "The process terminates immediately without running `P`.",
      "C": "The event replaces `P` in the execution.",
      "D": "The event causes a conditional branch in the process."
    },
    "answer": "A"
  },
  {
    "id": "topic11_8",
    "question": "Why is the `phase n; P` construct used in ProVerif models?",
    "options": {
      "A": "To declare new constants within process `P`.",
      "B": "To synchronize processes globally, allowing processes only in the current phase to run.",
      "C": "To model input/output blocking on channel `n`.",
      "D": "To replicate `P` `n` times."
    },
    "answer": "B"
  },
  {
    "id": "topic11_9",
    "question": "Which of the following best describes parallel composition in ProVerif?",
    "options": {
      "A": "`P | Q` runs processes `P` and `Q` concurrently.",
      "B": "`P | Q` means process `Q` replaces process `P`.",
      "C": "`P | Q` means sequential execution of `P` then `Q`.",
      "D": "`P | Q` defines a choice between processes `P` and `Q`."
    },
    "answer": "A"
  },
  {
    "id": "topic11_10",
    "question": "What is the main reason for using `let x: T = D in D' else D''` in process expressions in ProVerif?",
    "options": {
      "A": "To model input operations.",
      "B": "To perform expression evaluation with conditional branching based on the success of evaluation.",
      "C": "To define new events.",
      "D": "To send messages over a restricted channel."
    },
    "answer": "B"
  },
  {
    "id": "topic12_1",
    "question": "In ProVerif, how are sub-processes specified to facilitate the development of protocols instead of encoding everything into a single main process?",
    "options": {
      "A": "By using global variables shared among processes.",
      "B": "By declaring process macros of the form `let R(x1 : t1, ..., xn : tn) = P`.",
      "C": "By writing each subprocess in a separate input file.",
      "D": "By defining phases that synchronize all subprocesses."
    },
    "answer": "B"
  },
  {
    "id": "topic12_2",
    "question": "What is the purpose of the free name declaration syntax `free n : t.` in ProVerif input files?",
    "options": {
      "A": "To define a type alias for `t`.",
      "B": "To declare a name `n` with its associated type `t`.",
      "C": "To create a macro with name `n`.",
      "D": "To mark `n` as a private variable within a process."
    },
    "answer": "B"
  },
  {
    "id": "topic12_3",
    "question": "Which of the following best describes the effect of expanding a macro invocation such as `R(M1, ..., Mn)` in ProVerif?",
    "options": {
      "A": "It creates a new process that is unrelated to the macro definition.",
      "B": "It replaces the invocation with the sub-process `P` where variables `x1, ..., xn` are substituted by `M1, ..., Mn`.",
      "C": "It generates a comment in the output to document the macro use.",
      "D": "It discards the macro and proceeds with only the main process."
    },
    "answer": "B"
  },
  {
    "id": "topic12_4",
    "question": "How does ProVerif handle multiple copies of a process when the process is under replication?",
    "options": {
      "A": "It merges all copies into a single process without distinction.",
      "B": "Each copy is assigned a unique name (such as \"a n\") to track executions independently.",
      "C": "Replication is not supported in ProVerif.",
      "D": "It halts with an error as replicated processes are ambiguous."
    },
    "answer": "B"
  },
  {
    "id": "topic12_5",
    "question": "What is the main reason for using process macros in ProVerif models according to the given content?",
    "options": {
      "A": "To simplify the representation and make protocol development easier.",
      "B": "To improve runtime performance of the ProVerif tool.",
      "C": "To reduce the number of types needed in the model.",
      "D": "To enforce higher security assumptions automatically."
    },
    "answer": "A"
  },
  {
    "id": "topic12_6",
    "question": "In the phrase `let R' (y : bitstring) = 0.` from a ProVerif model, what does this syntax represent?",
    "options": {
      "A": "A macro named R' with a parameter y of type bitstring that equals the process 0 (inactive).",
      "B": "A free name declaration for R'.",
      "C": "A type declaration for bitstring named R'.",
      "D": "A recursive process definition incorrectly formatted."
    },
    "answer": "A"
  },
  {
    "id": "topic12_7",
    "question": "What is the effect of the `phase n; P phase` construct in ProVerif process definitions?",
    "options": {
      "A": "It marks `P` to start only when the global protocol phase is `n`, synchronizing all processes accordingly.",
      "B": "It declares a macro called `phase`.",
      "C": "It repeats the process `P` `n` times.",
      "D": "It creates a concurrent thread that runs independent of phases."
    },
    "answer": "A"
  },
  {
    "id": "topic12_8",
    "question": "Which of the following statements regarding types in ProVerif is correct?",
    "options": {
      "A": "Types do not need to be declared explicitly; any variable can assume any type.",
      "B": "User-defined types are declared using the syntax `type t.`",
      "C": "Only the type `bitstring` is supported in ProVerif models.",
      "D": "Types are declared inside process bodies, not in declarations."
    },
    "answer": "B"
  },
  {
    "id": "topic12_9",
    "question": "When a macro is defined with the syntax `def name(i1,...,in) { declarations }`, what is the meaning of calling `name(a1,...,an)` in ProVerif?",
    "options": {
      "A": "It calls an external process named `name`.",
      "B": "It expands to the declarations inside `def` with `i1,...,in` substituted by `a1,...,an`.",
      "C": "It creates a new free name called `name`.",
      "D": "It triggers an error because `def` cannot be invoked this way."
    },
    "answer": "B"
  },
  {
    "id": "topic12_10",
    "question": "How does ProVerif present the internal representation of a process when macros are used?",
    "options": {
      "A": "It outputs the process with all macros expanded and assigns unique identifiers to names and variables.",
      "B": "It shows only the macro names without expansions.",
      "C": "It hides the internal details to simplify the output.",
      "D": "It prints the process partially expanded to prevent confusion."
    },
    "answer": "A"
  },
  {
    "id": "topic13_1",
    "question": "In the given formalism, what is mandatory before using any variable or name in a process declaration?",
    "options": {
      "A": "It can be used without prior declaration.",
      "B": "It must be declared with its type before use.",
      "C": "It must be declared only if used inside a function.",
      "D": "Declaration is only required for constructors."
    },
    "answer": "B"
  },
  {
    "id": "topic13_2",
    "question": "How are variables of formulas such as F1, ..., Fm, and F quantified in the clauses?",
    "options": {
      "A": "Existentially quantified by exists x1 : t1, ..., xn : tn.",
      "B": "Universally quantified by forall x1 : t1, ..., xn : tn.",
      "C": "Quantification is optional depending on the variable type.",
      "D": "Variables are left unquantified for flexibility."
    },
    "answer": "B"
  },
  {
    "id": "topic13_3",
    "question": "What happens when formulas F1, ..., Fm, and F do not contain any variables?",
    "options": {
      "A": "The quantifiers forall x1 : t1, ..., xn : tn must still be included.",
      "B": "The quantifiers can be omitted.",
      "C": "Variables must be introduced artificially.",
      "D": "The formula becomes invalid without variables."
    },
    "answer": "B"
  },
  {
    "id": "topic13_4",
    "question": "In the declaration `new a:nonce`, what is the scope of the name `a`?",
    "options": {
      "A": "It is in the scope of variables declared previously.",
      "B": "It is not in the scope of any variables and modeled without arguments.",
      "C": "It inherits the scope of the process it is declared in.",
      "D": "It is globally scoped across all processes."
    },
    "answer": "B"
  },
  {
    "id": "topic13_5",
    "question": "Given a process snippet `in(c, (x: bitstring, y: bitstring)); new b:nonce`, how is the name `b` represented?",
    "options": {
      "A": "As `b[]` without arguments since it is fresh.",
      "B": "As `b[x= M, y = N]` representing variables x and y in scope.",
      "C": "As a global name without any bindings.",
      "D": "As `b[x, y]` where x and y are just placeholders."
    },
    "answer": "B"
  },
  {
    "id": "topic13_6",
    "question": "What is the role of constructors and destructors in the given formalism?",
    "options": {
      "A": "They represent variable declarations only.",
      "B": "They are function symbols used for creating and analyzing data terms.",
      "C": "They are reserved keywords that cannot be redefined.",
      "D": "They denote only input/output channels."
    },
    "answer": "B"
  },
  {
    "id": "topic13_7",
    "question": "Why is it recommended to distinctly name names and variables when modeling processes?",
    "options": {
      "A": "To reduce the size of the code only.",
      "B": "To avoid confusion and false attacks due to argument mismatches in biprocesses.",
      "C": "Because the language syntax requires it.",
      "D": "To improve performance during code execution."
    },
    "answer": "B"
  },
  {
    "id": "topic13_8",
    "question": "What does the special type declaration `t or fail` imply for a variable?",
    "options": {
      "A": "The variable can never take the value `fail`.",
      "B": "The variable is only allowed to take the value `fail`.",
      "C": "The variable may take either a value of type `t` or the special value `fail`.",
      "D": "The variable is untyped and can take any value."
    },
    "answer": "C"
  },
  {
    "id": "topic13_9",
    "question": "Which of the following best describes the scope of session identifiers in the internal representation of fresh names?",
    "options": {
      "A": "Session identifiers are optional and can be omitted safely.",
      "B": "Session identifiers are always present and sufficient for soundness.",
      "C": "Session identifiers must be manually added by users.",
      "D": "Session identifiers represent variables to be substituted."
    },
    "answer": "B"
  },
  {
    "id": "topic13_10",
    "question": "What is the consequence of omitting `else 0` in nested if-then-else constructs, according to the content?",
    "options": {
      "A": "It clarifies the conditional branching.",
      "B": "It may create ambiguity about which `if` the `else` applies to.",
      "C": "The program will throw an error during parsing.",
      "D": "It is a recommended style to write concise code."
    },
    "answer": "B"
  },
  {
    "id": "topic14_1",
    "question": "In the context of destructor function symbols in ProVerif, what happens when no rewrite rule applies to a destructor in a term?",
    "options": {
      "A": "The term is evaluated as true.",
      "B": "The destructor succeeds with a default value.",
      "C": "The destructor fails and the whole pattern-matching fails.",
      "D": "The term is skipped and the evaluation continues."
    },
    "answer": "C"
  },
  {
    "id": "topic14_2",
    "question": "What is the main characteristic of a \"simple\" pattern cpat in the given definitions?",
    "options": {
      "A": "It contains only variables and constants without constructors.",
      "B": "Every destructor occurrence =D in cpat is a may-fail constructor term U.",
      "C": "It uses nested destructor function symbols only.",
      "D": "It contains no equals sign (=) in its structure."
    },
    "answer": "B"
  },
  {
    "id": "topic14_3",
    "question": "According to the content, what form must the expression in a conditional statement take in ProVerif to comply with the specified restrictions?",
    "options": {
      "A": "M < N or M > N",
      "B": "M = N",
      "C": "M && N",
      "D": "not M"
    },
    "answer": "B"
  },
  {
    "id": "topic14_4",
    "question": "How are new destructors defined in the system according to the content?",
    "options": {
      "A": "By writing them as public functions without any constraints.",
      "B": "Only by extending the definitions given in Section 3.1.1.",
      "C": "By providing a sequence of rewrite rules specifying pattern matching and reduction.",
      "D": "Through macros that combine constructors and destructors arbitrarily."
    },
    "answer": "C"
  },
  {
    "id": "topic14_5",
    "question": "What is the requirement for a converter function in relation to its argument and the same-type values without conversion?",
    "options": {
      "A": "It must be identical to its argument and type neutral.",
      "B": "It must always produce a value of a different type than its argument.",
      "C": "It must be different from its argument, different also from values of the same type without applying the converter, and must identify which converter was applied.",
      "D": "It can return the same value as the argument if the types match."
    },
    "answer": "C"
  },
  {
    "id": "topic14_6",
    "question": "When matching a pattern f(pat1,...,patn) to a term f(M1,...,Mn), under what condition is this pattern valid according to the provided content?",
    "options": {
      "A": "When f is any function symbol, public or private.",
      "B": "When f is a data constructor and each pati matches Mi for all i ≤ n.",
      "C": "When the destructors are absent in the pattern.",
      "D": "When pat1 matches M1 only and the others are ignored."
    },
    "answer": "B"
  },
  {
    "id": "topic14_7",
    "question": "What must be true about the types of arguments in destructor rewrite rules such as g(M1,1,...,M1,k) = M1,0?",
    "options": {
      "A": "The return type M1,0 can be different from the types of Mi,j.",
      "B": "All arguments M1,1,...,M1,k must have the same type, and M1,0 must have the type specified by the destructor g.",
      "C": "Types do not need to be consistent if the rewrite rules are convergent.",
      "D": "Types of arguments can vary arbitrarily across different rewrite rules."
    },
    "answer": "B"
  },
  {
    "id": "topic14_8",
    "question": "In the process statements like `let x = M in P else Q`, why is it important to consider that M may contain destructor functions?",
    "options": {
      "A": "Because destructors always succeed and simplify evaluation.",
      "B": "Because destructors may fail, causing the entire let expression to fail and trigger the else branch.",
      "C": "Because destructors cause variables to be typed as null.",
      "D": "Because destructors make the term M immutable."
    },
    "answer": "B"
  },
  {
    "id": "topic14_9",
    "question": "Regarding patterns and may-fail constructor terms, what is implied if a pattern contains a destructor function symbol that is not a may-fail constructor term?",
    "options": {
      "A": "The pattern is considered simple.",
      "B": "The pattern cannot be processed and will always fail.",
      "C": "The pattern is not simple, and may require more complex matching semantics.",
      "D": "The pattern automatically succeeds regardless of the term matched."
    },
    "answer": "C"
  },
  {
    "id": "topic14_10",
    "question": "What is the significance of the condition that the expression evaluation construct is removed in the ProVerif subset considered?",
    "options": {
      "A": "To simplify the matching so that only public functions and equality are used.",
      "B": "To allow arbitrary computations in conditionals.",
      "C": "To accept destructors anywhere in the program without limitation.",
      "D": "To increase the complexity of term rewriting and matching."
    },
    "answer": "A"
  },
  {
    "id": "topic15_1",
    "question": "What is ProVerif primarily used to verify in security protocols?",
    "options": {
      "A": "Performance optimization of protocols",
      "B": "Reachability and secrecy properties of terms",
      "C": "User authentication methods",
      "D": "Network topology configurations"
    },
    "answer": "B"
  },
  {
    "id": "topic15_2",
    "question": "In ProVerif, which query is used to test if a term M is secret from an attacker?",
    "options": {
      "A": "query secret(M).",
      "B": "query reachable(M).",
      "C": "query attacker(M).",
      "D": "query accessible(M)."
    },
    "answer": "C"
  },
  {
    "id": "topic15_3",
    "question": "When defining the term M in the secrecy query in ProVerif, what must be true about M?",
    "options": {
      "A": "M can include destructors and free names.",
      "B": "M must be a ground term without destructors but may contain free names.",
      "C": "M can be any variable defined in the process.",
      "D": "M must be a public name only."
    },
    "answer": "B"
  },
  {
    "id": "topic15_4",
    "question": "What does the reachability property in ProVerif determine?",
    "options": {
      "A": "Which protocols are the fastest to execute.",
      "B": "Whether an attacker can derive a specific term from the protocol.",
      "C": "If the protocol satisfies user authentication requirements.",
      "D": "The equivalence between two protocols."
    },
    "answer": "B"
  },
  {
    "id": "topic15_5",
    "question": "Strong secrecy in the context of ProVerif means:",
    "options": {
      "A": "The term cannot be decrypted by any participant in the system.",
      "B": "The adversary cannot distinguish between two protocol executions using different secret values.",
      "C": "The secret remains unchanged during the entire protocol execution.",
      "D": "The secret can be reconstructed only by trusted parties."
    },
    "answer": "B"
  },
  {
    "id": "topic15_6",
    "question": "How does ProVerif model cryptographic primitives in the symbolic (Dolev-Yao) model?",
    "options": {
      "A": "As imperfect black boxes with probabilistic algorithms.",
      "B": "As perfect black boxes modeled by function symbols and equations.",
      "C": "As plaintext strings only.",
      "D": "As random number generators."
    },
    "answer": "B"
  },
  {
    "id": "topic15_7",
    "question": "Which of the following is NOT a category of security properties verified by ProVerif mentioned in the content?",
    "options": {
      "A": "Secrecy",
      "B": "Correspondences",
      "C": "Authentication",
      "D": "Cryptanalysis resistance"
    },
    "answer": "D"
  },
  {
    "id": "topic15_8",
    "question": "The simplest property to verify using ProVerif is:",
    "options": {
      "A": "Equivalence between different protocols.",
      "B": "Strong secrecy of terms.",
      "C": "Full correctness of message ordering.",
      "D": "Performance timing of cryptographic operations."
    },
    "answer": "B"
  },
  {
    "id": "topic15_9",
    "question": "In a ProVerif input file, where should the secrecy query be placed relative to the main process?",
    "options": {
      "A": "After the main process definition",
      "B": "Before the main process definition",
      "C": "Outside the input file",
      "D": "Anywhere; the order does not matter"
    },
    "answer": "B"
  },
  {
    "id": "topic15_10",
    "question": "Which formalizes an adversary in the context of ProVerif’s security analysis?",
    "options": {
      "A": "As an external system with unlimited computational power but limited knowledge of keys.",
      "B": "As a participant who follows the protocol honestly.",
      "C": "As a passive observer with no ability to intercept messages.",
      "D": "As a function symbol inside the protocol process."
    },
    "answer": "A"
  },
  {
    "id": "topic16_1",
    "question": "What is the primary purpose of correspondence assertions in the verification of authentication properties?",
    "options": {
      "A": "To ensure data confidentiality during message exchanges.",
      "B": "To prove that if one event has occurred, then a related event has also occurred or will occur.",
      "C": "To encrypt messages between communicating parties.",
      "D": "To simulate attacker behavior in protocol analysis."
    },
    "answer": "B"
  },
  {
    "id": "topic16_2",
    "question": "In the handshake protocol discussed, what does authentication guarantee about the interaction between client A and server B?",
    "options": {
      "A": "Client A always sends encrypted messages to server B.",
      "B": "Client A genuinely communicates with server B, not an impostor.",
      "C": "Server B can decrypt any message sent by client A.",
      "D": "The messages are sent only once during the session."
    },
    "answer": "B"
  },
  {
    "id": "topic16_3",
    "question": "How does ProVerif internally represent security protocols for verification?",
    "options": {
      "A": "As differential equations describing message flows.",
      "B": "As finite state machines with labeled transitions.",
      "C": "As sets of Horn clauses that can be queried for derivability.",
      "D": "As context-free grammars modeling protocol syntax."
    },
    "answer": "C"
  },
  {
    "id": "topic16_4",
    "question": "Which of the following properties can ProVerif automatically verify?",
    "options": {
      "A": "Secrecy and authentication only.",
      "B": "Only secrecy properties, not authentication.",
      "C": "Secrecy, authentication, and some observational equivalence properties.",
      "D": "Only privacy and traceability properties."
    },
    "answer": "C"
  },
  {
    "id": "topic16_5",
    "question": "What is the significance of the computational soundness results mentioned with respect to ProVerif?",
    "options": {
      "A": "They guarantee that any symbolic proof automatically implies real-world cryptographic security for all protocols.",
      "B": "They show that, for restricted protocols using public-key encryption, symbolic proofs imply security in the computational model.",
      "C": "They prove that computational models are less secure than symbolic models.",
      "D": "They ensure that ProVerif does not require any human guidance during verification."
    },
    "answer": "B"
  },
  {
    "id": "topic16_6",
    "question": "Which logic or formalism does Tamarin use for expressing protocol trace properties?",
    "options": {
      "A": "Propositional logic.",
      "B": "Temporal first-order logic.",
      "C": "Linear temporal logic (LTL).",
      "D": "Modal logic."
    },
    "answer": "B"
  },
  {
    "id": "topic16_7",
    "question": "What role do correspondence assertions play in the formal proof of authentication within a protocol?",
    "options": {
      "A": "They mandate message encryption standards.",
      "B": "They link specific execution events to guarantee authenticity relationships.",
      "C": "They verify key lengths used in the protocol.",
      "D": "They ensure message delivery order."
    },
    "answer": "B"
  },
  {
    "id": "topic16_8",
    "question": "Why is it important that protocol verification tools handle an unbounded number of sessions and message spaces?",
    "options": {
      "A": "To speed up verification by ignoring session limits.",
      "B": "To model realistic adversary capabilities and long-running protocol executions.",
      "C": "Because the tools are designed only for theoretical examples.",
      "D": "To simplify the translation into Horn clauses."
    },
    "answer": "B"
  },
  {
    "id": "topic16_9",
    "question": "What main advantage does ProVerif have over manual protocol verification methods?",
    "options": {
      "A": "It eliminates the need for any underlying cryptographic assumptions.",
      "B": "It automatically translates protocols into a format suitable for automated analysis.",
      "C": "It guarantees no attacks exist on any protocol with no exceptions.",
      "D": "It requires less hardware resources than manual proofs."
    },
    "answer": "B"
  },
  {
    "id": "topic16_10",
    "question": "Which of the following statements best describes the relationship between the Dolev-Yao model and the computational model in ProVerif's verification framework?",
    "options": {
      "A": "The Dolev-Yao model is strictly stronger than the computational model.",
      "B": "A proof in the Dolev-Yao symbolic model implies security in the computational model for a restricted class of protocols.",
      "C": "The computational model ignores public-key encryption, unlike the Dolev-Yao model.",
      "D": "ProVerif cannot perform analysis in the computational model at all."
    },
    "answer": "B"
  },
  {
    "id": "topic1_1",
    "question": "What is the primary relationship between ProVerif's input language and the applied pi calculus?",
    "options": {
      "A": "ProVerif's input language is identical to the applied pi calculus without any modifications.",
      "B": "ProVerif's input language is a dialect of the applied pi calculus, as introduced by Abadi and Fournet (2001) and updated by Abadi et al. (2016).",
      "C": "ProVerif's input language replaces the applied pi calculus entirely with its own custom extensions.",
      "D": "ProVerif's input language is based on the applied pi calculus but only for basic pi calculus processes, excluding cryptography."
    },
    "answer": "B"
  },
  {
    "id": "topic1_2",
    "question": "How does the applied pi calculus extend the pi calculus?",
    "options": {
      "A": "It adds support for destructors and error-handling constructs only.",
      "B": "It extends the pi calculus with function symbols defined by an equational theory.",
      "C": "It simplifies the pi calculus by removing support for cryptographic primitives.",
      "D": "It extends the pi calculus solely through the addition of observational equivalence properties."
    },
    "answer": "B"
  },
  {
    "id": "topic1_3",
    "question": "What is one key difference between ProVerif and the applied pi calculus in terms of handling functions and equations?",
    "options": {
      "A": "ProVerif uses the same equational theories as the applied pi calculus for all functions.",
      "B": "ProVerif uses destructors instead of the equational theories of the applied pi calculus and does not support all equational theories.",
      "C": "ProVerif relies entirely on equational theories but adds more function symbols than the applied pi calculus.",
      "D": "ProVerif and the applied pi calculus both use destructors, but ProVerif limits them to cryptographic contexts."
    },
    "answer": "B"
  },
  {
    "id": "topic1_4",
    "question": "What does ProVerif take as input for modeling a protocol?",
    "options": {
      "A": "A basic pi calculus process without any extensions.",
      "B": "A model of the protocol in an extension of the pi calculus with cryptography, similar to the applied pi calculus.",
      "C": "Only security properties, without any protocol description.",
      "D": "A full implementation of the protocol in a programming language, translated automatically."
    },
    "answer": "B"
  },
  {
    "id": "topic1_5",
    "question": "Which of the following security properties can ProVerif verify based on its structure?",
    "options": {
      "A": "Only secrecy, as it is the primary focus of the applied pi calculus.",
      "B": "Secrecy, authentication (correspondences), and some observational equivalence properties.",
      "C": "Authentication and secrecy, but not observational equivalence, as that is handled by Horn clauses alone.",
      "D": "Observational equivalence properties only, excluding secrecy and authentication."
    },
    "answer": "B"
  },
  {
    "id": "topic1_6",
    "question": "How are cryptographic primitives modeled in ProVerif?",
    "options": {
      "A": "They are modeled exclusively by equational theories, as in the applied pi calculus.",
      "B": "They are modeled by rewrite rules or by equations, allowing for a wide variety of primitives.",
      "C": "They are not modeled directly and must be added as external extensions.",
      "D": "They are modeled only through destructors, without any use of equations."
    },
    "answer": "B"
  },
  {
    "id": "topic1_7",
    "question": "In ProVerif, what do substitutions primarily map when dealing with terms?",
    "options": {
      "A": "Substitutions always map names to expressions for flexibility.",
      "B": "Substitutions always map variables (not names) to terms, and they never substitute fail or a may-fail variable for an ordinary variable.",
      "C": "Substitutions map both variables and names to any type of expression without restrictions.",
      "D": "Substitutions map variables to names only, to maintain the structure of the applied pi calculus."
    },
    "answer": "B"
  },
  {
    "id": "topic1_8",
    "question": "What is the significance of observational equivalence in the context of ProVerif and the applied pi calculus?",
    "options": {
      "A": "ProVerif proves diff-equivalence, which is weaker than observational equivalence, making it less useful.",
      "B": "If two processes are equivalent in the pi calculus, the corresponding applied pi calculus processes are observationally equivalent, but ProVerif focuses on the stronger diff-equivalence.",
      "C": "Observational equivalence is not relevant, as ProVerif only deals with secrecy properties.",
      "D": "ProVerif requires encoding into the applied pi calculus to prove observational equivalence directly."
    },
    "answer": "B"
  },
  {
    "id": "topic1_9",
    "question": "How does ProVerif handle errors compared to the applied pi calculus?",
    "options": {
      "A": "ProVerif does not handle errors, relying entirely on the applied pi calculus's equational theory.",
      "B": "ProVerif has a built-in error-handling construct (like the else branch), whereas the applied pi calculus does not explicitly include this.",
      "C": "Both ProVerif and the applied pi calculus use the same error-handling mechanisms based on destructors.",
      "D": "ProVerif avoids error handling by limiting the use of functions and equations."
    },
    "answer": "B"
  },
  {
    "id": "topic1_10",
    "question": "What role do Horn clauses play in ProVerif's structure for verifying properties?",
    "options": {
      "A": "Horn clauses are used to model protocols directly, without involving derivability queries.",
      "B": "Horn clauses are part of ProVerif's structure for derivability queries, which help in resolution to determine if a property holds or if there's an attack.",
      "C": "Horn clauses are only used in the applied pi calculus and not in ProVerif's verification process.",
      "D": "Horn clauses replace the need for extensions to the pi calculus in ProVerif."
    },
    "answer": "B"
  },
  {
    "id": "topic2_1",
    "question": "What is the primary goal of ProVerif in the context of cryptographic protocols?",
    "options": {
      "A": "To simulate network traffic and detect real-time attacks.",
      "B": "To verify secrecy and authentication properties automatically.",
      "C": "To generate new cryptographic keys for secure communication.",
      "D": "To manually debug protocol implementations."
    },
    "answer": "B"
  },
  {
    "id": "topic2_2",
    "question": "Which of the following protocols has ProVerif been used to verify, based on its applications?",
    "options": {
      "A": "A simple encryption algorithm like AES.",
      "B": "An e-voting protocol for secure elections.",
      "C": "A basic file-sharing system without security features.",
      "D": "A hardware-based access control mechanism."
    },
    "answer": "B"
  },
  {
    "id": "topic2_3",
    "question": "What types of security properties can ProVerif prove for protocols?",
    "options": {
      "A": "Only computational security under specific hardware constraints.",
      "B": "Secrecy, authentication, and observational equivalences.",
      "C": "Performance metrics like speed and efficiency of encryption.",
      "D": "User interface usability in protocol implementations."
    },
    "answer": "B"
  },
  {
    "id": "topic2_4",
    "question": "How does ProVerif model protocols for verification?",
    "options": {
      "A": "Using a simple flowchart diagram of message exchanges.",
      "B": "Through an extension of the Pi calculus with cryptography.",
      "C": "By directly implementing the protocol in a programming language.",
      "D": "With tree-automata to represent message structures only."
    },
    "answer": "B"
  },
  {
    "id": "topic2_5",
    "question": "In ProVerif's verification process, what attacker model is assumed?",
    "options": {
      "A": "An attacker with limited capabilities, restricted to basic eavesdropping.",
      "B": "A powerful attacker with Dolev-Yao capabilities controlling public channels.",
      "C": "An attacker that only targets specific cryptographic primitives.",
      "D": "A collaborative attacker working with the protocol participants."
    },
    "answer": "B"
  },
  {
    "id": "topic2_6",
    "question": "ProVerif has been applied to analyze which of the following major deployed protocols?",
    "options": {
      "A": "A proprietary corporate intranet protocol.",
      "B": "The TLS protocol for secure web communications.",
      "C": "A legacy analog communication system.",
      "D": "A social media data-sharing protocol without encryption."
    },
    "answer": "B"
  },
  {
    "id": "topic2_7",
    "question": "How does ProVerif handle cryptographic primitives during verification?",
    "options": {
      "A": "By ignoring them and focusing only on message exchanges.",
      "B": "Through definitions via rewrite rules or equations.",
      "C": "By requiring physical hardware simulations for accuracy.",
      "D": "By automatically generating new primitives for each session."
    },
    "answer": "B"
  },
  {
    "id": "topic2_8",
    "question": "What does ProVerif output if it identifies a potential attack during verification?",
    "options": {
      "A": "A detailed report on how to fix the attack in code.",
      "B": "Information about the potential attack based on resolution with selection.",
      "C": "Recommendations for alternative protocols only.",
      "D": "Nothing, as it focuses solely on proving properties."
    },
    "answer": "B"
  },
  {
    "id": "topic2_9",
    "question": "In what way has ProVerif been utilized beyond direct protocol verification?",
    "options": {
      "A": "As a front-end for user interface design in security tools.",
      "B": "As a back-end for building other verification tools.",
      "C": "For training AI models on cryptographic patterns.",
      "D": "For real-time monitoring of network security."
    },
    "answer": "B"
  },
  {
    "id": "topic2_10",
    "question": "What key feature allows ProVerif to verify protocols for an unbounded number of sessions?",
    "options": {
      "A": "It limits the message space to ensure quick processing.",
      "B": "It supports an unbounded number of sessions and message space.",
      "C": "It requires manual configuration for each session limit.",
      "D": "It only works with bounded sessions to guarantee termination."
    },
    "answer": "B"
  },
  {
    "id": "topic3_1",
    "question": "According to the specifications, what characters can be included in an identifier after the first character?",
    "options": {
      "A": "Only letters (a-z, A-Z) and digits (0-9).",
      "B": "Letters (a-z, A-Z), digits (0-9), underscores (_), single-quotes ('), and accented letters from the ISO Latin 1 character set.",
      "C": "Any printable characters, as long as the identifier is not a reserved word.",
      "D": "Letters and digits only, with no special characters like underscores."
    },
    "answer": "B"
  },
  {
    "id": "topic3_2",
    "question": "What rule applies to the first character of an identifier in the language?",
    "options": {
      "A": "It must be a digit or a letter.",
      "B": "It must be a letter, which can include accented letters from the ISO Latin 1 character set.",
      "C": "It can be any character, including underscores or digits, as long as the rest is valid.",
      "D": "It must be an uppercase letter to distinguish it from reserved words."
    },
    "answer": "B"
  },
  {
    "id": "topic3_3",
    "question": "Are there any length restrictions specified for identifiers in the language?",
    "options": {
      "A": "Identifiers must be at most 32 characters long.",
      "B": "There are no explicit length restrictions; they can be an unlimited sequence of allowed characters.",
      "C": "Identifiers must be at least 1 character but no more than 64 characters.",
      "D": "The length is limited to the number of characters in reserved words."
    },
    "answer": "B"
  },
  {
    "id": "topic3_4",
    "question": "How does the language handle keyword reservation policies for identifiers?",
    "options": {
      "A": "Identifiers can reuse reserved words as long as they are prefixed with an underscore.",
      "B": "Identifiers must be distinct from reserved words, such as \"channel\" or \"if\".",
      "C": "Reserved words can be used as identifiers in certain contexts, like comments.",
      "D": "Only built-in types like \"bool\" are reserved, but other keywords can be reused."
    },
    "answer": "B"
  },
  {
    "id": "topic3_5",
    "question": "In what way are identifiers case sensitive according to the specifications?",
    "options": {
      "A": "They are not case sensitive, so \"Variable\" and \"variable\" are considered the same.",
      "B": "They are case sensitive, meaning \"Variable\" and \"variable\" are distinct identifiers.",
      "C": "Case sensitivity applies only to the first character of the identifier.",
      "D": "Identifiers become case insensitive when used in declarations."
    },
    "answer": "B"
  },
  {
    "id": "topic3_6",
    "question": "What must be considered when declaring names or variables as identifiers?",
    "options": {
      "A": "They can be declared without specifying a type, as long as they are not reserved words.",
      "B": "They must be declared with their type, such as in a \"new a : t;\" statement.",
      "C": "Types are optional for variables but required for names.",
      "D": "Declaration is only needed if the identifier is used in a function symbol."
    },
    "answer": "B"
  },
  {
    "id": "topic3_7",
    "question": "In noninterf declarations, what restriction applies to identifiers used as function symbols?",
    "options": {
      "A": "Only constructors can be used as identifiers, and names are not allowed.",
      "B": "Any identifiers can be used, including reserved words for convenience.",
      "C": "Only names are allowed as identifiers, but not constructors.",
      "D": "Identifiers must include digits in noninterf declarations."
    },
    "answer": "A"
  },
  {
    "id": "topic3_8",
    "question": "What is recommended regarding the reuse of built-in identifiers like \"bool\" or \"nat\" as user-defined identifiers?",
    "options": {
      "A": "It is encouraged to reuse them to save space in the code.",
      "B": "It is strongly discouraged, as it can lead to confusion in the language.",
      "C": "Built-in identifiers can be reused freely in comments or nested structures.",
      "D": "They must be reused with a prefix, such as \"user_bool\"."
    },
    "answer": "B"
  },
  {
    "id": "topic3_9",
    "question": "How do comments interact with identifier rules in the language?",
    "options": {
      "A": "Comments can include reserved words, which then become valid identifiers.",
      "B": "Comments are surrounded by (* and *), and they do not affect identifier validity, but identifiers inside comments are still checked.",
      "C": "Any identifier used in a comment is automatically reserved and cannot be used elsewhere.",
      "D": "Nested comments allow identifiers to bypass first-character rules."
    },
    "answer": "B"
  },
  {
    "id": "topic3_10",
    "question": "In the context of identifiers for variables, what additional rule applies to their usage in rewrite rules?",
    "options": {
      "A": "Variables as identifiers can include names without any restrictions.",
      "B": "Variables must not contain names, and their types must match the arguments they substitute.",
      "C": "Variables can be substituted by any term, regardless of type declarations.",
      "D": "Only may-fail variables can be used as identifiers in rewrite rules."
    },
    "answer": "B"
  },
  {
    "id": "topic4_1",
    "question": "In the given formalism, what is the key characteristic that distinguishes a keyword from a regular identifier?",
    "options": {
      "A": "Keywords can start with a digit, while identifiers must start with a letter.",
      "B": "Keywords are reserved words with special syntactic meaning, like \"event\" or \"if,\" and cannot be used as identifiers.",
      "C": "Keywords must include accented letters from the ISO Latin 1 set.",
      "D": "Keywords are any sequence of letters and digits, as long as they are not used in processes."
    },
    "answer": "B"
  },
  {
    "id": "topic4_2",
    "question": "Based on the content, what semantic role does the keyword \"event\" play in the language?",
    "options": {
      "A": "It is used to declare a new identifier for natural numbers.",
      "B": "It introduces an event declaration, such as in \"event ev(U1, ..., Un); P,\" to log or track actions in processes.",
      "C": "It serves as an infix operator for comparisons, like equality checks.",
      "D": "It is only used in options for patterns and has no role in process terms."
    },
    "answer": "B"
  },
  {
    "id": "topic4_3",
    "question": "In the grammar provided, why must keywords like \"channel\" be treated differently from user-defined identifiers?",
    "options": {
      "A": "Keywords can be redefined in a process declaration without restrictions.",
      "B": "Keywords have predefined syntactic meanings and are reserved, so they cannot be used as identifiers to avoid conflicts.",
      "C": "Keywords are only required for sequences and can be omitted in simple terms.",
      "D": "Keywords like \"channel\" must always include digits to distinguish them."
    },
    "answer": "B"
  },
  {
    "id": "topic4_4",
    "question": "According to the content, what happens if a programmer tries to use a keyword like \"if\" as an identifier in a process term?",
    "options": {
      "A": "It is allowed, as long as the identifier is prefixed with an underscore.",
      "B": "It results in a syntax error because keywords are reserved and distinct from identifiers.",
      "C": "It can be used freely in conditional statements but not elsewhere.",
      "D": "It requires explicit declaration to override its reserved status."
    },
    "answer": "B"
  },
  {
    "id": "topic4_5",
    "question": "In the context of semantic roles, what is the primary function of the keyword \"new\" in expressions like \"new ⟨ident⟩\"?",
    "options": {
      "A": "It is used to perform arithmetic operations, such as addition or subtraction.",
      "B": "It declares a new identifier for fresh values, often in binding constructs, to ensure uniqueness in processes.",
      "C": "It specifies the precedence of infix operators in the grammar.",
      "D": "It is only used for defining types and has no role in term bindings."
    },
    "answer": "B"
  },
  {
    "id": "topic4_6",
    "question": "From the precedence rules in the content, how do keywords like \"==>\" interact with other elements in the language?",
    "options": {
      "A": "They have the lowest precedence, allowing them to be used interchangeably with identifiers.",
      "B": "They are infix symbols with specific precedence (e.g., \"==>\" has low precedence), defining implication in terms like ⟨gterm⟩ ==> ⟨gterm⟩.",
      "C": "Keywords like \"==>\" must always be followed by a reserved word to be valid.",
      "D": "They associate to the right, unlike standard operators like + and -."
    },
    "answer": "B"
  },
  {
    "id": "topic4_7",
    "question": "In the grammar for ⟨lemma⟩, what role does the keyword \"for\" play when used in constructs like \"⟨gterm⟩ for { public vars seq+⟨ident⟩ }\"?",
    "options": {
      "A": "It is used to define new types and can be omitted if variables are private.",
      "B": "It introduces a specification for variable visibility or secrecy, such as public or secret, in lemmas.",
      "C": "It serves as a comparison operator for checking equality in terms.",
      "D": "It is only applicable in event declarations and not in lemmas."
    },
    "answer": "B"
  },
  {
    "id": "topic4_8",
    "question": "Based on the content, which of the following best describes the keyword \"let\" in expressions like \"let ⟨ident⟩ = ⟨gterm⟩ in ⟨gterm⟩\"?",
    "options": {
      "A": "It is used for creating sequences and has no binding role.",
      "B": "It facilitates variable binding and substitution in terms, allowing definitions within a scope.",
      "C": "It must be declared as an identifier before use in any context.",
      "D": "It only applies to infix operations and not to term bindings."
    },
    "answer": "B"
  },
  {
    "id": "topic4_9",
    "question": "In the semantics section, how are keywords like \"out\" and \"in\" utilized in process terms?",
    "options": {
      "A": "They are optional and can be replaced with user-defined identifiers for flexibility.",
      "B": "They define communication actions, such as \"out(c, D); P\" for output, which are part of the process term contexts.",
      "C": "They are restricted to arithmetic expressions and not used in processes.",
      "D": "They require a phase number to be specified for precedence."
    },
    "answer": "B"
  },
  {
    "id": "topic4_10",
    "question": "According to the content, what restriction applies to keywords in relation to the grammar's non-terminals, such as ⟨gterm⟩?",
    "options": {
      "A": "Keywords can be used freely within ⟨gterm⟩ as long as they are not reserved for types.",
      "B": "Keywords like \"inj-event\" have specific roles in ⟨gterm⟩, such as injecting events, and must be distinct from identifiers.",
      "C": "Keywords are only used in declarations and never in non-terminal expansions like ⟨gterm⟩.",
      "D": "Keywords must include underscores to differentiate them in non-terminals."
    },
    "answer": "B"
  },
  {
    "id": "topic5_1",
    "question": "In ProVerif, what is the primary meaning of the equality operator M = N when used in terms?",
    "options": {
      "A": "It represents a constructor for creating new tuples.",
      "B": "It checks whether two terms are equal, often used in conditions like if statements.",
      "C": "It defines a new variable binding for processes.",
      "D": "It performs a disequality check between terms."
    },
    "answer": "B"
  },
  {
    "id": "topic5_2",
    "question": "How does ProVerif recommend using destructors compared to equations for better performance, based on the heuristics?",
    "options": {
      "A": "Destructors should be avoided as they increase computation cost.",
      "B": "Equations are preferred because they are more precise than destructors.",
      "C": "Using destructors yields better performance than relying on equations.",
      "D": "Destructors and equations should always be used interchangeably without impact."
    },
    "answer": "C"
  },
  {
    "id": "topic5_3",
    "question": "What is the usage method for the conjunction operator M && N in ProVerif terms?",
    "options": {
      "A": "It combines two processes into a parallel composition.",
      "B": "It evaluates to true only if both M and N are true, used for logical AND in conditions.",
      "C": "It creates a new name or variable in the process.",
      "D": "It is used exclusively for message output operations."
    },
    "answer": "B"
  },
  {
    "id": "topic5_4",
    "question": "In ProVerif processes, what does the 'new n: t; P' operator primarily mean and how is it used?",
    "options": {
      "A": "It declares a global constant for the entire protocol.",
      "B": "It creates a fresh name or variable of type t, restricting its scope to process P.",
      "C": "It is used to replicate a process multiple times.",
      "D": "It performs an input operation to receive a message into variable n."
    },
    "answer": "B"
  },
  {
    "id": "topic5_5",
    "question": "What is the meaning and typical usage of the disjunction operator M || N in ProVerif terms?",
    "options": {
      "A": "It sequences two processes one after the other.",
      "B": "It evaluates to true if either M or N (or both) is true, used for logical OR in expressions.",
      "C": "It is equivalent to parallel composition for processes.",
      "D": "It negates the value of a single term."
    },
    "answer": "B"
  },
  {
    "id": "topic5_6",
    "question": "How is the negation operator not(M) used in ProVerif terms?",
    "options": {
      "A": "It inverts the truth value of M, making it useful in conditional statements.",
      "B": "It combines M with another term to form a tuple.",
      "C": "It is used only for process replication.",
      "D": "It checks for equality between M and a fresh random value."
    },
    "answer": "A"
  },
  {
    "id": "topic5_7",
    "question": "In ProVerif, what is the purpose of the parallel composition operator P | Q?",
    "options": {
      "A": "It runs processes P and Q sequentially, one after the other.",
      "B": "It executes processes P and Q concurrently, allowing them to run in parallel.",
      "C": "It restricts the scope of names used in P and Q.",
      "D": "It is used for conditional branching between P and Q."
    },
    "answer": "B"
  },
  {
    "id": "topic5_8",
    "question": "What is the correct usage method for the replication operator !P in ProVerif processes?",
    "options": {
      "A": "It creates a single instance of process P with a new name.",
      "B": "It generates multiple copies of process P that can run indefinitely or in parallel.",
      "C": "It is used to input messages into process P.",
      "D": "It evaluates a condition before executing P."
    },
    "answer": "B"
  },
  {
    "id": "topic5_9",
    "question": "For the conditional operator in ProVerif processes (e.g., if M then P else Q), what must the expression M be to ensure proper usage?",
    "options": {
      "A": "M must always be a constructor application.",
      "B": "M should be of the form an equality like N = K, as specified for the destructor equal.",
      "C": "M can be any arbitrary term without restrictions.",
      "D": "M is typically a disequality operator like N <> K."
    },
    "answer": "B"
  },
  {
    "id": "topic5_10",
    "question": "In ProVerif, how are operators like in(M, x: t); P and out(M, N); P typically used in processes?",
    "options": {
      "A": "They are used for internal variable declarations only.",
      "B": "in(M, x: t); P inputs a message matching pattern M into variable x, while out(M, N); P outputs N on channel M.",
      "C": "They define new function symbols for terms.",
      "D": "They are equivalent to logical operators for term evaluation."
    },
    "answer": "B"
  },
  {
    "id": "topic6_1",
    "question": "In the grammar for sequences like seq+⟨X⟩ = (⟨X⟩,)∗⟨X⟩, what is the primary semantic role of parentheses `()`?",
    "options": {
      "A": "To separate individual elements in a sequence.",
      "B": "To group structural elements, such as enclosing a repeated pattern.",
      "C": "To denote optional components in declarations.",
      "D": "To indicate the end of a binding statement."
    },
    "answer": "B"
  },
  {
    "id": "topic6_2",
    "question": "According to the content, how are semicolons `;` used in the ⟨gbinding⟩ grammar, such as !⟨nat⟩ = ⟨gterm⟩ [; ⟨gbinding⟩]?",
    "options": {
      "A": "To group multiple terms into a single block.",
      "B": "To separate sequential bindings or statements within a declaration.",
      "C": "To indicate repetition of elements in a sequence.",
      "D": "To denote the start of a new identifier."
    },
    "answer": "B"
  },
  {
    "id": "topic6_3",
    "question": "In the definition of sequences like ⟨X⟩, . . .,⟨X⟩, what is the usage rule for the dot `.` symbol?",
    "options": {
      "A": "It is used to concatenate strings or terms directly.",
      "B": "It serves as an ellipsis to represent a continuation or repetition of elements in a sequence.",
      "C": "It indicates the end of a comment block.",
      "D": "It groups optional parameters in function symbols."
    },
    "answer": "B"
  },
  {
    "id": "topic6_4",
    "question": "For the ⟨failtypedecl⟩ grammar, such as seq+⟨ident⟩: ⟨typeid⟩[or fail][,⟨failtypedecl⟩], what is the semantic interpretation of brackets `[]`?",
    "options": {
      "A": "They are used to enclose mandatory sequences of identifiers.",
      "B": "They indicate optional components that may or may not appear.",
      "C": "They group multiple declarations into a single block.",
      "D": "They separate elements in a list of bindings."
    },
    "answer": "B"
  },
  {
    "id": "topic6_5",
    "question": "In the context of process rules like E,P∪{{out(N,M); P,in(N,x); Q}},A, what role do braces `{}` play in the semantic interpretation?",
    "options": {
      "A": "They are used to denote sets or collections of elements, such as processes or actions.",
      "B": "They separate individual terms in a sequence.",
      "C": "They indicate optional parameters in declarations.",
      "D": "They represent repetition in sequences."
    },
    "answer": "A"
  },
  {
    "id": "topic6_6",
    "question": "Based on the precedence rules and grammar, such as &&(true, u) → u, how are parentheses `()` typically used in function symbols?",
    "options": {
      "A": "To mark the beginning of a comment.",
      "B": "To group arguments or parameters for functions and operators.",
      "C": "To separate keywords from identifiers.",
      "D": "To indicate a sequence of natural numbers."
    },
    "answer": "B"
  },
  {
    "id": "topic6_7",
    "question": "In the ⟨gbinding⟩ rule like !⟨nat⟩ = ⟨gterm⟩ [; ⟨gbinding⟩], what is the key usage rule for the semicolon `;` in relation to structural elements?",
    "options": {
      "A": "It groups related terms into a single expression.",
      "B": "It acts as a separator for multiple bindings, allowing chained declarations.",
      "C": "It denotes the end of an entire sequence.",
      "D": "It is used exclusively for optional elements."
    },
    "answer": "B"
  },
  {
    "id": "topic6_8",
    "question": "For sequences described as (⟨X⟩,)∗⟨X⟩, what is the semantic interpretation of the dot `.` when it appears in patterns like ⟨X⟩, . . .,⟨X⟩?",
    "options": {
      "A": "It represents direct access to a sub-element in a term.",
      "B": "It indicates an ellipsis for showing a series or continuation of similar elements.",
      "C": "It separates function symbols from their arguments.",
      "D": "It encloses optional bindings."
    },
    "answer": "B"
  },
  {
    "id": "topic6_9",
    "question": "In declarations like ⟨options⟩ ::= [ [seq+⟨ident⟩]], how do brackets `[]` function in terms of grouping or separating elements?",
    "options": {
      "A": "They are used to create mandatory lists of identifiers.",
      "B": "They enclose optional sequences, allowing for flexibility in the structure.",
      "C": "They separate processes in parallel compositions.",
      "D": "They indicate the precedence of operators."
    },
    "answer": "B"
  },
  {
    "id": "topic6_10",
    "question": "Considering the overall grammar, such as in E,P∪{{P |Q}},A, what is the primary role of braces `{}` in grouping structural elements?",
    "options": {
      "A": "To separate individual actions or processes in a set.",
      "B": "To group elements into sets, facilitating the representation of collections like processes.",
      "C": "To denote repetition in sequences.",
      "D": "To indicate optional components in bindings."
    },
    "answer": "B"
  },
  {
    "id": "topic7_1",
    "question": "In ProVerif, what is the correct syntax for writing a comment in the code?",
    "options": {
      "A": "Using // at the beginning of the line, like in C++.",
      "B": "Enclosing the text in (* and *), such as (* this is a comment *).",
      "C": "Starting with a # symbol, like in shell scripts.",
      "D": "Using single quotes around the text, such as 'this is a comment'."
    },
    "answer": "B"
  },
  {
    "id": "topic7_2",
    "question": "How can comments in ProVerif span multiple lines?",
    "options": {
      "A": "By using // on each line separately.",
      "B": "By enclosing the entire block in (* and *).",
      "C": "By indenting each line with spaces or tabs.",
      "D": "Comments cannot span multiple lines; they must be single-line only."
    },
    "answer": "B"
  },
  {
    "id": "topic7_3",
    "question": "What is the primary role of spaces in ProVerif code, such as between keywords and identifiers?",
    "options": {
      "A": "Spaces are required for proper indentation and must match a specific number per line.",
      "B": "Spaces separate tokens (e.g., keywords, variables) but do not affect the code's meaning otherwise.",
      "C": "Spaces are ignored entirely, and code can be written without any spaces between elements.",
      "D": "Spaces denote the start of a new process or declaration."
    },
    "answer": "B"
  },
  {
    "id": "topic7_4",
    "question": "In ProVerif, are tabs interchangeable with spaces for separating elements in the code?",
    "options": {
      "A": "No, only spaces can be used; tabs will cause syntax errors.",
      "B": "Yes, both tabs and spaces can be used as whitespace to separate tokens.",
      "C": "Tabs must be used exclusively for readability, while spaces are for alignment.",
      "D": "Tabs are only allowed inside comments, not in the main code."
    },
    "answer": "B"
  },
  {
    "id": "topic7_5",
    "question": "How do newline characters function in ProVerif code, particularly in process declarations?",
    "options": {
      "A": "Newlines are required after every statement to indicate its end.",
      "B": "Newlines act as whitespace and are treated similarly to spaces for token separation.",
      "C": "Newlines must be avoided; all code should be written on a single line.",
      "D": "Newlines only affect the execution if they are inside a comment."
    },
    "answer": "B"
  },
  {
    "id": "topic7_6",
    "question": "What happens if extra spaces are added between elements in a ProVerif expression, such as in \"out ( N , M ) ; P\"?",
    "options": {
      "A": "The code will result in a syntax error due to inconsistent spacing.",
      "B": "Extra spaces are ignored, as long as tokens (like \"out\" and \"N\") are properly separated.",
      "C": "Spaces must be exactly one character between each element for the code to compile.",
      "D": "Extra spaces change the meaning of the expression, altering its behavior."
    },
    "answer": "B"
  },
  {
    "id": "topic7_7",
    "question": "In ProVerif, do comments play any role in the execution or analysis of the code?",
    "options": {
      "A": "Yes, comments can be used to define variables or events that affect the process.",
      "B": "No, comments are entirely ignored by ProVerif during parsing and analysis.",
      "C": "Comments only affect execution if they contain specific keywords like \"new\".",
      "D": "Yes, but only if they are placed at the beginning of the file."
    },
    "answer": "B"
  },
  {
    "id": "topic7_8",
    "question": "What is the impact of omitting whitespace (e.g., spaces or tabs) between two keywords in ProVerif, such as writing \"out(N,M);P\" without spaces?",
    "options": {
      "A": "ProVerif will automatically add the necessary whitespace.",
      "B": "It will cause a syntax error because tokens must be separated.",
      "C": "The code will execute correctly as long as the keywords are valid.",
      "D": "Whitespace is optional and only needed for readability."
    },
    "answer": "B"
  },
  {
    "id": "topic7_9",
    "question": "In ProVerif, how should whitespace be managed in complex structures, like function applications or process compositions?",
    "options": {
      "A": "Whitespace must be minimized to avoid increasing file size.",
      "B": "Spaces or tabs should be used flexibly to separate elements, but they do not alter semantics.",
      "C": "Only newlines can be used; spaces and tabs are prohibited in such structures.",
      "D": "Whitespace inside structures like functions must exactly match the declared syntax."
    },
    "answer": "B"
  },
  {
    "id": "topic7_10",
    "question": "Based on ProVerif's syntax rules, what best describes the role of tabs in improving code readability without affecting functionality?",
    "options": {
      "A": "Tabs cannot be used at all; only spaces are allowed for any purpose.",
      "B": "Tabs can be used for indentation, similar to spaces, as both are forms of whitespace.",
      "C": "Tabs must replace spaces in all cases to ensure proper parsing.",
      "D": "Tabs are only useful inside comments and have no role in the main code."
    },
    "answer": "B"
  },
  {
    "id": "topic8_1",
    "question": "What is the correct syntax for declaring a user-defined type in the language?",
    "options": {
      "A": "free t : type.",
      "B": "type t .",
      "C": "const t : typeid.",
      "D": "fun t() : type."
    },
    "answer": "B"
  },
  {
    "id": "topic8_2",
    "question": "In the system, what is the primary role of names like 'a' or 'k'?",
    "options": {
      "A": "They represent variables that can be substituted by terms.",
      "B": "They act as atomic data, such as keys or nonces.",
      "C": "They are used exclusively for function symbols.",
      "D": "They must be declared as destructors."
    },
    "answer": "B"
  },
  {
    "id": "topic8_3",
    "question": "How must free names be introduced in an input file according to the language rules?",
    "options": {
      "A": "They can be used directly without any declaration.",
      "B": "They must be declared using the syntax \"free n : t .\".",
      "C": "They are automatically generated as part of process declarations.",
      "D": "They only need to be declared if they are used in destructors."
    },
    "answer": "B"
  },
  {
    "id": "topic8_4",
    "question": "What is a key difference between variables and names in terms of their roles?",
    "options": {
      "A": "Variables represent atomic data, while names can be substituted by terms.",
      "B": "Names represent atomic data, while variables can be substituted by terms.",
      "C": "Both are interchangeable and can serve the same purpose in processes.",
      "D": "Variables must be declared with types, but names do not require types."
    },
    "answer": "B"
  },
  {
    "id": "topic8_5",
    "question": "Which declaration method is used to introduce constants in the language?",
    "options": {
      "A": "Using \"fun c() : t.\" or \"const c : t .\".",
      "B": "Only through \"free c : t .\".",
      "C": "Via \"reduc c : t .\".",
      "D": "Constants are automatically introduced in processes without declaration."
    },
    "answer": "A"
  },
  {
    "id": "topic8_6",
    "question": "Why is the language described as strongly typed, and how does this affect declarations?",
    "options": {
      "A": "It allows declarations without specifying types, making them optional.",
      "B": "It requires all free names, variables, and function symbols to be declared with their types.",
      "C": "It only applies types to constants, ignoring names and variables.",
      "D": "Strong typing means types can be changed dynamically during processes."
    },
    "answer": "B"
  },
  {
    "id": "topic8_7",
    "question": "What mechanism is used to introduce function symbols, and what does their declaration specify?",
    "options": {
      "A": "They are declared with \"free h : t .\", specifying only the output type.",
      "B": "They are declared as \"h(T1,...,Tn) : T\", specifying input and output types.",
      "C": "They use \"const h(T1,...,Tn) : T\" and do not require types.",
      "D": "Function symbols are predefined and cannot be user-declared."
    },
    "answer": "B"
  },
  {
    "id": "topic8_8",
    "question": "In the context of modeling features, what role do constants play in processes?",
    "options": {
      "A": "They act as variables that change during execution.",
      "B": "They represent fixed values, defined as functions of arity 0 or via \"const c : t .\".",
      "C": "They are used only for destructors and not in main processes.",
      "D": "Constants must be declared as free names to function properly."
    },
    "answer": "B"
  },
  {
    "id": "topic8_9",
    "question": "Which of the following options correctly describes an introduction mechanism for variables in the system?",
    "options": {
      "A": "Variables are introduced automatically and do not need types.",
      "B": "Variables must be declared with their type and can be substituted by terms in processes.",
      "C": "Variables are the same as names and use the \"free\" keyword.",
      "D": "Variables are declared using \"fun x : t .\"."
    },
    "answer": "B"
  },
  {
    "id": "topic8_10",
    "question": "What additional options might be associated with declarations like \"free\" or \"const\", and how do they relate to their roles?",
    "options": {
      "A": "Options like \"private\" for free declarations enhance security by restricting access.",
      "B": "Options are not needed, as declarations are always public.",
      "C": "Options such as \"typeConverter\" are used only for processes, not declarations.",
      "D": "Declarations like \"const\" use options like \"induction\" for verification."
    },
    "answer": "A"
  },
  {
    "id": "topic9_1",
    "question": "In the formalism described, what is the primary method for declaring a type for names or variables?",
    "options": {
      "A": "Using the syntax \"free n : t\" directly in the process.",
      "B": "Using the syntax \"type t.\" to define a user-defined type.",
      "C": "Declaring it only when using constructors in rewrite rules.",
      "D": "It is automatically inferred from the context without explicit declaration."
    },
    "answer": "B"
  },
  {
    "id": "topic9_2",
    "question": "What role do constructor function symbols, such as 'f', play in the system?",
    "options": {
      "A": "They manipulate existing terms using rewrite rules.",
      "B": "They build new terms by applying functions to variables or names.",
      "C": "They are used exclusively for defining destructors.",
      "D": "They represent atomic data like keys and nonces."
    },
    "answer": "B"
  },
  {
    "id": "topic9_3",
    "question": "How are destructors, such as 'g', introduced in the system according to the content?",
    "options": {
      "A": "Through a simple \"fun g(t1, ..., tk) : t\" declaration without rules.",
      "B": "Via rewrite rules in a \"reduc\" declaration, specifying patterns like \"g(M1,1, ..., M1,k) = M1,0\".",
      "C": "By declaring them as constants with \"const g : t\".",
      "D": "They are built-in and do not require explicit introduction."
    },
    "answer": "B"
  },
  {
    "id": "topic9_4",
    "question": "In terms of definition methods, what must be specified when defining a destructor using rewrite rules?",
    "options": {
      "A": "Only the input terms, as the output is optional.",
      "B": "An ordered list of rules in the form \"forall x1,1 : t1,1; g(M1,1, ..., M1,k) = M1,0\".",
      "C": "The destructor's arity without any patterns or outputs.",
      "D": "A single rule that applies universally to all terms."
    },
    "answer": "B"
  },
  {
    "id": "topic9_5",
    "question": "What is the role of destructors in the system when processing terms?",
    "options": {
      "A": "They create new terms from variables and names.",
      "B": "They manipulate terms formed by constructors, as defined by rewrite rules, and may result in 'fail' if no rule applies.",
      "C": "They are used only for declaring types and free names.",
      "D": "They substitute variables without altering the structure."
    },
    "answer": "B"
  },
  {
    "id": "topic9_6",
    "question": "According to the introduction mechanisms, how can constants be declared in the system?",
    "options": {
      "A": "Only as functions with arity greater than zero, like \"fun c(t1) : t\".",
      "B": "As a function of arity zero using \"fun c() : t\" or specifically with \"const c : t\".",
      "C": "Through rewrite rules in a \"reduc\" declaration.",
      "D": "They must be declared as variables with types."
    },
    "answer": "B"
  },
  {
    "id": "topic9_7",
    "question": "In the context of destructors, what happens if none of the rewrite rules in the ordered list are applicable?",
    "options": {
      "A": "The destructor automatically succeeds with a default output.",
      "B": "ProVerif tries the rules in reverse order until one works.",
      "C": "The destructor fails, as no reduction can be applied.",
      "D": "It generates a new rule based on the input terms."
    },
    "answer": "C"
  },
  {
    "id": "topic9_8",
    "question": "What is a key difference in the roles of constructors and destructors based on their definition methods?",
    "options": {
      "A": "Constructors are defined by rewrite rules, while destructors build terms.",
      "B": "Constructors build terms and appear in term applications, while destructors manipulate terms via ordered rewrite rules.",
      "C": "Both are identical and can be used interchangeably in processes.",
      "D": "Destructors are only for atomic data, and constructors handle variables."
    },
    "answer": "B"
  },
  {
    "id": "topic9_9",
    "question": "For extended destructors as introduced in the content, what additional feature allows for more complex behaviors?",
    "options": {
      "A": "They can be defined without any types or arity.",
      "B": "They support an extended way using \"fun g(t1, ..., tk) : t\" combined with \"reduc\" for behaviors beyond basic rewrite rules.",
      "C": "They are limited to built-in operators like 'not' or 'is nat'.",
      "D": "They must be declared as free names first."
    },
    "answer": "B"
  },
  {
    "id": "topic9_10",
    "question": "When introducing function symbols in declarations, what must be specified for a constructor or destructor like 'h'?",
    "options": {
      "A": "Only its name, as the type is inferred automatically.",
      "B": "Its arity and types, such as \"h(T1, ..., Tn) : T\", to indicate how it processes inputs and outputs.",
      "C": "It can be used without declaration if it's a built-in symbol.",
      "D": "A list of variables it substitutes, without types."
    },
    "answer": "B"
  },
  {
    "id": "topic10_1",
    "question": "In the context of expressions, what are the basic building blocks for composing an evaluable unit like a function application?",
    "options": {
      "A": "Only variables and constants, without any operators.",
      "B": "Variables, constants, function calls, and tuple constructions.",
      "C": "Names and events, but not function applications.",
      "D": "Destructors and rewrite rules only."
    },
    "answer": "B"
  },
  {
    "id": "topic10_2",
    "question": "When composing a tuple in an expression, how is it typically constructed according to the content?",
    "options": {
      "A": "Using a constructor like tupleT1,...,Tn(M1,...,Mn) to group terms.",
      "B": "Directly as a variable without any specific syntax.",
      "C": "By applying a destructor to combine multiple terms.",
      "D": "Through conditional statements like if-then-else."
    },
    "answer": "A"
  },
  {
    "id": "topic10_3",
    "question": "What must be true for an expression to be considered ground when composing operators and operands?",
    "options": {
      "A": "It must contain no variables, only constants and function calls.",
      "B": "It can include variables as long as they are declared.",
      "C": "It should always evaluate to fail for security reasons.",
      "D": "It must include at least one destructor or rewrite rule."
    },
    "answer": "A"
  },
  {
    "id": "topic10_4",
    "question": "In expressions, how are function applications incorporated into the composition of operators and operands?",
    "options": {
      "A": "By using the syntax h(D1,...,Dn) where h is from Fd ∪ Fc, applied to subexpressions.",
      "B": "Only through variables, without any specific function symbols.",
      "C": "By restricting them with new a: T; D before use.",
      "D": "Exclusively in processes, not in standalone expressions."
    },
    "answer": "A"
  },
  {
    "id": "topic10_5",
    "question": "When evaluating a composed expression involving a destructor like g(U1,...,Un), what happens if no rewrite rule applies?",
    "options": {
      "A": "The expression evaluates to the constant fail.",
      "B": "It automatically defaults to a ground term.",
      "C": "The evaluation continues indefinitely until a rule matches.",
      "D": "It transforms into a conditional statement."
    },
    "answer": "A"
  },
  {
    "id": "topic10_6",
    "question": "How does the 'let' construct contribute to composing expressions with function applications or tuple constructions?",
    "options": {
      "A": "It allows binding a value to a variable, such as let x: T = D in D′ else D′′, enabling further composition.",
      "B": "It restricts the expression to only ground terms.",
      "C": "It is used solely for declaring new names, not for expressions.",
      "D": "It evaluates expressions without any error handling."
    },
    "answer": "A"
  },
  {
    "id": "topic10_7",
    "question": "In the composition of expressions, what role do associative and commutative operators play, as mentioned in the content?",
    "options": {
      "A": "They allow for flexible ordering of operands in function applications, like in Diﬃe-Hellman exponentiation.",
      "B": "They are only used in processes and not in expressions.",
      "C": "They must be avoided to prevent evaluation failures.",
      "D": "They convert expressions into ground terms automatically."
    },
    "answer": "A"
  },
  {
    "id": "topic10_8",
    "question": "When composing an expression with a conditional like if D then D′ else D′′, what is the key condition for it to succeed?",
    "options": {
      "A": "D must evaluate to true; otherwise, it fails or uses the else branch.",
      "B": "D must be a ground term, regardless of its value.",
      "C": "The expression must include a destructor for evaluation.",
      "D": "It always succeeds as long as variables are present."
    },
    "answer": "A"
  },
  {
    "id": "topic10_9",
    "question": "For tuple constructions in expressions, which of the following best describes how operands like terms M1,...,Mn are combined?",
    "options": {
      "A": "As a constructor application, such as tupleT1,...,Tn(M1,...,Mn), to form a single evaluable unit.",
      "B": "By using pattern-matching directly without constructors.",
      "C": "Through replication or parallel composition in processes.",
      "D": "Only if they are non-ground terms for flexibility."
    },
    "answer": "A"
  },
  {
    "id": "topic10_10",
    "question": "In the evaluation of composed expressions, what distinguishes constructors from destructors in terms of their application?",
    "options": {
      "A": "Constructors build terms like f(M1,...,Mk) for composition, while destructors use rewrite rules like g(U1,...,Un) → U.",
      "B": "Constructors always fail, whereas destructors always succeed.",
      "C": "Constructors are only for ground terms, and destructors for variables.",
      "D": "There is no difference; both are used interchangeably."
    },
    "answer": "A"
  },
  {
    "id": "topic11_1",
    "question": "In ProVerif, what is the primary role of the 'new n : t; P' construct in process declarations?",
    "options": {
      "A": "It defines a constant that can be used globally in the process.",
      "B": "It restricts a new name 'n' of type 't' and continues with process 'P'.",
      "C": "It handles input operations on a channel named 'n'.",
      "D": "It replicates the process 'P' multiple times for parallel execution."
    },
    "answer": "B"
  },
  {
    "id": "topic11_2",
    "question": "How does the 'if M then P else Q' construct contribute to control flow in ProVerif processes?",
    "options": {
      "A": "It evaluates the term 'M' and executes 'P' if true, otherwise 'Q', allowing conditional branching.",
      "B": "It always executes both 'P' and 'Q' in parallel regardless of 'M'.",
      "C": "It restricts the scope of 'M' to only 'P' and discards 'Q'.",
      "D": "It terminates the process immediately if 'M' is false."
    },
    "answer": "A"
  },
  {
    "id": "topic11_3",
    "question": "In ProVerif, what does the 'in(M, x: t); P' process construct primarily accomplish?",
    "options": {
      "A": "It outputs a message on channel 'M' and binds it to variable 'x' before running 'P'.",
      "B": "It inputs a message from channel 'M', binds it to variable 'x' of type 't', and then runs 'P'.",
      "C": "It declares a new name 'x' of type 't' and uses it in process 'P' without any input.",
      "D": "It replicates the process 'P' based on the value received from channel 'M'."
    },
    "answer": "B"
  },
  {
    "id": "topic11_4",
    "question": "What is the function of the 'out(M, N); P' construct in ProVerif processes?",
    "options": {
      "A": "It inputs a term from channel 'M' and compares it with 'N' before executing 'P'.",
      "B": "It outputs the term 'N' on channel 'M' and then continues with process 'P'.",
      "C": "It restricts access to 'M' and 'N' for security, then runs 'P'.",
      "D": "It evaluates 'M' and 'N' as conditions for replicating 'P'."
    },
    "answer": "B"
  },
  {
    "id": "topic11_5",
    "question": "In the context of process termination, what does the '0' (nil process) represent in ProVerif?",
    "options": {
      "A": "It represents a process that performs ongoing replication indefinitely.",
      "B": "It is a null process that does nothing and signifies the end of execution.",
      "C": "It handles conditional checks and terminates based on input values.",
      "D": "It composes multiple processes in parallel until one finishes."
    },
    "answer": "B"
  },
  {
    "id": "topic11_6",
    "question": "How does process composition work with the 'P | Q' construct in ProVerif?",
    "options": {
      "A": "It runs processes 'P' and 'Q' sequentially, waiting for 'P' to finish before starting 'Q'.",
      "B": "It executes 'P' and 'Q' in parallel, allowing both to run simultaneously.",
      "C": "It restricts names in 'P' and makes them unavailable in 'Q'.",
      "D": "It replicates 'P' inside 'Q' for multiple instances."
    },
    "answer": "B"
  },
  {
    "id": "topic11_7",
    "question": "What is the purpose of the '!P' (replication) construct in ProVerif processes?",
    "options": {
      "A": "It creates a single copy of process 'P' that runs once and terminates.",
      "B": "It replicates process 'P' indefinitely, allowing multiple concurrent instances.",
      "C": "It inputs data into 'P' and outputs it after replication.",
      "D": "It phases the execution of 'P' based on global synchronization."
    },
    "answer": "B"
  },
  {
    "id": "topic11_8",
    "question": "In ProVerif, how does the 'phase n; P' construct affect process execution?",
    "options": {
      "A": "It declares a new name for use in process 'P' without any synchronization.",
      "B": "It acts as a global synchronization point, discarding processes not at phase 'n' and running 'P'.",
      "C": "It evaluates conditions in 'P' and terminates if phase 'n' is not met.",
      "D": "It outputs events related to phase 'n' before executing 'P'."
    },
    "answer": "B"
  },
  {
    "id": "topic11_9",
    "question": "Regarding events in ProVerif processes, what is the role of the 'event(e(M1,...,Mn)); P' construct?",
    "options": {
      "A": "It records that a specific program point has been reached with arguments, then continues with 'P'.",
      "B": "It inputs messages and binds them to events for parallel composition.",
      "C": "It terminates the process 'P' after executing the event.",
      "D": "It replicates the event multiple times without affecting 'P'."
    },
    "answer": "A"
  },
  {
    "id": "topic11_10",
    "question": "In ProVerif, how are expressions integrated into processes, such as with 'let x: T = D in D′ else D′′'?",
    "options": {
      "A": "It evaluates 'D' and binds the result to 'x', then executes 'D′' if successful, or 'D′′' otherwise, extending process capabilities.",
      "B": "It restricts names in 'D' and discards 'D′' for security reasons.",
      "C": "It outputs 'D' on a channel and runs 'D′' in parallel with 'D′′'.",
      "D": "It phases the execution of 'D′' based on the value of 'D′′'."
    },
    "answer": "A"
  },
  {
    "id": "topic12_1",
    "question": "In ProVerif, what is the correct syntax for defining a process macro that allows sub-processes to be specified for easier development?",
    "options": {
      "A": "def R(x1: t1, ..., xn: tn) = P.",
      "B": "let R(x1: t1, ..., xn: tn) = P.",
      "C": "type R(x1: t1, ..., xn: tn) = P.",
      "D": "free R(x1: t1, ..., xn: tn) = P."
    },
    "answer": "B"
  },
  {
    "id": "topic12_2",
    "question": "When a macro like R(M1, ..., Mn) is used in a ProVerif process, what happens during its expansion?",
    "options": {
      "A": "It replaces the macro with a new declaration for free names.",
      "B": "It substitutes the actual arguments M1, ..., Mn for the formal parameters x1, ..., xn in the defined sub-process P.",
      "C": "It discards the sub-process P and runs only the main process.",
      "D": "It automatically adds a phase construct to synchronize the process."
    },
    "answer": "B"
  },
  {
    "id": "topic12_3",
    "question": "Why are process macros particularly useful in ProVerif for protocol development, according to the content?",
    "options": {
      "A": "They eliminate the need for declarations altogether.",
      "B": "They allow sub-processes to be defined and reused, making the code easier to manage and organize into larger blocks.",
      "C": "They ensure that all processes run in a single phase without synchronization.",
      "D": "They automatically handle cryptographic primitives without user input."
    },
    "answer": "B"
  },
  {
    "id": "topic12_4",
    "question": "In a ProVerif model, what must be done for free names before they can be used in process declarations or macros?",
    "options": {
      "A": "They can be used directly without any declaration.",
      "B": "They must be declared with their type using the syntax \"free n: t.\".",
      "C": "They only need to be declared if they appear in a macro.",
      "D": "They require a phase construct for proper usage."
    },
    "answer": "B"
  },
  {
    "id": "topic12_5",
    "question": "How does the phase construct in ProVerif contribute to organizing processes into larger code blocks for protocols with multiple stages?",
    "options": {
      "A": "It allows processes to run independently without synchronization.",
      "B": "It acts as a global synchronization point, discarding processes not yet at the specified phase and starting new ones.",
      "C": "It merges all sub-processes into a single macro automatically.",
      "D": "It requires macros to be redefined for each phase."
    },
    "answer": "B"
  },
  {
    "id": "topic12_6",
    "question": "Based on the content, how does ProVerif handle the expansion of macros when generating its output?",
    "options": {
      "A": "Macros are preserved in the output for readability.",
      "B": "Macros are expanded in the main process, and the output shows the process as if the macros were directly written out.",
      "C": "The output only includes macros if they are used in declarations.",
      "D": "ProVerif discards macros and focuses on phases instead."
    },
    "answer": "B"
  },
  {
    "id": "topic12_7",
    "question": "What are the main structural components of a ProVerif model for organizing protocols into larger code blocks?",
    "options": {
      "A": "Only declarations and the main process, with no need for macros.",
      "B": "Declarations for cryptographic primitives, process macros for sub-processes, and the main process for the overall protocol.",
      "C": "Phases and free names, but not constructors or destructors.",
      "D": "Macros for security assumptions and destructors for outputs."
    },
    "answer": "B"
  },
  {
    "id": "topic12_8",
    "question": "In ProVerif, how are variables in a process macro like let R(x1: t1, ..., xn: tn) = P handled when the macro is expanded?",
    "options": {
      "A": "The variables are ignored, and only the process P is executed.",
      "B": "The free variables x1, ..., xn are substituted with the provided arguments, ensuring they match the declared types.",
      "C": "The variables must be redeclared in the main process before expansion.",
      "D": "The variables are automatically converted to free names during expansion."
    },
    "answer": "B"
  },
  {
    "id": "topic12_9",
    "question": "According to the content, what role do macros play in defining security assumptions for cryptographic primitives in ProVerif?",
    "options": {
      "A": "Macros cannot be used for security assumptions; they are only for processes.",
      "B": "Macros can define security assumptions by using the \"def name(i1, ..., in) { declarations }\" syntax, which expands to substitute arguments.",
      "C": "Security assumptions are handled separately through phases, not macros.",
      "D": "Macros for security must include a replication construct for multiple keys."
    },
    "answer": "B"
  },
  {
    "id": "topic12_10",
    "question": "When ProVerif processes a protocol with macros and phases, how does it organize the workflow into larger code blocks in its internal representation?",
    "options": {
      "A": "It treats macros and phases as separate entities without merging them.",
      "B": "It expands macros and uses phases for synchronization, merging processes into a biprocess for analysis, while annotating with identifiers for clarity.",
      "C": "It discards phases and focuses only on macro expansions.",
      "D": "It requires users to manually merge processes before running the model."
    },
    "answer": "B"
  },
  {
    "id": "topic13_1",
    "question": "According to the formalism, what is required for variables in clauses like F1, ..., Fm, F before they can be used?",
    "options": {
      "A": "They can be used directly without any quantification if the clause is simple.",
      "B": "They must be universally quantified using \"forall x1 : t1, ..., xn : tn\".",
      "C": "Quantification is only needed if the variables appear in a conditional statement.",
      "D": "They require quantification only when the types include \"or fail\"."
    },
    "answer": "B"
  },
  {
    "id": "topic13_2",
    "question": "In the process declaration, how must free names like 'c' in \"free c : channel\" be handled before they are used?",
    "options": {
      "A": "They can be used without declaration as long as they are not in the scope of variables.",
      "B": "They must be declared with their type using the \"free n : t\" syntax before use.",
      "C": "Declaration is optional if the name is a constructor or destructor.",
      "D": "They only need to be declared if they are part of a biprocess."
    },
    "answer": "B"
  },
  {
    "id": "topic13_3",
    "question": "What determines the representation of a name like 'b' in the process \"in(c, (x: bitstring, y: bitstring)); new b:nonce\"?",
    "options": {
      "A": "It is always represented without arguments, regardless of surrounding variables.",
      "B": "It is represented with arguments (e.g., b[x=M, y=N]) because it is in the scope of variables x and y.",
      "C": "Its representation depends only on its type, such as \"nonce\", and not on scope.",
      "D": "It can be represented either way, as long as it is universally quantified."
    },
    "answer": "B"
  },
  {
    "id": "topic13_4",
    "question": "When dealing with identifiers in processes, what is recommended to prevent confusion between names and variables?",
    "options": {
      "A": "Using the same names for variables and functions, as long as they are in different scopes.",
      "B": "Employing distinct naming for names and variables to avoid ambiguity.",
      "C": "Allowing reuse of identifiers as long as they are declared with \"forall\".",
      "D": "Only distinguishing them in elimtrue declarations."
    },
    "answer": "B"
  },
  {
    "id": "topic13_5",
    "question": "In the context of scope determination, when can the universal quantification \"forall x1 : t1, ..., xn : tn\" be omitted for variables in clauses?",
    "options": {
      "A": "It can always be omitted for simplicity in the process declaration.",
      "B": "It can be omitted only when the variables F1, ..., Fm, F contain no variables.",
      "C": "It is optional if the types are of the form \"t or fail\".",
      "D": "It must be included even if no variables are present for backward compatibility."
    },
    "answer": "B"
  },
  {
    "id": "topic13_6",
    "question": "How does the scope of variables affect the internal representation of fresh names in a process?",
    "options": {
      "A": "Fresh names are always represented without arguments, irrespective of scope.",
      "B": "Fresh names in the scope of variables, like x and y, must be annotated with those variables (e.g., b[x=M, y=N]).",
      "C": "Scope only matters for destructors, not for fresh names like in \"new a:nonce\".",
      "D": "Fresh names do not require annotation if they are universally quantified."
    },
    "answer": "B"
  },
  {
    "id": "topic13_7",
    "question": "Regarding identifier uniqueness, why is it important to ensure that names and variables are uniquely named in declarations?",
    "options": {
      "A": "It helps in avoiding false attacks during proof of equivalences by ensuring matching names have the same arguments.",
      "B": "Uniqueness is only necessary for processes and not for variables or functions.",
      "C": "Identifiers can be reused as long as they are in different clauses or facts.",
      "D": "It is recommended only for noninterf declarations to simplify indexing."
    },
    "answer": "A"
  },
  {
    "id": "topic13_8",
    "question": "In the formalism, what rule applies to the types of variables in universal quantification, such as \"forall x1 : t1, ..., xn : tn\"?",
    "options": {
      "A": "Types t1, ..., tn must be just type identifiers and cannot include \"or fail\".",
      "B": "Types t1, ..., tn can be a type identifier or of the form \"t or fail\", allowing variables to take the value \"fail\".",
      "C": "Types are irrelevant as long as the variables are in scope.",
      "D": "Types must always include \"or fail\" for variables in processes."
    },
    "answer": "B"
  },
  {
    "id": "topic13_9",
    "question": "For processes and their declarations, what must be ensured regarding the use of identifiers like functions and names?",
    "options": {
      "A": "They can be used without declaration as long as they are constructors.",
      "B": "All identifiers, including functions and names, must be declared before use to maintain mandatory declaration-before-use constraints.",
      "C": "Declaration is only required for variables, not for functions or processes.",
      "D": "Identifiers in queries or lemmas do not need prior declaration."
    },
    "answer": "B"
  },
  {
    "id": "topic13_10",
    "question": "In the context of scope determination rules, what happens if a name is not properly annotated with variables in its scope during equivalence proofs?",
    "options": {
      "A": "It has no impact, as session identifiers are always sufficient.",
      "B": "It can lead to false attacks because names might have different arguments in the two components of a biprocess.",
      "C": "Names without annotations are automatically universally quantified.",
      "D": "It only affects destructors and not constructors."
    },
    "answer": "B"
  },
  {
    "id": "topic14_1",
    "question": "In the context of destructor calls, what must be ensured regarding the number of arguments provided to a destructor like g?",
    "options": {
      "A": "The number of arguments can vary as long as they are of the correct type.",
      "B": "The number of arguments must exactly match the arity k specified in the destructor's rewrite rules.",
      "C": "Only one argument is required, regardless of the destructor's definition.",
      "D": "The number of arguments can be optional if the destructor is part of a simple pattern."
    },
    "answer": "B"
  },
  {
    "id": "topic14_2",
    "question": "When defining rewrite rules for a destructor, what type consistency requirement applies to the arguments of g across all rules?",
    "options": {
      "A": "Arguments in different rules can have different types as long as they are constructors.",
      "B": "All arguments of g in every rule must have the same types as those in other rules for the same destructor.",
      "C": "Type consistency is only needed for the return values, not the arguments.",
      "D": "Arguments must match the types of built-in destructors like 'not' or '='."
    },
    "answer": "B"
  },
  {
    "id": "topic14_3",
    "question": "What happens if the parameters in a destructor call, such as g(M1,1, ..., M1,k), do not meet the type consistency requirements specified in the rewrite rules?",
    "options": {
      "A": "The call proceeds with type conversion automatically.",
      "B": "ProVerif attempts to apply the next rewrite rule in the sequence.",
      "C": "The destructor fails, and the term is not reduced.",
      "D": "The parameters are implicitly adjusted to match the required types."
    },
    "answer": "C"
  },
  {
    "id": "topic14_4",
    "question": "For a type converter function, what constraint ensures type consistency during pattern-matching?",
    "options": {
      "A": "The output must be the same as the input type, and no checking is needed.",
      "B": "The output must differ from the input, identify the function applied, and be checked upon pattern-matching.",
      "C": "Type consistency is only required if there are multiple converter functions.",
      "D": "The function can produce values of any type without verification."
    },
    "answer": "B"
  },
  {
    "id": "topic14_5",
    "question": "In the case of a simple pattern, what parameter matching requirement must be met for occurrences of =D?",
    "options": {
      "A": "D must be a may-fail constructor term, but parameter count can be flexible.",
      "B": "D must be a may-fail constructor term with exact parameter count and type consistency.",
      "C": "Only the type of D needs to match, regardless of the number of parameters.",
      "D": "D can be any term, as long as it does not contain destructor symbols."
    },
    "answer": "B"
  },
  {
    "id": "topic14_6",
    "question": "When using a data constructor f with associated destructors, what must be ensured for pattern matching of terms like f(M1, ..., Mn)?",
    "options": {
      "A": "The patterns pat1, ..., patn must match M1, ..., Mn in type but not necessarily in count.",
      "B": "The number of patterns must match the arity n of f, and each must be consistent in type with the corresponding Mi.",
      "C": "Pattern matching works even if f is not a data constructor, as long as types are similar.",
      "D": "Only the first pattern needs to match for the entire term to succeed."
    },
    "answer": "B"
  },
  {
    "id": "topic14_7",
    "question": "Regarding destructor-function constraints, what condition must be met for the return values in rewrite rules like g(M1,1, ..., M1,k) = M1,0?",
    "options": {
      "A": "The return values can have different types across rules for variety.",
      "B": "All return values (e.g., M1,0, ..., Mm,0) must share the same type as specified for the destructor's output.",
      "C": "Return values only need to match the types of the arguments, not among themselves.",
      "D": "Type consistency is not required if the destructor is public."
    },
    "answer": "B"
  },
  {
    "id": "topic14_8",
    "question": "In ProVerif, when encountering a term with a destructor like 'equal(M, N)', what parameter matching rule applies if the rewrite rules fail?",
    "options": {
      "A": "ProVerif will loop indefinitely until a match is found.",
      "B": "The destructor fails, and the process continues as if the term evaluation failed.",
      "C": "Parameters M and N can be of any type, as long as their count matches.",
      "D": "ProVerif automatically adjusts the parameters for type consistency."
    },
    "answer": "B"
  },
  {
    "id": "topic14_9",
    "question": "For function macros in ProVerif, what requirement ensures proper parameter handling when defining a symbol for repeated terms?",
    "options": {
      "A": "The macro can have a variable number of parameters without type checks.",
      "B": "Parameters must maintain type consistency with the original terms, and the count must match the macro's definition.",
      "C": "Only constructors need parameter matching; destructors in macros are exempt.",
      "D": "Type consistency is checked only during pattern-matching, not at definition."
    },
    "answer": "B"
  },
  {
    "id": "topic14_10",
    "question": "What key constraint differentiates destructors from constructors in terms of parameter matching and failure?",
    "options": {
      "A": "Destructors allow flexible parameter counts, while constructors do not.",
      "B": "Destructors must follow rewrite rules with exact parameter count and type consistency, and they fail if no rule applies.",
      "C": "Constructors can fail if types are inconsistent, but destructors always succeed.",
      "D": "Parameter matching is optional for both, but only destructors require public declaration."
    },
    "answer": "B"
  },
  {
    "id": "topic15_1",
    "question": "In ProVerif, what is the primary purpose of proving reachability properties?",
    "options": {
      "A": "To evaluate the computational efficiency of a protocol.",
      "B": "To determine which terms are available to an attacker, thereby assessing syntactic secrecy.",
      "C": "To simulate real-world network attacks on a protocol.",
      "D": "To verify the equivalence of two different protocols."
    },
    "answer": "B"
  },
  {
    "id": "topic15_2",
    "question": "When testing the secrecy of a term M in ProVerif, what query must be included in the input file before the main process?",
    "options": {
      "A": "query secret(M).",
      "B": "query attacker(M).",
      "C": "query reachability(M).",
      "D": "query verify(M)."
    },
    "answer": "B"
  },
  {
    "id": "topic15_3",
    "question": "What are the specific requirements for the term M when using it in a secrecy query in ProVerif?",
    "options": {
      "A": "It must be a variable term that includes destructors and public names only.",
      "B": "It must be a ground term, without destructors, and may contain free names (possibly private).",
      "C": "It must be a non-ground term with destructors for dynamic analysis.",
      "D": "It must include both public and private names without any restrictions."
    },
    "answer": "B"
  },
  {
    "id": "topic15_4",
    "question": "In the context of ProVerif, how is syntactic secrecy evaluated?",
    "options": {
      "A": "By directly simulating an attacker's computational power in a real environment.",
      "B": "By investigating which terms are available to an attacker through reachability analysis.",
      "C": "By comparing the protocol's performance metrics against predefined benchmarks.",
      "D": "By verifying correspondences without considering attacker capabilities."
    },
    "answer": "B"
  },
  {
    "id": "topic15_5",
    "question": "According to the content, what is the role of an adversary in verifying security properties like secrecy?",
    "options": {
      "A": "The adversary is ignored, as ProVerif focuses only on internal protocol logic.",
      "B": "The adversary is formalized first to analyze how it might access or manipulate terms in the model.",
      "C": "The adversary is modeled only for equivalences, not for secrecy properties.",
      "D": "The adversary is limited to using destructors on ground terms exclusively."
    },
    "answer": "B"
  },
  {
    "id": "topic15_6",
    "question": "What does strong secrecy mean in the context of ProVerif, as described in the content?",
    "options": {
      "A": "The adversary can distinguish between two versions of the protocol but only under certain conditions.",
      "B": "The adversary cannot distinguish between two versions of the protocol that use different secret values.",
      "C": "Strong secrecy applies only to protocols without an equational theory.",
      "D": "It means the secret is partially available to the adversary for reachability testing."
    },
    "answer": "B"
  },
  {
    "id": "topic15_7",
    "question": "Based on the content, which of the following best describes the symbolic model used in ProVerif for security protocol verification?",
    "options": {
      "A": "It models cryptographic primitives as imperfect functions with real-world computational limits.",
      "B": "It treats cryptographic primitives as perfect blackboxes, represented by function symbols in an algebra of terms.",
      "C": "It focuses exclusively on computational models without any algebraic representation.",
      "D": "It requires equations for all terms to simulate dynamic adversary interactions."
    },
    "answer": "B"
  },
  {
    "id": "topic15_8",
    "question": "In ProVerif, how are security properties like secrecy and correspondences primarily verified, according to the references mentioned?",
    "options": {
      "A": "Through manual proof techniques based on Blanchet's 2008 work on equivalences.",
      "B": "By automatic verification tools, with main references from Blanchet (2009) for secrecy and correspondences.",
      "C": "By focusing only on computational models as per Blanchet et al. (2012).",
      "D": "Through empirical testing without theoretical formalization."
    },
    "answer": "B"
  },
  {
    "id": "topic15_9",
    "question": "What limitation is mentioned in the content regarding the chapter's discussion of ProVerif?",
    "options": {
      "A": "It only deals with extensions of the core calculus from §2.1 for simplicity.",
      "B": "It restricts analysis to the core calculus of §2.1, with results extendable to other features.",
      "C": "It excludes reachability properties entirely.",
      "D": "It requires full computational models for all verifications."
    },
    "answer": "B"
  },
  {
    "id": "topic15_10",
    "question": "According to the definition in the content, when does a closed process P0 preserve strong secrecy?",
    "options": {
      "A": "When the adversary can access the secret under specific protocol conditions.",
      "B": "When the adversary cannot distinguish two versions of the protocol using different secret values.",
      "C": "When strong secrecy is verified only in the presence of an equational theory.",
      "D": "When the process is open and includes free names without restrictions."
    },
    "answer": "B"
  },
  {
    "id": "topic16_1",
    "question": "In the context of handshake protocols, what is the primary purpose of correspondence assertions for authentication?",
    "options": {
      "A": "To ensure that messages are encrypted securely without any verification.",
      "B": "To confirm that if one event (e.g., e1) has been executed, another event (e.g., e2) has or will be executed.",
      "C": "To limit the number of sessions in a protocol to prevent overload.",
      "D": "To verify secrecy properties only, ignoring authentication entirely."
    },
    "answer": "B"
  },
  {
    "id": "topic16_2",
    "question": "According to the content, how does ProVerif verify authentication properties like those in handshake protocols?",
    "options": {
      "A": "By manually checking each protocol step without any translation.",
      "B": "By translating the protocol into Horn clauses and checking derivability queries for properties like correspondence assertions.",
      "C": "By simulating a bounded number of sessions and ignoring unbounded scenarios.",
      "D": "By focusing solely on observational equivalence without considering secrecy."
    },
    "answer": "B"
  },
  {
    "id": "topic16_3",
    "question": "What role do tools like ProVerif and Tamarin play in verifying authentication properties for an unbounded number of sessions?",
    "options": {
      "A": "They restrict analysis to a single session to simplify verification.",
      "B": "They allow verification of protocols for an unbounded number of sessions, often using lemmas to guide proofs.",
      "C": "They only verify secrecy and ignore authentication in unbounded environments.",
      "D": "They require manual intervention for all properties, making automation impossible."
    },
    "answer": "B"
  },
  {
    "id": "topic16_4",
    "question": "In the handshake protocol example, what must be proven using correspondence assertions to ensure authentication?",
    "options": {
      "A": "That all messages are kept secret regardless of events.",
      "B": "That if the client thinks they are executing the protocol with a server, that server is indeed the one involved.",
      "C": "That the protocol works only for bounded message spaces.",
      "D": "That encryption primitives are subterm convergent without any event checks."
    },
    "answer": "B"
  },
  {
    "id": "topic16_5",
    "question": "How does ProVerif handle the verification of security properties, such as authentication via correspondence assertions?",
    "options": {
      "A": "It verifies them manually by building clauses based on user input.",
      "B": "It automatically translates protocols into Horn clauses and uses resolution to prove properties like \"if e1 occurs, then e2 occurs.\"",
      "C": "It relies exclusively on temporal first-order logic without any clause-based approach.",
      "D": "It only supports bounded sessions and cannot handle equivalences."
    },
    "answer": "B"
  },
  {
    "id": "topic16_6",
    "question": "Based on the content, what limitation does ProVerif have when verifying protocols in the computational model?",
    "options": {
      "A": "It can fully automate proofs for all properties without any restrictions.",
      "B": "It cannot fully prove required properties automatically due to certain aspects not being accounted for, though it handles key parts like correspondence assertions.",
      "C": "It is limited to verifying only secrecy and ignores authentication entirely.",
      "D": "It requires an unbounded message space but fails in attack reconstruction."
    },
    "answer": "B"
  },
  {
    "id": "topic16_7",
    "question": "In examples like the certified email protocol, how are correspondence assertions applied to verify authentication?",
    "options": {
      "A": "They are used to prove secrecy only, without linking events.",
      "B": "They verify that specific events in the protocol correspond, ensuring authentication as shown in works like Abadi & Blanchet.",
      "C": "They focus on privacy and traceability without any event-based checks.",
      "D": "They are applied manually without any tool support."
    },
    "answer": "B"
  },
  {
    "id": "topic16_8",
    "question": "What key advantage does ProVerif provide for analyzing protocols like the JFK key exchange?",
    "options": {
      "A": "It verifies protocols by combining manual proofs with automatic checks of correspondences and equivalences.",
      "B": "It ignores correspondences and focuses only on computational soundness.",
      "C": "It restricts analysis to trusted environments and avoids untrusted systems.",
      "D": "It proves properties without translating them into any internal representation."
    },
    "answer": "A"
  },
  {
    "id": "topic16_9",
    "question": "According to the content, how does the use of Horn clauses contribute to verifying authentication properties?",
    "options": {
      "A": "They are used to manually build proofs without systematic translation.",
      "B": "They provide a systematic translation from formal protocol models, allowing verification of properties beyond just secrecy.",
      "C": "They are only applicable to bounded sessions and not for authentication.",
      "D": "They focus on subterm convergent equations without addressing correspondences."
    },
    "answer": "B"
  },
  {
    "id": "topic16_10",
    "question": "In the context of tools like Tamarin, what is required to verify trace properties for authentication in protocols?",
    "options": {
      "A": "It verifies properties automatically without any user input.",
      "B": "It often needs the user to provide lemmas to guide the proof for an unbounded number of sessions.",
      "C": "It limits verification to secrecy and avoids authentication altogether.",
      "D": "It relies on computational models exclusively, ignoring symbolic ones."
    },
    "answer": "B"
  },
  {
    "id": "topic1_1",
    "question": "What is the input language of ProVerif based on?",
    "options": {
      "A": "The standard pi calculus without extensions.",
      "B": "A dialect of the applied pi calculus introduced by Abadi and Fournet.",
      "C": "A subset of first-order logic.",
      "D": "The lambda calculus with cryptographic primitives."
    },
    "answer": "B"
  },
  {
    "id": "topic1_2",
    "question": "How does the applied pi calculus extend the standard pi calculus?",
    "options": {
      "A": "By adding probabilistic transitions.",
      "B": "By introducing function symbols defined by an equational theory.",
      "C": "By removing communication channels.",
      "D": "By supporting only linear types."
    },
    "answer": "B"
  },
  {
    "id": "topic1_3",
    "question": "What is one key difference between ProVerif and the applied pi calculus?",
    "options": {
      "A": "ProVerif does not support any equational theories.",
      "B": "ProVerif uses destructors instead of equational theories.",
      "C": "The applied pi calculus has built-in error-handling constructs.",
      "D": "ProVerif does not support cryptographic primitives."
    },
    "answer": "B"
  },
  {
    "id": "topic1_4",
    "question": "Which of the following does ProVerif support for modeling cryptographic primitives?",
    "options": {
      "A": "Only rewrite rules.",
      "B": "Only equations.",
      "C": "Both rewrite rules and equations.",
      "D": "Neither rewrite rules nor equations."
    },
    "answer": "C"
  },
  {
    "id": "topic1_5",
    "question": "What security properties can ProVerif verify?",
    "options": {
      "A": "Only secrecy.",
      "B": "Only authentication.",
      "C": "Secrecy, authentication, and some observational equivalence properties.",
      "D": "Only observational equivalence."
    },
    "answer": "C"
  },
  {
    "id": "topic1_6",
    "question": "What is the relationship between ProVerif's calculus and the applied pi calculus?",
    "options": {
      "A": "They are identical in all aspects.",
      "B": "ProVerif's calculus is a strict subset of the applied pi calculus.",
      "C": "They are extensions of the pi calculus but differ in handling equations and error-handling.",
      "D": "ProVerif's calculus is unrelated to the applied pi calculus."
    },
    "answer": "C"
  },
  {
    "id": "topic1_7",
    "question": "How does ProVerif handle error conditions during expression evaluation?",
    "options": {
      "A": "It ignores errors silently.",
      "B": "It uses a built-in else branch for error-handling.",
      "C": "It aborts the entire verification process.",
      "D": "It relies on external error-handling libraries."
    },
    "answer": "B"
  },
  {
    "id": "topic1_8",
    "question": "What does ProVerif prove that is stronger than observational equivalence in the applied pi calculus?",
    "options": {
      "A": "Trace equivalence.",
      "B": "Di-equivalence.",
      "C": "Weak bisimulation.",
      "D": "Strong bisimulation."
    },
    "answer": "B"
  },
  {
    "id": "topic1_9",
    "question": "Which of the following is NOT a feature of ProVerif's input language?",
    "options": {
      "A": "Support for destructors.",
      "B": "Built-in error-handling constructs.",
      "C": "Full support for all equational theories.",
      "D": "Extension of the pi calculus with cryptography."
    },
    "answer": "C"
  },
  {
    "id": "topic1_10",
    "question": "What is the primary purpose of ProVerif's automatic translator?",
    "options": {
      "A": "To convert the applied pi calculus into ProVerif's dialect.",
      "B": "To translate protocol models and security properties into Horn clauses.",
      "C": "To generate human-readable summaries of attacks.",
      "D": "To optimize cryptographic primitives for performance."
    },
    "answer": "B"
  },
  {
    "id": "topic2_1",
    "question": "What is the primary goal of ProVerif?",
    "options": {
      "A": "To optimize cryptographic algorithms for performance.",
      "B": "To verify cryptographic protocols for security properties.",
      "C": "To simulate network attacks in real-time environments.",
      "D": "To generate cryptographic keys for secure communication."
    },
    "answer": "B"
  },
  {
    "id": "topic2_2",
    "question": "Which of the following security properties can ProVerif verify?",
    "options": {
      "A": "Only secrecy, but not authentication.",
      "B": "Secrecy, authentication, and observational equivalence.",
      "C": "Only authentication, but not secrecy.",
      "D": "Only reachability properties."
    },
    "answer": "B"
  },
  {
    "id": "topic2_3",
    "question": "What kind of attacker model does ProVerif assume?",
    "options": {
      "A": "A passive eavesdropper with no message manipulation capabilities.",
      "B": "A \"Dolev-Yao\" attacker with full control over communication channels.",
      "C": "An attacker limited to brute-force attacks.",
      "D": "An attacker restricted to physical side-channel attacks."
    },
    "answer": "B"
  },
  {
    "id": "topic2_4",
    "question": "ProVerif has been used to verify which of the following real-world protocols?",
    "options": {
      "A": "HTTPS and SSH only.",
      "B": "TLS, Signal, and a certified email service.",
      "C": "Only theoretical protocols, not deployed ones.",
      "D": "Blockchain consensus protocols exclusively."
    },
    "answer": "B"
  },
  {
    "id": "topic2_5",
    "question": "How does ProVerif internally represent protocols for verification?",
    "options": {
      "A": "Using finite state machines.",
      "B": "Through abstract syntax trees.",
      "C": "Using Horn clauses and derivability queries.",
      "D": "Via game-based cryptographic proofs."
    },
    "answer": "C"
  },
  {
    "id": "topic2_6",
    "question": "What limitation does ProVerif have regarding termination?",
    "options": {
      "A": "It always terminates but may miss some attacks.",
      "B": "Termination is guaranteed only for a bounded number of sessions.",
      "C": "It never terminates for complex protocols.",
      "D": "Termination is not guaranteed in general due to relational Horn clauses."
    },
    "answer": "D"
  },
  {
    "id": "topic2_7",
    "question": "ProVerif is built on an extension of which computational model?",
    "options": {
      "A": "Turing machines.",
      "B": "The pi calculus with cryptographic primitives.",
      "C": "Lambda calculus.",
      "D": "Petri nets."
    },
    "answer": "B"
  },
  {
    "id": "topic2_8",
    "question": "Besides standalone verification, ProVerif has been used as a back-end for:",
    "options": {
      "A": "Compiling cryptographic implementations.",
      "B": "Building other verification tools for protocol implementations.",
      "C": "Generating synthetic attack datasets.",
      "D": "Optimizing firewall rule sets."
    },
    "answer": "B"
  },
  {
    "id": "topic2_9",
    "question": "Which of the following best describes ProVerif's automation level?",
    "options": {
      "A": "Fully interactive, requiring manual guidance for each step.",
      "B": "Mostly automated, with some interactive features when proofs fail.",
      "C": "Only supports manual theorem proving.",
      "D": "Requires exhaustive manual attack simulation."
    },
    "answer": "B"
  },
  {
    "id": "topic2_10",
    "question": "ProVerif has been applied to analyze protocols in which domains?",
    "options": {
      "A": "Only academic toy examples.",
      "B": "Email services, voting protocols, and ad-hoc routing (e.g., ARAN).",
      "C": "Strictly financial transaction protocols.",
      "D": "Only symmetric-key cryptographic schemes."
    },
    "answer": "B"
  },
  {
    "id": "topic3_1",
    "question": "Which of the following is a valid rule for constructing identifiers in the given formalism?",
    "options": {
      "A": "Identifiers must begin with a digit.",
      "B": "Identifiers must begin with a letter and can include underscores and digits.",
      "C": "Identifiers cannot include letters from the ISO Latin 1 character set.",
      "D": "Identifiers are case-insensitive."
    },
    "answer": "B"
  },
  {
    "id": "topic3_2",
    "question": "What is the primary distinction between names (e.g., `a`, `b`, `c`) and variables (e.g., `x`, `y`, `z`) in this formalism?",
    "options": {
      "A": "Names represent atomic data like keys, while variables can be substituted by terms.",
      "B": "Variables represent atomic data, while names can be substituted by terms.",
      "C": "Names and variables are interchangeable.",
      "D": "Variables must always be declared with a destructor type."
    },
    "answer": "A"
  },
  {
    "id": "topic3_3",
    "question": "Which of the following is NOT allowed as the first character of an identifier?",
    "options": {
      "A": "A lowercase letter (e.g., `a`).",
      "B": "An underscore (`_`).",
      "C": "An uppercase letter (e.g., `A`).",
      "D": "A digit (e.g., `1`)."
    },
    "answer": "D"
  },
  {
    "id": "topic3_4",
    "question": "How are reserved words (e.g., `channel`, `let`, `type`) treated in the formalism?",
    "options": {
      "A": "They can be used as identifiers if declared with a special keyword.",
      "B": "They cannot be used as identifiers under any circumstances.",
      "C": "They are case-insensitive, so variations like `CHANNEL` are allowed.",
      "D": "They are only reserved when used in destructor applications."
    },
    "answer": "B"
  },
  {
    "id": "topic3_5",
    "question": "Which of the following is a valid identifier in the formalism?",
    "options": {
      "A": "`1key`",
      "B": "`_private`",
      "C": "`let` (reserved word)",
      "D": "`nonce'123`"
    },
    "answer": "D"
  },
  {
    "id": "topic3_6",
    "question": "What is the requirement for declaring names and variables in the formalism?",
    "options": {
      "A": "They must be declared with their type before use.",
      "B": "Names must be declared, but variables can be used freely.",
      "C": "Only variables used in destructors need declarations.",
      "D": "Declaration is optional for names but mandatory for variables."
    },
    "answer": "A"
  },
  {
    "id": "topic3_7",
    "question": "Which character set is allowed in identifiers beyond letters and digits?",
    "options": {
      "A": "Only underscores (`_`).",
      "B": "Underscores (`_`), single-quotes (`'`), and ISO Latin 1 accented letters.",
      "C": "Only ISO Latin 1 accented letters.",
      "D": "Special symbols like `@` and `#`."
    },
    "answer": "B"
  },
  {
    "id": "topic3_8",
    "question": "What happens if an identifier matches a reserved word (e.g., `process`)?",
    "options": {
      "A": "It is treated as a variable if declared with a type.",
      "B": "It causes a syntax error because reserved words cannot be identifiers.",
      "C": "It is allowed if used in a constructor application.",
      "D": "It is automatically renamed by the parser."
    },
    "answer": "B"
  },
  {
    "id": "topic3_9",
    "question": "Which of the following is true about the case sensitivity of identifiers?",
    "options": {
      "A": "Identifiers are case-insensitive (e.g., `Key` and `key` are the same).",
      "B": "Identifiers are case-sensitive (e.g., `Key` and `key` are distinct).",
      "C": "Only variables are case-sensitive; names are not.",
      "D": "Case sensitivity depends on the type of the identifier."
    },
    "answer": "B"
  },
  {
    "id": "topic3_10",
    "question": "In the formalism, which of the following is discouraged but technically allowed?",
    "options": {
      "A": "Using reserved words as identifiers.",
      "B": "Using built-in type names (e.g., `nat`, `bool`) as identifiers.",
      "C": "Using underscores in identifiers.",
      "D": "Using numbers as the first character of an identifier."
    },
    "answer": "B"
  },
  {
    "id": "topic4_1",
    "question": "Which of the following is a valid identifier according to the given character set rules?",
    "options": {
      "A": "`1variable`",
      "B": "`_private`",
      "C": "`channel`",
      "D": "`DataValue`"
    },
    "answer": "D"
  },
  {
    "id": "topic4_2",
    "question": "What is the role of the reserved word `channel` in the grammar?",
    "options": {
      "A": "It denotes a type identifier (`⟨typeid⟩`).",
      "B": "It is used to declare process communication.",
      "C": "It represents a mathematical operator.",
      "D": "It is a placeholder for natural numbers."
    },
    "answer": "A"
  },
  {
    "id": "topic4_3",
    "question": "Which of the following is NOT a reserved word or keyword in the given grammar?",
    "options": {
      "A": "`event`",
      "B": "`let`",
      "C": "`private`",
      "D": "`calculate`"
    },
    "answer": "D"
  },
  {
    "id": "topic4_4",
    "question": "How are identifiers distinguished from reserved words in the grammar?",
    "options": {
      "A": "Reserved words are always uppercase.",
      "B": "Identifiers cannot overlap with reserved words.",
      "C": "Reserved words are enclosed in `⟨ ⟩`.",
      "D": "Identifiers must end with a digit."
    },
    "answer": "B"
  },
  {
    "id": "topic4_5",
    "question": "Which of the following infix operators has the highest precedence?",
    "options": {
      "A": "`==>`",
      "B": "`&&`",
      "C": "`+`",
      "D": "`=`"
    },
    "answer": "C"
  },
  {
    "id": "topic4_6",
    "question": "What syntactic category does `inj-event` belong to?",
    "options": {
      "A": "A reserved type identifier.",
      "B": "A keyword for process synchronization.",
      "C": "A function symbol in `⟨gterm⟩`.",
      "D": "An infix operator."
    },
    "answer": "C"
  },
  {
    "id": "topic4_7",
    "question": "In the grammar, what is the semantic role of the keyword `new`?",
    "options": {
      "A": "To declare a rewrite rule.",
      "B": "To introduce a fresh variable (binding).",
      "C": "To define a natural number constant.",
      "D": "To mark a term as public."
    },
    "answer": "B"
  },
  {
    "id": "topic4_8",
    "question": "Which keyword is used to introduce a conditional term in `⟨gterm⟩`?",
    "options": {
      "A": "`if`",
      "B": "`choice`",
      "C": "`let`",
      "D": "`==>`"
    },
    "answer": "B"
  },
  {
    "id": "topic4_9",
    "question": "What is the significance of the `fail` keyword in `⟨mayfailterm⟩`?",
    "options": {
      "A": "It indicates an error in type checking.",
      "B": "It represents an explicit failure case in term evaluation.",
      "C": "It is used to terminate processes.",
      "D": "It marks a term as optional."
    },
    "answer": "B"
  },
  {
    "id": "topic4_10",
    "question": "Which reserved word is associated with declaring non-interference properties?",
    "options": {
      "A": "`noninterf`",
      "B": "`private`",
      "C": "`secret`",
      "D": "`event`"
    },
    "answer": "A"
  },
  {
    "id": "topic5_1",
    "question": "Which of the following is NOT a reserved keyword in ProVerif?",
    "options": {
      "A": "`event`",
      "B": "`new`",
      "C": "`loop`",
      "D": "`forall`"
    },
    "answer": "C"
  },
  {
    "id": "topic5_2",
    "question": "What does the `new` operator in ProVerif primarily represent?",
    "options": {
      "A": "Creating a new equation for destructors.",
      "B": "Generating a fresh random name/identifier.",
      "C": "Defining a recursive function.",
      "D": "Outputting a message on a channel."
    },
    "answer": "B"
  },
  {
    "id": "topic5_3",
    "question": "Which operator is used to represent observational equivalence in ProVerif?",
    "options": {
      "A": "`==`",
      "B": "`=`",
      "C": "`equiv`",
      "D": "`diff`"
    },
    "answer": "D"
  },
  {
    "id": "topic5_4",
    "question": "What is the purpose of the `destructor` in ProVerif compared to the applied pi calculus?",
    "options": {
      "A": "It replaces equational theories for term simplification.",
      "B": "It encrypts messages automatically.",
      "C": "It replicates processes for parallel execution.",
      "D": "It enforces type-checking for variables."
    },
    "answer": "A"
  },
  {
    "id": "topic5_5",
    "question": "How is term equality written in ProVerif patterns?",
    "options": {
      "A": "`M == N`",
      "B": "`M = N`",
      "C": "`equal(M, N)`",
      "D": "`M eq N`"
    },
    "answer": "B"
  },
  {
    "id": "topic5_6",
    "question": "Which operator pair represents conjunction and disjunction in ProVerif terms?",
    "options": {
      "A": "`AND` / `OR`",
      "B": "`&&` / `||`",
      "C": "`∧` / `∨`",
      "D": "`and` / `or`"
    },
    "answer": "B"
  },
  {
    "id": "topic5_7",
    "question": "What does the `out(M, N); P` operator sequence do?",
    "options": {
      "A": "Receives message `N` on channel `M` and continues as `P`.",
      "B": "Sends message `N` on channel `M` and continues as `P`.",
      "C": "Binds variable `N` to input from `M` for `P`.",
      "D": "Checks if `M` equals `N` before executing `P`."
    },
    "answer": "B"
  },
  {
    "id": "topic5_8",
    "question": "Which setting adjusts the precision of fresh name analysis in ProVerif?",
    "options": {
      "A": "`set allowDiffPatterns = true.`",
      "B": "`set movenew = true.`",
      "C": "`set predicatesImplementable = check.`",
      "D": "`set elimtrue = false.`"
    },
    "answer": "B"
  },
  {
    "id": "topic5_9",
    "question": "What is the default behavior of ProVerif regarding attacker knowledge?",
    "options": {
      "A": "It checks if the attacker can distinguish a value from a random one.",
      "B": "It verifies if the attacker can compute the value of a variable.",
      "C": "It assumes all names are public by default.",
      "D": "It ignores free variables in processes."
    },
    "answer": "B"
  },
  {
    "id": "topic5_10",
    "question": "Which construct is used to model non-deterministic choice in ProVerif?",
    "options": {
      "A": "`choice`",
      "B": "`or`",
      "C": "`diff`",
      "D": "`select`"
    },
    "answer": "A"
  },
  {
    "id": "topic6_1",
    "question": "What is the correct interpretation of the empty sequence `seq+⟨X⟩` in the given formalism?",
    "options": {
      "A": "It represents exactly one element of `⟨X⟩`.",
      "B": "It represents one or more elements of `⟨X⟩` separated by commas.",
      "C": "It represents zero elements of `⟨X⟩`.",
      "D": "It represents a reserved keyword."
    },
    "answer": "B"
  },
  {
    "id": "topic6_2",
    "question": "Which of the following is a valid use of delimiters for enclosing comments in the input file?",
    "options": {
      "A": "`(* This is a comment *)`",
      "B": "`// This is a comment`",
      "C": "`# This is a comment #`",
      "D": "`{ This is a comment }`"
    },
    "answer": "A"
  },
  {
    "id": "topic6_3",
    "question": "How are nested comments handled in the given formalism?",
    "options": {
      "A": "Nested comments are not allowed.",
      "B": "Nested comments are supported (e.g., `(* (* nested *) *)`).",
      "C": "Nested comments are only allowed if they use different delimiters.",
      "D": "Nested comments are automatically flattened."
    },
    "answer": "B"
  },
  {
    "id": "topic6_4",
    "question": "In the grammar rule `⟨gbinding⟩ ::= !⟨nat⟩ = ⟨gterm⟩ [; ⟨gbinding⟩]`, what is the role of the semicolon (`;`)?",
    "options": {
      "A": "It terminates the entire rule.",
      "B": "It separates multiple `⟨gbinding⟩` declarations.",
      "C": "It is optional and has no semantic meaning.",
      "D": "It denotes a comment."
    },
    "answer": "B"
  },
  {
    "id": "topic6_5",
    "question": "Which delimiter pair is used to group terms in the rule `| (seq⟨gterm⟩)`?",
    "options": {
      "A": "`[]`",
      "B": "`{}`",
      "C": "`()`",
      "D": "`⟨⟩`"
    },
    "answer": "C"
  },
  {
    "id": "topic6_6",
    "question": "What is the precedence order of the infix symbols `||`, `&&`, and `==>`?",
    "options": {
      "A": "`==>` has the highest precedence, followed by `&&`, then `||`.",
      "B": "`||` has the highest precedence, followed by `&&`, then `==>`.",
      "C": "`==>` has the lowest precedence, followed by `&&`, then `||`.",
      "D": "`&&` has the highest precedence, followed by `||`, then `==>`."
    },
    "answer": "C"
  },
  {
    "id": "topic6_7",
    "question": "In the rule `⟨failtypedecl⟩ ::= seq+⟨ident⟩: ⟨typeid⟩[or fail][,⟨failtypedecl⟩]`, what does the comma (`,`) signify?",
    "options": {
      "A": "It separates alternative declarations.",
      "B": "It terminates the declaration.",
      "C": "It separates multiple `⟨failtypedecl⟩` entries.",
      "D": "It is a placeholder for optional text."
    },
    "answer": "C"
  },
  {
    "id": "topic6_8",
    "question": "Which of the following is a valid identifier according to the given rules?",
    "options": {
      "A": "`1variable`",
      "B": "`_name`",
      "C": "`VarName`",
      "D": "`&&operator`"
    },
    "answer": "C"
  },
  {
    "id": "topic6_9",
    "question": "In the I/O rule `E,P∪{{out(N,M); P,in(N,x); Q}},A`, what is the purpose of the semicolon (`;`)?",
    "options": {
      "A": "It separates parallel processes.",
      "B": "It terminates the process declaration.",
      "C": "It separates sequential actions within a process.",
      "D": "It denotes a comment."
    },
    "answer": "C"
  },
  {
    "id": "topic6_10",
    "question": "How are function symbols like `&&` and `||` restricted in reduc and equation declarations?",
    "options": {
      "A": "They are allowed as constructors.",
      "B": "They are allowed as destructors.",
      "C": "They are not allowed; only constructors are permitted.",
      "D": "They are allowed only in nested terms."
    },
    "answer": "C"
  },
  {
    "id": "topic7_1",
    "question": "How does ProVerif handle syntax errors in the input code?",
    "options": {
      "A": "It ignores the error and continues execution.",
      "B": "It indicates the character position (line and column numbers) of the error.",
      "C": "It only logs the error without any details.",
      "D": "It automatically corrects the error."
    },
    "answer": "B"
  },
  {
    "id": "topic7_2",
    "question": "Which of the following is a valid way to include comments in ProVerif code?",
    "options": {
      "A": "Using `/* ... */` for multi-line comments.",
      "B": "Using `//` for single-line comments.",
      "C": "Comments are not supported in ProVerif.",
      "D": "Using `#` for single-line comments."
    },
    "answer": "A"
  },
  {
    "id": "topic7_3",
    "question": "What role do whitespace characters (spaces, tabs, newlines) play in ProVerif's syntax?",
    "options": {
      "A": "They are ignored and have no syntactic significance.",
      "B": "They are required to separate keywords and identifiers.",
      "C": "They are only significant inside comments.",
      "D": "They can replace parentheses in expressions."
    },
    "answer": "B"
  },
  {
    "id": "topic7_4",
    "question": "How does ProVerif treat newline characters in process declarations?",
    "options": {
      "A": "Newlines are mandatory after every semicolon.",
      "B": "Newlines are optional and used only for readability.",
      "C": "Newlines terminate process declarations prematurely.",
      "D": "Newlines are equivalent to semicolons."
    },
    "answer": "B"
  },
  {
    "id": "topic7_5",
    "question": "Which of the following is NOT a reserved keyword in ProVerif?",
    "options": {
      "A": "`event`",
      "B": "`let`",
      "C": "`comment`",
      "D": "`new`"
    },
    "answer": "C"
  },
  {
    "id": "topic7_6",
    "question": "What happens if a reserved keyword (e.g., `event`) is used as an identifier in ProVerif?",
    "options": {
      "A": "It is automatically converted to a valid identifier.",
      "B": "It causes a syntax error.",
      "C": "It is treated as a comment.",
      "D": "It is allowed as long as it is in lowercase."
    },
    "answer": "B"
  },
  {
    "id": "topic7_7",
    "question": "In ProVerif, how are multiple statements separated within a process?",
    "options": {
      "A": "By commas.",
      "B": "By semicolons or newlines.",
      "C": "By colons.",
      "D": "By parentheses."
    },
    "answer": "B"
  },
  {
    "id": "topic7_8",
    "question": "Which of the following is true about ProVerif's error messages?",
    "options": {
      "A": "They are only displayed for critical errors.",
      "B": "They include line and column numbers for syntax errors.",
      "C": "They are suppressed by default.",
      "D": "They are only visible in interactive mode."
    },
    "answer": "B"
  },
  {
    "id": "topic7_9",
    "question": "What is the purpose of indentation (spaces/tabs) in ProVerif code?",
    "options": {
      "A": "It is syntactically required for block structure.",
      "B": "It is optional but improves readability.",
      "C": "It replaces the need for semicolons.",
      "D": "It is used to denote comments."
    },
    "answer": "B"
  },
  {
    "id": "topic7_10",
    "question": "Which editor feature is specifically mentioned for editing ProVerif code?",
    "options": {
      "A": "Syntax highlighting for reserved keywords.",
      "B": "Auto-correction of reserved keyword misuse.",
      "C": "Integration with ProVerif's interactive mode.",
      "D": "Line numbers matching error messages."
    },
    "answer": "A"
  },
  {
    "id": "topic8_1",
    "question": "What is the correct syntax to declare a constant `c` of type `t` in ProVerif?",
    "options": {
      "A": "`const c = t.`",
      "B": "`const c : t.`",
      "C": "`fun c() : t.`",
      "D": "`free c : t.`"
    },
    "answer": "B"
  },
  {
    "id": "topic8_2",
    "question": "Which identifiers are typically used to range over *names* (e.g., keys, nonces) in ProVerif?",
    "options": {
      "A": "`x, y, z`",
      "B": "`a, b, c, k`",
      "C": "`f, g, h`",
      "D": "`true, false`"
    },
    "answer": "B"
  },
  {
    "id": "topic8_3",
    "question": "How must free names (e.g., `n`) be declared before use in an input file?",
    "options": {
      "A": "`free n = t.`",
      "B": "`name n : t.`",
      "C": "`free n : t.`",
      "D": "They can be used without declaration."
    },
    "answer": "C"
  },
  {
    "id": "topic8_4",
    "question": "What does the function declaration `h(T1,...,Tn) : T` indicate?",
    "options": {
      "A": "`h` is a destructor returning type `T`.",
      "B": "`h` takes arguments of types `T1` to `Tn` and returns type `T`.",
      "C": "`h` is a constant of type `T`.",
      "D": "`h` is a free name."
    },
    "answer": "B"
  },
  {
    "id": "topic8_5",
    "question": "Which of the following is *not* a built-in type in ProVerif?",
    "options": {
      "A": "`bitstring`",
      "B": "`bool`",
      "C": "`string`",
      "D": "`nat`"
    },
    "answer": "C"
  },
  {
    "id": "topic8_6",
    "question": "What is the purpose of the `type t.` declaration?",
    "options": {
      "A": "To define a destructor.",
      "B": "To introduce a user-defined type `t`.",
      "C": "To declare a free name.",
      "D": "To assign a value to a constant."
    },
    "answer": "B"
  },
  {
    "id": "topic8_7",
    "question": "Which construct is used to declare a function symbol (constructor/destructor) in ProVerif?",
    "options": {
      "A": "`free f : t.`",
      "B": "`fun f(seq<typeid>) : typeid.`",
      "C": "`const f : t.`",
      "D": "`let f = term.`"
    },
    "answer": "B"
  },
  {
    "id": "topic8_8",
    "question": "What is the role of variables (e.g., `x, y, z`) in ProVerif?",
    "options": {
      "A": "They represent atomic data like nonces.",
      "B": "They can be substituted by terms.",
      "C": "They are constants of type `bitstring`.",
      "D": "They must be declared with `free`."
    },
    "answer": "B"
  },
  {
    "id": "topic8_9",
    "question": "Which option is *not* valid for declarations like `free` or `reduc`?",
    "options": {
      "A": "`private`",
      "B": "`public`",
      "C": "`memberOptim`",
      "D": "`precise`"
    },
    "answer": "B"
  },
  {
    "id": "topic8_10",
    "question": "What is the correct way to declare multiple free names of the same type `t`?",
    "options": {
      "A": "`free n1 : t, n2 : t.`",
      "B": "`free n1, n2 : t.`",
      "C": "`free (n1, n2) : t.`",
      "D": "Both A and B are correct."
    },
    "answer": "D"
  },
  {
    "id": "topic9_1",
    "question": "What is the primary role of destructors in the given formalism?",
    "options": {
      "A": "To create new terms by combining variables and names.",
      "B": "To manipulate terms through predefined rewrite rules.",
      "C": "To replace constructors in all term-building operations.",
      "D": "To declare new types for free names."
    },
    "answer": "B"
  },
  {
    "id": "topic9_2",
    "question": "How are destructor function symbols typically declared in the system?",
    "options": {
      "A": "Using the syntax `free g : t`.",
      "B": "Via `reduc` rules or `fun` declarations with `reduc`.",
      "C": "By assigning them to variables directly.",
      "D": "They do not require declaration and are built-in."
    },
    "answer": "B"
  },
  {
    "id": "topic9_3",
    "question": "What is the key difference between constructors and destructors?",
    "options": {
      "A": "Constructors can only fail, while destructors always succeed.",
      "B": "Constructors build terms, while destructors manipulate terms via rewrite rules.",
      "C": "Constructors are optional, while destructors are mandatory.",
      "D": "Destructors are used for type declarations, while constructors are not."
    },
    "answer": "B"
  },
  {
    "id": "topic9_4",
    "question": "Which of the following is a valid way to define a constant in the system?",
    "options": {
      "A": "`free c : t`.",
      "B": "`const c : t`.",
      "C": "`reduc c() : t`.",
      "D": "`fun c : t`."
    },
    "answer": "B"
  },
  {
    "id": "topic9_5",
    "question": "What happens if no rewrite rule applies to a destructor’s input?",
    "options": {
      "A": "The destructor returns a random term.",
      "B": "The destructor fails.",
      "C": "The destructor defaults to the first constructor.",
      "D": "The system prompts for manual input."
    },
    "answer": "B"
  },
  {
    "id": "topic9_6",
    "question": "How are user-defined types introduced in the system?",
    "options": {
      "A": "Using `free t : type`.",
      "B": "Via `type t.`.",
      "C": "Through `fun t() : type`.",
      "D": "They are inferred automatically."
    },
    "answer": "B"
  },
  {
    "id": "topic9_7",
    "question": "Which of the following is NOT a built-in constructor or destructor?",
    "options": {
      "A": "`true` (constructor).",
      "B": "`&&` (destructor).",
      "C": "`modular exponentiation` (destructor).",
      "D": "`+1` (constructor)."
    },
    "answer": "C"
  },
  {
    "id": "topic9_8",
    "question": "What is the purpose of the `forall` clause in destructor rewrite rules?",
    "options": {
      "A": "To restrict the scope of the destructor to specific types.",
      "B": "To universally quantify variables used in the rule’s terms.",
      "C": "To declare free names globally.",
      "D": "To define conditional execution of processes."
    },
    "answer": "B"
  },
  {
    "id": "topic9_9",
    "question": "In the declaration `fun g(T1,...,Tn) : T`, what does `g` represent?",
    "options": {
      "A": "A free name of type `T`.",
      "B": "A constructor function symbol.",
      "C": "A destructor or constructor function symbol.",
      "D": "A variable substitution rule."
    },
    "answer": "C"
  },
  {
    "id": "topic9_10",
    "question": "Which limitation of destructors is highlighted in the content?",
    "options": {
      "A": "They cannot handle atomic data like nonces.",
      "B": "They cannot directly represent modular exponentiation.",
      "C": "They require manual type inference.",
      "D": "They are incompatible with free names."
    },
    "answer": "B"
  },
  {
    "id": "topic10_1",
    "question": "What is a ground term in the given formalism?",
    "options": {
      "A": "A term that contains at least one variable.",
      "B": "A term that contains no variables.",
      "C": "A term that includes the constant `fail`.",
      "D": "A term that is always a constructor application."
    },
    "answer": "B"
  },
  {
    "id": "topic10_2",
    "question": "Which of the following is a valid value in the evaluation relation `D ⇓ V`?",
    "options": {
      "A": "A term containing variables.",
      "B": "A non-ground destructor application.",
      "C": "A ground term or `fail`.",
      "D": "A process with a restriction."
    },
    "answer": "C"
  },
  {
    "id": "topic10_3",
    "question": "How is the expression `let y = D in in(y, x: T); P` represented in the core calculus?",
    "options": {
      "A": "As a direct input process without transformation.",
      "B": "As an expression evaluation moved into the process syntax.",
      "C": "As a restriction on the variable `y`.",
      "D": "As a conditional statement."
    },
    "answer": "B"
  },
  {
    "id": "topic10_4",
    "question": "What does the evaluation of a destructor `g(D₁, ..., Dₙ)` result in if no rewrite rule applies?",
    "options": {
      "A": "The first rule in `def(g)` is forced to apply.",
      "B": "It evaluates to the last term in `def(g)`.",
      "C": "It evaluates to the constant `fail`.",
      "D": "It loops indefinitely until a rule matches."
    },
    "answer": "C"
  },
  {
    "id": "topic10_5",
    "question": "Which of the following constructs is allowed in ProVerif expressions but not in core processes?",
    "options": {
      "A": "Replication (`!P`).",
      "B": "Restriction (`new a: T; D`).",
      "C": "Parallel composition (`P | Q`).",
      "D": "Event (`event(ev); P`)."
    },
    "answer": "B"
  },
  {
    "id": "topic10_6",
    "question": "What is the purpose of the `else` branch in `let x: T = D in D′ else D′′`?",
    "options": {
      "A": "To handle the case where `D` evaluates to `fail`.",
      "B": "To introduce a new name bound to `x`.",
      "C": "To enforce type checking on `D′`.",
      "D": "To parallelize the evaluation of `D′` and `D′′`."
    },
    "answer": "A"
  },
  {
    "id": "topic10_7",
    "question": "Which of the following is NOT a valid component of a may-fail term in destructor rules?",
    "options": {
      "A": "A term `M`.",
      "B": "The constant `fail`.",
      "C": "A may-fail variable `u`.",
      "D": "A process identifier `P`."
    },
    "answer": "D"
  },
  {
    "id": "topic10_8",
    "question": "How is the term `if M then N else N′` evaluated if `M` fails?",
    "options": {
      "A": "It evaluates to `N`.",
      "B": "It evaluates to `N′`.",
      "C": "It evaluates to `fail`.",
      "D": "It raises a runtime error."
    },
    "answer": "C"
  },
  {
    "id": "topic10_9",
    "question": "In the enriched syntax, what can replace occurrences of terms `M` in processes?",
    "options": {
      "A": "Only ground terms.",
      "B": "Only destructor applications.",
      "C": "Expressions `D` (which may include destructors).",
      "D": "Event constructions."
    },
    "answer": "C"
  },
  {
    "id": "topic10_10",
    "question": "Which operator has the highest precedence in the given grammar of terms?",
    "options": {
      "A": "`||` (logical OR).",
      "B": "`&&` (logical AND).",
      "C": "`=` (equality).",
      "D": "`+` (addition)."
    },
    "answer": "D"
  },
  {
    "id": "topic11_1",
    "question": "Which construct represents a process that does nothing in ProVerif?",
    "options": {
      "A": "`null`",
      "B": "`0`",
      "C": "`stop`",
      "D": "`nil`"
    },
    "answer": "B"
  },
  {
    "id": "topic11_2",
    "question": "What is the purpose of the `phase n; P` construct in ProVerif?",
    "options": {
      "A": "To terminate the process after `n` steps.",
      "B": "To synchronize processes globally by advancing to phase `n` and discarding earlier phases.",
      "C": "To loop the process `P` for `n` iterations.",
      "D": "To restrict the scope of names in `P` to phase `n`."
    },
    "answer": "B"
  },
  {
    "id": "topic11_3",
    "question": "How is a constant defined in ProVerif?",
    "options": {
      "A": "`const c = t;`",
      "B": "`fun c(): t.` or `const c : t.`",
      "C": "`let c : t = ...;`",
      "D": "`define c as t;`"
    },
    "answer": "B"
  },
  {
    "id": "topic11_4",
    "question": "Which of the following is NOT a valid process composition construct in ProVerif?",
    "options": {
      "A": "`P | Q` (parallel composition)",
      "B": "`P + Q` (non-deterministic choice)",
      "C": "`!P` (replication)",
      "D": "`new n: t; P` (name restriction)"
    },
    "answer": "B"
  },
  {
    "id": "topic11_5",
    "question": "What does the process `in(M, x: t); P` model?",
    "options": {
      "A": "Output a term `M` on channel `x`, then execute `P`.",
      "B": "Input a term on channel `M`, bind it to `x`, then execute `P`.",
      "C": "Evaluate `M` and assign it to `x`, then run `P`.",
      "D": "Check if `M` equals `x`, then execute `P`."
    },
    "answer": "B"
  },
  {
    "id": "topic11_6",
    "question": "Which construct is used to express correspondence properties (e.g., \"if `end(M)` occurs, `begin(M)` must have occurred\")?",
    "options": {
      "A": "`event(e(M1,...,Mn)); P`",
      "B": "`assert(M); P`",
      "C": "`phase n; P`",
      "D": "`if M then P else Q`"
    },
    "answer": "A"
  },
  {
    "id": "topic11_7",
    "question": "How is the conditional statement structured in ProVerif?",
    "options": {
      "A": "`if M then P` (no else clause).",
      "B": "`if M then P else Q` (else is mandatory).",
      "C": "`case M of P else Q`.",
      "D": "`when M do P`."
    },
    "answer": "B"
  },
  {
    "id": "topic11_8",
    "question": "Which limitation does ProVerif have regarding cryptographic primitives?",
    "options": {
      "A": "It cannot handle symmetric encryption.",
      "B": "Modular exponentiation cannot be directly represented via rewrite rules.",
      "C": "It only supports hash functions.",
      "D": "Destructors cannot be defined."
    },
    "answer": "B"
  },
  {
    "id": "topic11_9",
    "question": "What is the role of `new n: t; P`?",
    "options": {
      "A": "To create a public channel `n` for process `P`.",
      "B": "To restrict the scope of the fresh name `n` to process `P`.",
      "C": "To declare a global variable `n` of type `t`.",
      "D": "To output `n` on channel `t`."
    },
    "answer": "B"
  },
  {
    "id": "topic11_10",
    "question": "Which process construct is used to model infinite replication of `P`?",
    "options": {
      "A": "`loop P`",
      "B": "`!P`",
      "C": "`repeat P`",
      "D": "`P*`"
    },
    "answer": "B"
  },
  {
    "id": "topic12_1",
    "question": "What is the primary purpose of process macros in ProVerif?",
    "options": {
      "A": "To replace cryptographic primitives with simpler constructs.",
      "B": "To define reusable sub-processes for easier protocol development.",
      "C": "To enforce type checking on free variables.",
      "D": "To eliminate the need for a main process."
    },
    "answer": "B"
  },
  {
    "id": "topic12_2",
    "question": "How is a process macro formally declared in ProVerif?",
    "options": {
      "A": "`macro R(x1:t1, ..., xn:tn) := P`",
      "B": "`let R(x1:t1, ..., xn:tn) = P`",
      "C": "`def R(x1:t1, ..., xn:tn) { P }`",
      "D": "`process R(x1:t1, ..., xn:tn) -> P`"
    },
    "answer": "B"
  },
  {
    "id": "topic12_3",
    "question": "What happens during the expansion of a macro `R(M1, ..., Mn)`?",
    "options": {
      "A": "The macro name `R` is replaced with `P`, ignoring arguments.",
      "B": "`P` is substituted with `M1, ..., Mn` replacing its free variables.",
      "C": "The process `P` is executed first, followed by the main process.",
      "D": "The macro is validated against cryptographic primitives."
    },
    "answer": "B"
  },
  {
    "id": "topic12_4",
    "question": "Which of the following must be declared before use in a ProVerif process?",
    "options": {
      "A": "Only free names.",
      "B": "Only variables in macros.",
      "C": "Free names, types, and constructors.",
      "D": "Destructors and phase numbers."
    },
    "answer": "C"
  },
  {
    "id": "topic12_5",
    "question": "What is the role of `phase n; P` in ProVerif?",
    "options": {
      "A": "It terminates all processes not in phase `n`.",
      "B": "It synchronizes processes globally by advancing to phase `n`.",
      "C": "It encrypts messages sent during phase `n`.",
      "D": "It defines a macro for phase-specific sub-processes."
    },
    "answer": "B"
  },
  {
    "id": "topic12_6",
    "question": "How does ProVerif handle macros in the final interpreted process?",
    "options": {
      "A": "Macros are retained as-is for readability.",
      "B": "Macros are expanded, and names/variables are given unique identifiers.",
      "C": "Macros are replaced with Horn clauses.",
      "D": "Macros are removed if unused in the main process."
    },
    "answer": "B"
  },
  {
    "id": "topic12_7",
    "question": "In the example `let R'(y:bitstring) = 0`, what does `0` represent?",
    "options": {
      "A": "A null cryptographic primitive.",
      "B": "A terminated or empty process.",
      "C": "A placeholder for phase synchronization.",
      "D": "An error in macro definition."
    },
    "answer": "B"
  },
  {
    "id": "topic12_8",
    "question": "What is the effect of omitting macro definitions and expanding them directly in the main process?",
    "options": {
      "A": "It alters the protocol’s security properties.",
      "B": "It makes no semantic difference but may reduce readability.",
      "C": "It forces ProVerif to use tree automata.",
      "D": "It invalidates type declarations."
    },
    "answer": "B"
  },
  {
    "id": "topic12_9",
    "question": "Which construct is used to declare a free name `n` of type `t` in ProVerif?",
    "options": {
      "A": "`free n : t`",
      "B": "`name n : t`",
      "C": "`let n : t`",
      "D": "`declare n : t`"
    },
    "answer": "A"
  },
  {
    "id": "topic12_10",
    "question": "What does ProVerif annotate in the interpreted process output to help users debug scope issues?",
    "options": {
      "A": "Phase numbers next to each process.",
      "B": "Unique identifiers `{n}` for program points.",
      "C": "Macro expansion timestamps.",
      "D": "Cryptographic primitive signatures."
    },
    "answer": "B"
  },
  {
    "id": "topic13_1",
    "question": "In the given formalism, what must be done before using a variable or a name in a process declaration?",
    "options": {
      "A": "It can be used without prior declaration.",
      "B": "It must be declared with its type before use.",
      "C": "It must be declared only if used in a conditional statement.",
      "D": "Declaration is optional for free names."
    },
    "answer": "B"
  },
  {
    "id": "topic13_2",
    "question": "What is the scope of a name declared as `new a:nonce` in the process `new a:nonce; out(c, a)`?",
    "options": {
      "A": "The scope is limited to the `out(c, a)` command.",
      "B": "The scope extends to the entire process block.",
      "C": "The scope is global and persists beyond the process.",
      "D": "The scope depends on the enclosing conditional statement."
    },
    "answer": "B"
  },
  {
    "id": "topic13_3",
    "question": "How is a name represented if it is declared inside the scope of variables, e.g., `in(c, (x, y)); new b:nonce`?",
    "options": {
      "A": "As `b[]` since variables do not affect naming.",
      "B": "As `b[x=M, y=N]` where M, N are runtime values of x, y.",
      "C": "As `b` without any arguments.",
      "D": "As `b[x, y]` without substitution."
    },
    "answer": "B"
  },
  {
    "id": "topic13_4",
    "question": "What happens if a variable is not universally quantified in a clause containing variables?",
    "options": {
      "A": "The clause is invalid and rejected.",
      "B": "The clause is treated as if variables are existentially quantified.",
      "C": "The clause is allowed only if no variables are used.",
      "D": "The variables are automatically assigned the `fail` type."
    },
    "answer": "A"
  },
  {
    "id": "topic13_5",
    "question": "Which of the following ensures identifier uniqueness in declarations?",
    "options": {
      "A": "All identifiers must have distinct names, regardless of type.",
      "B": "Variables and names can share identifiers if their types differ.",
      "C": "Identifiers must be unique only within the same category (e.g., two variables cannot share a name).",
      "D": "Identifiers must be unique only if used in the same process."
    },
    "answer": "C"
  },
  {
    "id": "topic13_6",
    "question": "What is the consequence of omitting `else 0` in nested `if-then-else` constructs?",
    "options": {
      "A": "The `else` clause is automatically attached to the outer `if`.",
      "B": "The `else` clause is automatically attached to the inner `if`.",
      "C": "The process becomes syntactically invalid.",
      "D": "The ambiguity must be resolved by explicit parentheses."
    },
    "answer": "D"
  },
  {
    "id": "topic13_7",
    "question": "In the clause `forall x1:t1, ..., xn:tn; F1, ..., Fm -> F`, when can the universal quantification part be omitted?",
    "options": {
      "A": "If at least one variable is present in F1, ..., Fm, F.",
      "B": "If no variables are present in F1, ..., Fm, F.",
      "C": "If the types t1, ..., tn include the `fail` type.",
      "D": "If the clause is used only once in the process."
    },
    "answer": "B"
  },
  {
    "id": "topic13_8",
    "question": "Why is distinct naming of variables and names recommended?",
    "options": {
      "A": "To allow variables and names to be used interchangeably.",
      "B": "To avoid confusion and ensure clarity in process definitions.",
      "C": "Because ProVerif requires names to be longer than variables.",
      "D": "Because variables cannot be substituted if names overlap."
    },
    "answer": "B"
  },
  {
    "id": "topic13_9",
    "question": "What is the significance of the `[precise]` annotation for an input?",
    "options": {
      "A": "It enforces exact matching of input values.",
      "B": "It ensures the input is processed only once.",
      "C": "It tells ProVerif to generate more precise axioms for the input.",
      "D": "It restricts the input to non-variable types."
    },
    "answer": "C"
  },
  {
    "id": "topic13_10",
    "question": "Which of the following is true about function symbol declarations?",
    "options": {
      "A": "Destructors can only be declared after constructors.",
      "B": "Function symbols must be declared with their types before use.",
      "C": "Function symbols can be used without declaration if they are infix operators.",
      "D": "Only constructors require type declarations."
    },
    "answer": "B"
  },
  {
    "id": "topic14_1",
    "question": "What is a key requirement for the arguments of a destructor in rewrite rules?",
    "options": {
      "A": "They must be of arbitrary types.",
      "B": "They must have the same type as the corresponding arguments in all other rewrite rules for that destructor.",
      "C": "They must always include at least one variable.",
      "D": "Their types can differ as long as the return type is consistent."
    },
    "answer": "B"
  },
  {
    "id": "topic14_2",
    "question": "When does a destructor term fail during evaluation?",
    "options": {
      "A": "If any of its arguments is a constructor term.",
      "B": "If no rewrite rule applies to the term.",
      "C": "If the term contains a may-fail constructor.",
      "D": "If the term is nested inside another destructor."
    },
    "answer": "B"
  },
  {
    "id": "topic14_3",
    "question": "What defines a \"simple pattern\" in pattern-matching?",
    "options": {
      "A": "It contains no destructor symbols, and all `=D` occurrences use may-fail constructor terms.",
      "B": "It must include at least one destructor symbol.",
      "C": "It can only match tuples.",
      "D": "It ignores type consistency."
    },
    "answer": "A"
  },
  {
    "id": "topic14_4",
    "question": "How are data constructors distinguished from other constructors?",
    "options": {
      "A": "They have no associated destructors.",
      "B": "They come with associated destructors (e.g., `gi(f(x1,...,xn)) → xi`).",
      "C": "They can only be used in conditional statements.",
      "D": "They must return a boolean value."
    },
    "answer": "B"
  },
  {
    "id": "topic14_5",
    "question": "What is a requirement for the return type of a destructor across its rewrite rules?",
    "options": {
      "A": "Each rule can return a different type.",
      "B": "All rules must return the same type as `M1,0`.",
      "C": "The return type must match the type of the first argument.",
      "D": "Return types are irrelevant for destructors."
    },
    "answer": "B"
  },
  {
    "id": "topic14_6",
    "question": "What happens during pattern-matching if a term `M` contains a destructor that fails?",
    "options": {
      "A": "The matching succeeds with a default value.",
      "B": "The matching fails.",
      "C": "The destructor is skipped, and the rest of the term is evaluated.",
      "D": "The term is automatically converted to a constructor term."
    },
    "answer": "B"
  },
  {
    "id": "topic14_7",
    "question": "What is true about the `equal` destructor in the simplified ProVerif language?",
    "options": {
      "A": "It can occur anywhere in terms.",
      "B": "It is the only allowed destructor and must only appear in conditionals (`M = N`).",
      "C": "It can be used to define new function symbols.",
      "D": "It ignores type consistency."
    },
    "answer": "B"
  },
  {
    "id": "topic14_8",
    "question": "What is a constraint on type converter functions during pattern-matching?",
    "options": {
      "A": "They must return the same type as their argument.",
      "B": "Their application must be identifiable, and their output must differ from inputs/other converters.",
      "C": "They can only be applied to tuples.",
      "D": "They are exempt from type-checking."
    },
    "answer": "B"
  },
  {
    "id": "topic14_9",
    "question": "In a `let x = M in P else Q` statement, what happens if `M` contains a failing destructor?",
    "options": {
      "A": "`P` is executed with `x` bound to a default value.",
      "B": "`Q` is executed.",
      "C": "The process terminates abruptly.",
      "D": "`M` is retried with the next applicable rewrite rule."
    },
    "answer": "B"
  },
  {
    "id": "topic14_10",
    "question": "What is a requirement for the arguments of a function macro in ProVerif?",
    "options": {
      "A": "They must all be destructor terms.",
      "B": "They must match the parameter count and types declared in the macro definition.",
      "C": "Macros cannot have arguments.",
      "D": "Argument types are inferred dynamically."
    },
    "answer": "B"
  },
  {
    "id": "topic15_1",
    "question": "What is the primary purpose of the query `query attacker(M).` in ProVerif?",
    "options": {
      "A": "To check if the term *M* can be derived by the attacker.",
      "B": "To encrypt the term *M* for secure transmission.",
      "C": "To declare *M* as a private name in the process.",
      "D": "To generate a new nonce for the term *M*."
    },
    "answer": "A"
  },
  {
    "id": "topic15_2",
    "question": "Which of the following terms is *not* a valid requirement for *M* in the query `query attacker(M).`?",
    "options": {
      "A": "*M* must be a ground term.",
      "B": "*M* must contain destructors.",
      "C": "*M* must not contain free names.",
      "D": "*M* must be syntactically well-formed."
    },
    "answer": "B"
  },
  {
    "id": "topic15_3",
    "question": "What does \"strong secrecy\" in ProVerif ensure?",
    "options": {
      "A": "The adversary can distinguish between two versions of the protocol using different secrets.",
      "B": "The adversary cannot distinguish between two versions of the protocol using different secrets.",
      "C": "The adversary can always decrypt the secret.",
      "D": "The secret is transmitted in plaintext."
    },
    "answer": "B"
  },
  {
    "id": "topic15_4",
    "question": "Which ProVerif query would you use to verify the syntactic secrecy of a term *k*?",
    "options": {
      "A": "`secret(k).`",
      "B": "`query attacker(k).`",
      "C": "`assert secrecy(k).`",
      "D": "`verify(k).`"
    },
    "answer": "B"
  },
  {
    "id": "topic15_5",
    "question": "According to the core calculus, which property is *not* verified by ProVerif?",
    "options": {
      "A": "Secrecy.",
      "B": "Correspondences.",
      "C": "Computational indistinguishability.",
      "D": "Equivalences."
    },
    "answer": "C"
  },
  {
    "id": "topic15_6",
    "question": "What is the symbolic model's assumption about cryptographic primitives?",
    "options": {
      "A": "They are computationally secure but imperfect.",
      "B": "They are perfect blackboxes with no equations.",
      "C": "They are modeled as function symbols in an algebra of terms.",
      "D": "They are vulnerable to side-channel attacks."
    },
    "answer": "C"
  },
  {
    "id": "topic15_7",
    "question": "Which reference is the main source for ProVerif's proof of secrecy and correspondences?",
    "options": {
      "A": "(Blanchet, 2004).",
      "B": "(Blanchet, 2009).",
      "C": "(Blanchet et al., 2008).",
      "D": "(Abadi and Blanchet, 2005)."
    },
    "answer": "B"
  },
  {
    "id": "topic15_8",
    "question": "What is a prerequisite for verifying secrecy in ProVerif?",
    "options": {
      "A": "The term must be a nonce.",
      "B": "The term must be a ground term without destructors.",
      "C": "The term must be used in a conditional statement.",
      "D": "The term must be a public name."
    },
    "answer": "B"
  },
  {
    "id": "topic15_9",
    "question": "Which class of equivalences is *not* handled by ProVerif?",
    "options": {
      "A": "Strong secrecy.",
      "B": "Observational equivalence.",
      "C": "Computational soundness.",
      "D": "Process bisimulation."
    },
    "answer": "C"
  },
  {
    "id": "topic15_10",
    "question": "In the Dolev-Yao model, what can the adversary *not* do?",
    "options": {
      "A": "Compute terms using cryptographic primitives.",
      "B": "Break cryptographic primitives via mathematical attacks.",
      "C": "Intercept and modify messages.",
      "D": "Generate new nonces."
    },
    "answer": "B"
  },
  {
    "id": "topic16_1",
    "question": "What is the primary purpose of correspondence assertions in protocol verification?",
    "options": {
      "A": "To ensure message encryption is unbreakable.",
      "B": "To verify that if one event occurs, another related event must have or will occur.",
      "C": "To guarantee computational efficiency in protocol execution.",
      "D": "To replace manual proofs entirely in protocol analysis."
    },
    "answer": "B"
  },
  {
    "id": "topic16_2",
    "question": "Which tool translates protocols into Horn clauses for automatic verification of security properties?",
    "options": {
      "A": "Tamarin",
      "B": "ProVerif",
      "C": "Isabelle",
      "D": "Coq"
    },
    "answer": "B"
  },
  {
    "id": "topic16_3",
    "question": "In ProVerif, what are security properties like secrecy and authentication translated into?",
    "options": {
      "A": "Boolean expressions",
      "B": "Horn clauses and derivability queries",
      "C": "Temporal logic formulas",
      "D": "Graph-based models"
    },
    "answer": "B"
  },
  {
    "id": "topic16_4",
    "question": "What limitation does ProVerif have when verifying protocols with stateful participants?",
    "options": {
      "A": "It cannot handle unbounded sessions.",
      "B": "It requires manual lemma guidance like Tamarin.",
      "C": "It cannot fully automate proofs for such protocols.",
      "D": "It only supports public-key encryption."
    },
    "answer": "C"
  },
  {
    "id": "topic16_5",
    "question": "Which of the following properties is NOT typically verified by ProVerif?",
    "options": {
      "A": "Secrecy",
      "B": "Authentication",
      "C": "Observational equivalence",
      "D": "Computational soundness for all protocols"
    },
    "answer": "D"
  },
  {
    "id": "topic16_6",
    "question": "What is a key advantage of using Tamarin over ProVerif for protocol verification?",
    "options": {
      "A": "Tamarin requires no user input for proofs.",
      "B": "Tamarin supports unbounded sessions and temporal logic.",
      "C": "Tamarin does not use Horn clauses.",
      "D": "Tamarin is fully automated for all equivalence properties."
    },
    "answer": "B"
  },
  {
    "id": "topic16_7",
    "question": "Which cryptographic protocol was analyzed using correspondence assertions in [AB05b]?",
    "options": {
      "A": "Direct Anonymous Attestation (DAA)",
      "B": "JFK (Just Fast Keying)",
      "C": "Certified email protocol",
      "D": "Plutus file system"
    },
    "answer": "C"
  },
  {
    "id": "topic16_8",
    "question": "What does the handshake protocol aim to ensure between client A and server B?",
    "options": {
      "A": "Only secrecy of exchanged messages.",
      "B": "Mutual authentication and secrecy.",
      "C": "Computational soundness.",
      "D": "Observational equivalence."
    },
    "answer": "B"
  },
  {
    "id": "topic16_9",
    "question": "Which framework proves computational soundness for ProVerif in the universal composability setting?",
    "options": {
      "A": "Dolev-Yao model",
      "B": "Backes et al. (2014)",
      "C": "Canetti and Herzog (2006)",
      "D": "Schmidt et al. (2012)"
    },
    "answer": "C"
  },
  {
    "id": "topic16_10",
    "question": "What type of logic does Tamarin initially use to express trace properties?",
    "options": {
      "A": "Propositional logic",
      "B": "Temporal first-order logic",
      "C": "Higher-order logic",
      "D": "Modal logic"
    },
    "answer": "B"
  },
  {
    "id": "topic1_1",
    "question": "Which of the following best describes the theoretical foundation of ProVerif’s formal description language?",
    "options": {
      "A": "It is based on a minimal extension of propositional logic.",
      "B": "It is based on the applied pi calculus with function symbols defined by equational theories.",
      "C": "It uses a variant of lambda calculus extended with concurrency features.",
      "D": "It is grounded in first-order predicate logic with temporal operators."
    },
    "answer": "B"
  },
  {
    "id": "topic1_2",
    "question": "What is one key difference between ProVerif and the standard applied pi calculus regarding handling equations?",
    "options": {
      "A": "ProVerif supports all equational theories without restriction.",
      "B": "The applied pi calculus uses destructors instead of equational theories.",
      "C": "ProVerif uses destructors rather than supporting all equational theories.",
      "D": "There are no differences in how equations are handled."
    },
    "answer": "C"
  },
  {
    "id": "topic1_3",
    "question": "What feature does ProVerif include that is not present in the original applied pi calculus?",
    "options": {
      "A": "Support for multithreaded processes",
      "B": "Built-in error-handling constructs such as else branches",
      "C": "Support for higher-order functions",
      "D": "Use of equational theories to define cryptographic primitives"
    },
    "answer": "B"
  },
  {
    "id": "topic1_4",
    "question": "In what way is observational equivalence related to the correspondence between ProVerif and the applied pi calculus?",
    "options": {
      "A": "If two ProVerif processes are observationally equivalent, then their applied pi calculus counterparts cannot be equivalent.",
      "B": "Observational equivalence in ProVerif implies observational equivalence in the applied pi calculus.",
      "C": "ProVerif only proves secrecy properties, not observational equivalences.",
      "D": "Observational equivalence is irrelevant to ProVerif’s verification process."
    },
    "answer": "B"
  },
  {
    "id": "topic1_5",
    "question": "What kind of security properties can ProVerif verify, in addition to secrecy and authentication?",
    "options": {
      "A": "Only performance-related properties",
      "B": "Type safety and memory correctness",
      "C": "Observational equivalence properties",
      "D": "Termination and liveness properties only"
    },
    "answer": "C"
  },
  {
    "id": "topic1_6",
    "question": "What is the role of substitutions in ProVerif's calculus?",
    "options": {
      "A": "They map names to expressions exclusively.",
      "B": "They map variables (not names) to terms or expressions.",
      "C": "They are used to replace function symbols with equational rules.",
      "D": "They are used to simulate network failures in protocol models."
    },
    "answer": "B"
  },
  {
    "id": "topic1_7",
    "question": "Which of the following is",
    "options": {
      "A": "Protocol specification using an extension of the pi calculus",
      "B": "Automatic translation into Horn clauses",
      "C": "Manual proof construction using natural deduction",
      "D": "Resolution engine with selection function"
    },
    "answer": "C"
  },
  {
    "id": "topic1_8",
    "question": "Why is diff-equivalence considered stronger than observational equivalence when comparing processes in ProVerif and the applied pi calculus?",
    "options": {
      "A": "Because it allows for more context changes during execution",
      "B": "Because it requires processes to be identical in all contexts",
      "C": "Because it is easier to prove using equational theories",
      "D": "Because it only applies to deterministic processes"
    },
    "answer": "B"
  },
  {
    "id": "topic1_9",
    "question": "How does ProVerif model cryptographic primitives within its formalism?",
    "options": {
      "A": "Through type annotations and static typing rules",
      "B": "Using built-in constants only, without user-defined operations",
      "C": "By means of rewrite rules or equational theories",
      "D": "By simulating them with probabilistic Turing machines"
    },
    "answer": "C"
  },
  {
    "id": "topic1_10",
    "question": "Which of the following statements about the relationship between ProVerif and the applied pi calculus is correct?",
    "options": {
      "A": "ProVerif can be encoded into the applied pi calculus to prove equivalence.",
      "B": "The applied pi calculus is a strict superset of ProVerif's calculus.",
      "C": "ProVerif and the applied pi calculus are completely incompatible.",
      "D": "ProVerif provides a less expressive formalism than the applied pi calculus."
    },
    "answer": "A"
  },
  {
    "id": "topic2_1",
    "question": "Which of the following best describes the primary purpose of ProVerif?",
    "options": {
      "A": "To simulate network traffic for performance testing",
      "B": "To verify cryptographic protocols for secrecy and authentication",
      "C": "To develop new cryptographic algorithms",
      "D": "To generate secure passwords automatically"
    },
    "answer": "B"
  },
  {
    "id": "topic2_2",
    "question": "What type of attacker model does ProVerif assume when analyzing protocols?",
    "options": {
      "A": "A passive eavesdropper only",
      "B": "An attacker with Dolev-Yao capabilities",
      "C": "A limited insider threat",
      "D": "A quantum computing adversary"
    },
    "answer": "B"
  },
  {
    "id": "topic2_3",
    "question": "Which of the following protocols has NOT been analyzed using ProVerif, according to the text?",
    "options": {
      "A": "TLS",
      "B": "Signal",
      "C": "HTTPS",
      "D": "ARAN"
    },
    "answer": "C"
  },
  {
    "id": "topic2_4",
    "question": "Which of the following is a feature of ProVerif that contributes to its automation?",
    "options": {
      "A": "It requires manual proof steps for every verification",
      "B": "It translates protocols into Horn clauses for analysis",
      "C": "It only works with bounded number of sessions",
      "D": "It supports only symmetric encryption primitives"
    },
    "answer": "B"
  },
  {
    "id": "topic2_5",
    "question": "Which of the following security properties can ProVerif",
    "options": {
      "A": "Secrecy",
      "B": "Authentication",
      "C": "Observational equivalence",
      "D": "Performance efficiency"
    },
    "answer": "D"
  },
  {
    "id": "topic2_6",
    "question": "What makes ProVerif's approach more precise than tree-automata methods?",
    "options": {
      "A": "It uses public-key cryptography",
      "B": "It maintains relational information on messages",
      "C": "It simulates real-world network conditions",
      "D": "It limits the message space to finite values"
    },
    "answer": "B"
  },
  {
    "id": "topic2_7",
    "question": "Which of the following tools or frameworks can use ProVerif as a back-end?",
    "options": {
      "A": "Wireshark",
      "B": "CryptoVerif",
      "C": "OpenSSL",
      "D": "GnuPG"
    },
    "answer": "B"
  },
  {
    "id": "topic2_8",
    "question": "What is one limitation of ProVerif’s Horn clause-based approach?",
    "options": {
      "A": "It only works with symmetric encryption",
      "B": "Termination is not guaranteed in general",
      "C": "It cannot handle concurrency",
      "D": "It requires physical hardware for execution"
    },
    "answer": "B"
  },
  {
    "id": "topic2_9",
    "question": "Which of the following case studies involved verifying a certified email protocol using ProVerif?",
    "options": {
      "A": "Abadi and Blanchet (2005b)",
      "B": "Diffie and Hellman (1976)",
      "C": "Rivest, Shamir, and Adleman (1978)",
      "D": "Needham and Schroeder (1978)"
    },
    "answer": "A"
  },
  {
    "id": "topic2_10",
    "question": "In what educational context is ProVerif currently being taught, according to the passage?",
    "options": {
      "A": "High school cybersecurity courses",
      "B": "Undergraduate computer science programs",
      "C": "Specialized Masters and summer schools",
      "D": "Online MOOCs for beginners"
    },
    "answer": "C"
  },
  {
    "id": "topic3_1",
    "question": "Which of the following characters is NOT allowed as the first character of an identifier in this formalism?",
    "options": {
      "A": "An uppercase letter (e.g., 'A')",
      "B": "A lowercase letter (e.g., 'a')",
      "C": "A digit (e.g., '5')",
      "D": "An underscore ( _ )"
    },
    "answer": "C"
  },
  {
    "id": "topic3_2",
    "question": "In the given language, what restriction applies to identifiers regarding reserved keywords?",
    "options": {
      "A": "Reserved keywords can be used as variable names but not function names.",
      "B": "Reserved keywords cannot be used as identifiers under any circumstances.",
      "C": "Reserved keywords can be used only for built-in types like `bitstring`.",
      "D": "Reserved keywords are case-insensitive and can be reused with different capitalization."
    },
    "answer": "B"
  },
  {
    "id": "topic3_3",
    "question": "Which of the following identifiers would be considered valid according to the specification described?",
    "options": {
      "A": "`my-variable`",
      "B": "`_secretKey`",
      "C": "`2ndAttempt`",
      "D": "`channel`"
    },
    "answer": "B"
  },
  {
    "id": "topic3_4",
    "question": "What is a key difference between names (like `a`, `b`, `c`) and variables (like `x`, `y`, `z`) in this formalism?",
    "options": {
      "A": "Names must always be lowercase, while variables can be uppercase or lowercase.",
      "B": "Variables can be substituted by terms, but names represent fixed atomic data.",
      "C": "Names and variables are interchangeable; the distinction is only conventional.",
      "D": "Variables are restricted to numeric values, while names can be strings."
    },
    "answer": "B"
  },
  {
    "id": "topic3_5",
    "question": "Based on the description, which of the following statements about may-fail variables is correct?",
    "options": {
      "A": "They are a special kind of name that can evaluate to `fail`.",
      "B": "They are a type of variable that can only appear in conditional expressions.",
      "C": "They can be substituted by terms that might evaluate to the special constant `fail`.",
      "D": "They are declared using the keyword `mayfail` and cannot be used in destructors."
    },
    "answer": "C"
  },
  {
    "id": "topic3_6",
    "question": "According to the grammar of enriched terms, which of the following is a valid constructor or destructor application?",
    "options": {
      "A": "`f(x, y, z)` where `f` is a function symbol",
      "B": "`5 + x`",
      "C": "`(x = y)`",
      "D": "`new a : bitstring; a`"
    },
    "answer": "A"
  },
  {
    "id": "topic3_7",
    "question": "What is the significance of the notation ⟨typeid⟩ in the specification?",
    "options": {
      "A": "It represents natural numbers used for indexing.",
      "B": "It denotes integer values such as 5 or -3.",
      "C": "It refers to types, which can be identifiers or the reserved word `channel`.",
      "D": "It defines sequences of options like `[data, private]`."
    },
    "answer": "C"
  },
  {
    "id": "topic3_8",
    "question": "Why do the authors recommend distinct naming of names and variables?",
    "options": {
      "A": "To reduce memory usage during process execution.",
      "B": "To improve performance in rewrite rules.",
      "C": "To avoid confusion and ensure clarity in code.",
      "D": "Because the system does not allow them to have similar spelling."
    },
    "answer": "C"
  },
  {
    "id": "topic3_9",
    "question": "Which of the following best describes the naming policy for function symbols in this formalism?",
    "options": {
      "A": "Function symbols must always start with a digit.",
      "B": "Only single-letter identifiers can be used for functions.",
      "C": "Function symbols are declared with their argument and result types.",
      "D": "Function symbols cannot be overloaded or reused."
    },
    "answer": "C"
  },
  {
    "id": "topic3_10",
    "question": "Which of the following identifiers would be considered invalid due to being a reserved keyword?",
    "options": {
      "A": "`message`",
      "B": "`attacker`",
      "C": "`process`",
      "D": "`secretKey`"
    },
    "answer": "C"
  },
  {
    "id": "topic4_1",
    "question": "Which of the following is a reserved keyword used to represent an event in the grammar?",
    "options": {
      "A": "`choice`",
      "B": "`inj-event`",
      "C": "`let`",
      "D": "`event`"
    },
    "answer": "D"
  },
  {
    "id": "topic4_2",
    "question": "In the grammar, what role does the keyword `let` serve?",
    "options": {
      "A": "Declaring a new type",
      "B": "Defining a function",
      "C": "Binding a value to an identifier within a scope",
      "D": "Declaring a process variable"
    },
    "answer": "C"
  },
  {
    "id": "topic4_3",
    "question": "What is the purpose of the keyword `new` in the grammar?",
    "options": {
      "A": "To declare a new function",
      "B": "To introduce a fresh name or value",
      "C": "To define a conditional expression",
      "D": "To specify a channel type"
    },
    "answer": "B"
  },
  {
    "id": "topic4_4",
    "question": "Which of the following is NOT a valid use of the keyword `channel`?",
    "options": {
      "A": "As part of a type declaration",
      "B": "As a value assigned to a variable",
      "C": "As a built-in type specifier",
      "D": "As a reserved word for communication primitives"
    },
    "answer": "B"
  },
  {
    "id": "topic4_5",
    "question": "Which keyword is used to denote that an event must occur exactly once in all executions?",
    "options": {
      "A": "`once`",
      "B": "`unique`",
      "C": "`inj-event`",
      "D": "`event`"
    },
    "answer": "C"
  },
  {
    "id": "topic4_6",
    "question": "In the context of the grammar, what is the correct use of the keyword `if`?",
    "options": {
      "A": "To begin a process definition",
      "B": "To start a loop structure",
      "C": "To conditionally execute one of two branches",
      "D": "To declare a conditional lemma"
    },
    "answer": "C"
  },
  {
    "id": "topic4_7",
    "question": "Which keyword is used to introduce a failure possibility in a term?",
    "options": {
      "A": "`fail`",
      "B": "`error`",
      "C": "`invalid`",
      "D": "`none`"
    },
    "answer": "A"
  },
  {
    "id": "topic4_8",
    "question": "Which of the following keywords is associated with defining logical properties or assertions?",
    "options": {
      "A": "`lemma`",
      "B": "`rule`",
      "C": "`assert`",
      "D": "`check`"
    },
    "answer": "A"
  },
  {
    "id": "topic4_9",
    "question": "What is the semantic role of the keyword `phase` when used in an event or function call?",
    "options": {
      "A": "It defines the return type",
      "B": "It specifies a temporal ordering constraint",
      "C": "It declares a local variable",
      "D": "It indicates a recursive call"
    },
    "answer": "B"
  },
  {
    "id": "topic4_10",
    "question": "Which of the following is a correct statement about the keyword `private` in the given grammar?",
    "options": {
      "A": "It restricts the visibility of a function",
      "B": "It is an allowed identifier within the `options` syntax",
      "C": "It marks a variable as immutable",
      "D": "It denotes a private communication channel"
    },
    "answer": "B"
  },
  {
    "id": "topic5_1",
    "question": "Which of the following is a valid operator used for term equality in ProVerif?",
    "options": {
      "A": "`&&`",
      "B": "`||`",
      "C": "`=`",
      "D": "`<>`"
    },
    "answer": "C"
  },
  {
    "id": "topic5_2",
    "question": "In ProVerif, what does the operator `<>` represent?",
    "options": {
      "A": "Term disequality",
      "B": "Logical negation",
      "C": "Term equality",
      "D": "Disjunction"
    },
    "answer": "A"
  },
  {
    "id": "topic5_3",
    "question": "What is the correct usage of the `not` operator in ProVerif?",
    "options": {
      "A": "`not M`",
      "B": "`not(M)`",
      "C": "`M not N`",
      "D": "`not{M}`"
    },
    "answer": "B"
  },
  {
    "id": "topic5_4",
    "question": "Which pair of operators represents logical conjunction and disjunction, respectively, in ProVerif?",
    "options": {
      "A": "`&&`, `||`",
      "B": "`and`, `or`",
      "C": "`&`, `|`",
      "D": "`&&`, `|`"
    },
    "answer": "A"
  },
  {
    "id": "topic5_5",
    "question": "How are tuples represented using operators in ProVerif?",
    "options": {
      "A": "`(M1 + M2)`",
      "B": "`{M1, M2}`",
      "C": "`(M1, M2)`",
      "D": "`[M1; M2]`"
    },
    "answer": "C"
  },
  {
    "id": "topic5_6",
    "question": "In ProVerif, what does the expression `h(M1, M2)` most likely represent?",
    "options": {
      "A": "A conditional statement",
      "B": "A name restriction",
      "C": "A constructor or destructor application",
      "D": "A parallel process composition"
    },
    "answer": "C"
  },
  {
    "id": "topic5_7",
    "question": "Which of the following cannot be used as an identifier in ProVerif due to being a reserved keyword?",
    "options": {
      "A": "`message`",
      "B": "`channel`",
      "C": "`protocol`",
      "D": "`data`"
    },
    "answer": "B"
  },
  {
    "id": "topic5_8",
    "question": "What is the function of the `if ... then ... else ...` construct in ProVerif processes?",
    "options": {
      "A": "It defines a new name.",
      "B": "It performs message output.",
      "C": "It executes a conditional branch.",
      "D": "It replicates a process."
    },
    "answer": "C"
  },
  {
    "id": "topic5_9",
    "question": "Which of the following operators or constructs is used to restrict the scope of a fresh name in ProVerif?",
    "options": {
      "A": "`new n : t; P`",
      "B": "`out(M, N); P`",
      "C": "`in(M, x : t); P`",
      "D": "`!P`"
    },
    "answer": "A"
  },
  {
    "id": "topic5_10",
    "question": "Which of the following best describes the purpose of the `=`, `&&`, and `||` operators in ProVerif terms?",
    "options": {
      "A": "They are all used for process replication.",
      "B": "They are used for term manipulation and logical operations.",
      "C": "They define cryptographic functions only.",
      "D": "They are reserved for predicate definitions."
    },
    "answer": "B"
  },
  {
    "id": "topic6_1",
    "question": "Which of the following best describes the purpose of parentheses `()` in the grammar?",
    "options": {
      "A": "To denote comments that should be ignored during parsing.",
      "B": "To group expressions and override operator precedence.",
      "C": "To declare new identifiers or variables.",
      "D": "To indicate function calls only when used with keywords like `let`."
    },
    "answer": "B"
  },
  {
    "id": "topic6_2",
    "question": "In the given formalism, how are sequences of terms separated by commas (e.g., `seq⟨gterm⟩`) interpreted?",
    "options": {
      "A": "As a single atomic expression without internal structure.",
      "B": "As one or more instances of the enclosed non-terminal ⟨gterm⟩, separated by commas.",
      "C": "As a list where each element must be enclosed in curly braces `{}`.",
      "D": "As a binary operation involving two ⟨gterm⟩ expressions."
    },
    "answer": "B"
  },
  {
    "id": "topic6_3",
    "question": "What is the role of square brackets `[]` in the syntax rule `⟨gbinding⟩ ::= !⟨nat⟩ = ⟨gterm⟩ [; ⟨gbinding⟩]`?",
    "options": {
      "A": "They denote optional parts of the grammar.",
      "B": "They enclose mandatory components of the production.",
      "C": "They represent repetition of the enclosed element zero or more times.",
      "D": "They are used for grouping expressions similar to parentheses."
    },
    "answer": "A"
  },
  {
    "id": "topic6_4",
    "question": "In the context of this grammar, what does the vertical bar `|` symbol signify when it appears at the beginning of a line?",
    "options": {
      "A": "It indicates a comment or annotation meant for documentation.",
      "B": "It separates different alternatives in a production rule.",
      "C": "It represents a logical OR between two expressions.",
      "D": "It denotes a continuation of the previous line's rule."
    },
    "answer": "B"
  },
  {
    "id": "topic6_5",
    "question": "Which of the following correctly explains the use of the semicolon `;` in the grammar rule `⟨gbinding⟩ ::= ⟨ident⟩ = ⟨gterm⟩ [; ⟨gbinding⟩]`?",
    "options": {
      "A": "It separates unrelated declarations and has no syntactic significance.",
      "B": "It serves as a delimiter between successive bindings in a sequence.",
      "C": "It always terminates a statement and requires a newline after it.",
      "D": "It is used exclusively for separating arguments in function calls."
    },
    "answer": "B"
  },
  {
    "id": "topic6_6",
    "question": "How are angle brackets ⟨ ⟩ used in this formal grammar notation?",
    "options": {
      "A": "To enclose literal characters that appear directly in the input.",
      "B": "To denote non-terminal symbols in the grammar.",
      "C": "To indicate optional parameters in function definitions.",
      "D": "To define terminal symbols such as reserved keywords."
    },
    "answer": "B"
  },
  {
    "id": "topic6_7",
    "question": "In the phrase `new ⟨ident⟩[[[⟨gbinding⟩]]]`, what does the triple bracket `[[[ ]] ]` indicate?",
    "options": {
      "A": "That the contents are comments and should be ignored.",
      "B": "That the ⟨gbinding⟩ is required and must appear exactly once.",
      "C": "That the ⟨gbinding⟩ is optional and may be repeated multiple times.",
      "D": "That the ⟨gbinding⟩ must be enclosed within square brackets."
    },
    "answer": "C"
  },
  {
    "id": "topic6_8",
    "question": "What is the correct interpretation of the dot `.` in the declaration `noninterf [⟨typedecl⟩;] seq⟨nidecl⟩.`?",
    "options": {
      "A": "It is a placeholder for an omitted part of the rule.",
      "B": "It marks the end of the declaration.",
      "C": "It represents a decimal point in numeric literals.",
      "D": "It is used to separate clauses within a function definition."
    },
    "answer": "B"
  },
  {
    "id": "topic6_9",
    "question": "Based on the grammar, which of the following delimiters is used to denote nested comments?",
    "options": {
      "A": "`{ }`",
      "B": "`( )`",
      "C": "`(* *)`",
      "D": "`[ ]`"
    },
    "answer": "C"
  },
  {
    "id": "topic6_10",
    "question": "Why are delimiters like parentheses and brackets important in defining the structure of grammar rules?",
    "options": {
      "A": "They have no real impact on the structure or meaning of the grammar.",
      "B": "They allow for ambiguity by permitting multiple interpretations of the same rule.",
      "C": "They enforce strict operator precedence and clarify grouping of elements.",
      "D": "They are only used for visual formatting and can be removed safely."
    },
    "answer": "C"
  },
  {
    "id": "topic7_1",
    "question": "Which of the following correctly describes how comments are written in ProVerif?",
    "options": {
      "A": "Comments begin with `//` and continue to the end of the line.",
      "B": "Comments are enclosed within `(* ... *)`.",
      "C": "Comments start with `#` and end with `#`.",
      "D": "Comments are not supported in ProVerif."
    },
    "answer": "B"
  },
  {
    "id": "topic7_2",
    "question": "What is the role of whitespace (spaces, tabs, and newlines) in ProVerif code?",
    "options": {
      "A": "Whitespace must be used to separate all keywords and identifiers.",
      "B": "Whitespace has no syntactic meaning and is generally ignored by the parser.",
      "C": "Whitespace affects the semantics of processes and must be carefully managed.",
      "D": "Whitespace can only be used between function names and their arguments."
    },
    "answer": "B"
  },
  {
    "id": "topic7_3",
    "question": "How does ProVerif treat newline characters when parsing code?",
    "options": {
      "A": "Newlines are treated as mandatory statement terminators.",
      "B": "Newlines are used to denote comments unless escaped.",
      "C": "Newlines are treated as whitespace and are mostly insignificant.",
      "D": "Newlines cause a syntax error if not placed after each process declaration."
    },
    "answer": "C"
  },
  {
    "id": "topic7_4",
    "question": "In ProVerif, which of the following is NOT a valid way to include a comment?",
    "options": {
      "A": "`(* This is a comment *)`",
      "B": "`(* Nested comments are (* not *) allowed *)`",
      "C": "`(* Single-line comment *)`",
      "D": "`(* Multi-line"
    },
    "answer": "B"
  },
  {
    "id": "topic7_5",
    "question": "What happens to spaces and tabs inside a term or expression in ProVerif?",
    "options": {
      "A": "They must be used to separate all elements of a term.",
      "B": "They are required only between keywords and identifiers.",
      "C": "They are optional and do not affect the parsing of terms.",
      "D": "They cause a syntax error if used within a function application."
    },
    "answer": "C"
  },
  {
    "id": "topic7_6",
    "question": "Which of the following is a correct use of whitespace in a ProVerif process definition?",
    "options": {
      "A": "`newa;P` (no space between `new` and `a`)",
      "B": "`out( N , M ) ; P` (spaces around commas and semicolon)",
      "C": "`in(N,x);P` (no spaces)",
      "D": "Both B and C"
    },
    "answer": "D"
  },
  {
    "id": "topic7_7",
    "question": "How does ProVerif handle nested comments?",
    "options": {
      "A": "It supports unlimited nesting of comments using `(* ... *)`.",
      "B": "It allows one level of nesting but ignores deeper ones.",
      "C": "It does not support nested comments and will generate an error.",
      "D": "Nested comments are allowed only in function definitions."
    },
    "answer": "C"
  },
  {
    "id": "topic7_8",
    "question": "What is the purpose of allowing arbitrary whitespace in most parts of ProVerif code?",
    "options": {
      "A": "To enforce strict formatting rules",
      "B": "To make the language easier for beginners",
      "C": "To allow developers flexibility in code layout",
      "D": "To prevent syntax errors caused by missing spaces"
    },
    "answer": "C"
  },
  {
    "id": "topic7_9",
    "question": "Which of the following would result in a syntax error in ProVerif due to improper handling of comments?",
    "options": {
      "A": "`(* A simple comment *)`",
      "B": "`(* Comment without closing`",
      "C": "`(* First comment *) (* Second comment *)`",
      "D": "`let x = (* assignment with comment *) 5`"
    },
    "answer": "B"
  },
  {
    "id": "topic7_10",
    "question": "Can you use whitespace between the symbols that form part of a keyword in ProVerif (e.g., `in`, `new`)?",
    "options": {
      "A": "Yes, all keywords allow internal whitespace.",
      "B": "No, inserting whitespace within a keyword causes a syntax error.",
      "C": "Only some keywords like `not` and `or` allow internal whitespace.",
      "D": "Whitespace within keywords is allowed only in let expressions."
    },
    "answer": "B"
  },
  {
    "id": "topic8_1",
    "question": "In ProVerif, how must all free names appearing in an input file be declared?",
    "options": {
      "A": "They can be used without any declaration.",
      "B": "Using the syntax `type n : t`.",
      "C": "Using the syntax `free n : t`.",
      "D": "By assigning them directly within a process expression."
    },
    "answer": "C"
  },
  {
    "id": "topic8_2",
    "question": "What is the correct way to declare a constant of type `t` in ProVerif?",
    "options": {
      "A": "`fun c() : t.`",
      "B": "`const c : t.`",
      "C": "`let c = t.`",
      "D": "`c : t.`"
    },
    "answer": "B"
  },
  {
    "id": "topic8_3",
    "question": "Which of the following best describes the role of variables in ProVerif?",
    "options": {
      "A": "Variables represent atomic data such as keys or nonces and cannot be substituted.",
      "B": "Variables can be substituted by terms during execution.",
      "C": "Variables are only used for defining types and not for computation.",
      "D": "Variables are always global and cannot be bound locally."
    },
    "answer": "B"
  },
  {
    "id": "topic8_4",
    "question": "How are user-defined types introduced in ProVerif?",
    "options": {
      "A": "With the keyword `typedef`.",
      "B": "With the keyword `type`, followed by the type name.",
      "C": "By using built-in types like `bitstring`.",
      "D": "Automatically when declaring functions."
    },
    "answer": "B"
  },
  {
    "id": "topic8_5",
    "question": "What is the purpose of function symbols in ProVerif?",
    "options": {
      "A": "To define processes that perform network communication.",
      "B": "To serve as constructors or destructors for data manipulation.",
      "C": "To restrict the use of built-in types like `bool`.",
      "D": "To generate random values like nonces or keys."
    },
    "answer": "B"
  },
  {
    "id": "topic8_6",
    "question": "What does the syntax `h(T1, ..., Tn) : T` indicate about a function symbol `h`?",
    "options": {
      "A": "It indicates that `h` is a variable with no arguments.",
      "B": "It specifies that `h` takes `n` arguments of types `T1` through `Tn` and returns a value of type `T`.",
      "C": "It defines `h` as a constant of type `T`.",
      "D": "It declares `h` as a channel used for message passing."
    },
    "answer": "B"
  },
  {
    "id": "topic8_7",
    "question": "Which identifiers typically represent names in ProVerif?",
    "options": {
      "A": "x, y, z",
      "B": "f, g, h",
      "C": "a, b, c, k",
      "D": "i, j, n"
    },
    "answer": "C"
  },
  {
    "id": "topic8_8",
    "question": "What is the significance of the `const` declaration compared to defining a constant using `fun`?",
    "options": {
      "A": "There is no difference; both are equivalent.",
      "B": "`const` allows the constant to be redefined later.",
      "C": "`const` is a specific construct for constants, while `fun c() : t` defines a nullary function.",
      "D": "`fun` is the preferred method for declaring constants."
    },
    "answer": "C"
  },
  {
    "id": "topic8_9",
    "question": "Which of the following is a built-in type in ProVerif?",
    "options": {
      "A": "`string`",
      "B": "`int`",
      "C": "`bitstring`",
      "D": "`list`"
    },
    "answer": "C"
  },
  {
    "id": "topic8_10",
    "question": "What is the main purpose of declarations in ProVerif?",
    "options": {
      "A": "To execute protocol simulations directly.",
      "B": "To define types, constants, functions, and other constructs before they are used in processes.",
      "C": "To optimize the runtime performance of cryptographic protocols.",
      "D": "To provide comments for better code readability."
    },
    "answer": "B"
  },
  {
    "id": "topic9_1",
    "question": "In the formalism described, what is the role of a destructor function symbol like `g`?",
    "options": {
      "A": "It constructs new terms from existing ones.",
      "B": "It only appears in process definitions.",
      "C": "It manipulates terms using rewrite rules to produce other terms.",
      "D": "It represents atomic data such as keys or nonces."
    },
    "answer": "C"
  },
  {
    "id": "topic9_2",
    "question": "Which of the following correctly describes how names (`a`, `b`, `c`, etc.) are treated in this formalism?",
    "options": {
      "A": "They can be substituted by other terms during execution.",
      "B": "They represent variables that change over time.",
      "C": "They must always be declared with their type before use.",
      "D": "They are not part of the typed language."
    },
    "answer": "C"
  },
  {
    "id": "topic9_3",
    "question": "What is the correct way to declare a free name `n` of type `t` in this formalism?",
    "options": {
      "A": "`name n : t.`",
      "B": "`free n : t.`",
      "C": "`var n : t.`",
      "D": "`decl n : t.`"
    },
    "answer": "B"
  },
  {
    "id": "topic9_4",
    "question": "How are destructors defined when using the extended method introduced in Section 4.2.1?",
    "options": {
      "A": "Using a single `fun` declaration without conditions.",
      "B": "By declaring them as constants of arity zero.",
      "C": "Through an ordered list of rewrite rules using `reduc`.",
      "D": "By assigning them directly to a constructor function."
    },
    "answer": "C"
  },
  {
    "id": "topic9_5",
    "question": "What is the purpose of the syntax `h(T1, ..., Tn) : T` for function symbols?",
    "options": {
      "A": "It defines a variable substitution rule.",
      "B": "It specifies the types of inputs and output for the function `h`.",
      "C": "It declares a set of rewrite rules for a destructor.",
      "D": "It creates a new atomic name."
    },
    "answer": "B"
  },
  {
    "id": "topic9_6",
    "question": "Which of the following best describes the difference between constructors and destructors in this formalism?",
    "options": {
      "A": "Constructors manipulate terms using rewrite rules, while destructors build terms.",
      "B": "Both can appear anywhere in processes, but destructors are faster.",
      "C": "Constructors build terms, while destructors break them down using rules.",
      "D": "There is no functional difference; both refer to the same class of functions."
    },
    "answer": "C"
  },
  {
    "id": "topic9_7",
    "question": "In ProVerif, how can a constant `c` of type `t` be declared?",
    "options": {
      "A": "`fun c() : t.`",
      "B": "`const c : t.`",
      "C": "Either `fun c() : t.` or `const c : t.`",
      "D": "Constants cannot be declared in ProVerif."
    },
    "answer": "C"
  },
  {
    "id": "topic9_8",
    "question": "What happens if none of the rewrite rules for a destructor apply to a given term?",
    "options": {
      "A": "The process terminates successfully.",
      "B": "The destructor returns a default value of zero.",
      "C": "The destructor fails and may lead to process failure.",
      "D": "The system automatically generates a new rule."
    },
    "answer": "C"
  },
  {
    "id": "topic9_9",
    "question": "Which of the following is a built-in destructor in ProVerif?",
    "options": {
      "A": "`tuple`",
      "B": "`true`",
      "C": "`not`",
      "D": "`fun`"
    },
    "answer": "C"
  },
  {
    "id": "topic9_10",
    "question": "Why are equations introduced in the context of destructors and cryptographic primitives?",
    "options": {
      "A": "To simplify variable declarations.",
      "B": "To allow modular exponentiation and other complex operations not expressible via rewrite rules alone.",
      "C": "To replace all rewrite rules with simpler expressions.",
      "D": "To optimize performance of basic protocols."
    },
    "answer": "B"
  },
  {
    "id": "topic10_1",
    "question": "In the context of ProVerif expressions, what does the symbol `fail` represent?",
    "options": {
      "A": "A successful computation that returns a boolean value.",
      "B": "A special constant indicating that a computation has failed.",
      "C": "A variable that can be assigned any term during evaluation.",
      "D": "An operator used for conditional branching in expressions."
    },
    "answer": "B"
  },
  {
    "id": "topic10_2",
    "question": "Which of the following best describes a \"ground\" expression in this formalism?",
    "options": {
      "A": "An expression that includes at least one variable.",
      "B": "An expression that evaluates only to a constructor function.",
      "C": "An expression that contains no variables and is fully evaluated.",
      "D": "An expression that must be wrapped in a conditional statement."
    },
    "answer": "C"
  },
  {
    "id": "topic10_3",
    "question": "What distinguishes destructors from constructors in the syntax of expressions?",
    "options": {
      "A": "Destructors always return new names, while constructors do not.",
      "B": "Constructors build data structures, while destructors break them down or extract values.",
      "C": "Destructors are only used in conditional statements, unlike constructors.",
      "D": "Constructors can fail during evaluation, but destructors cannot."
    },
    "answer": "B"
  },
  {
    "id": "topic10_4",
    "question": "Which of the following is a valid form of an enriched term in ProVerif?",
    "options": {
      "A": "`new x; if x then fail else y`",
      "B": "`f(new a; g(a), h(x))`",
      "C": "`tupleT1,T2(fail, x)`",
      "D": "All of the above"
    },
    "answer": "D"
  },
  {
    "id": "topic10_5",
    "question": "In the expression `let x = D in P else Q`, what happens if the evaluation of `D` results in `fail`?",
    "options": {
      "A": "The process `P` is executed.",
      "B": "The process `Q` is executed.",
      "C": "The entire expression is ignored.",
      "D": "A runtime error is raised."
    },
    "answer": "B"
  },
  {
    "id": "topic10_6",
    "question": "What is the purpose of rewrite rules like `g(U1,...,Un) → U` in defining destructors?",
    "options": {
      "A": "To define how to create new names during execution.",
      "B": "To specify how a destructor processes input terms and produces output.",
      "C": "To restrict the use of conditionals within expressions.",
      "D": "To ensure all expressions evaluate to `fail`."
    },
    "answer": "B"
  },
  {
    "id": "topic10_7",
    "question": "Which of the following represents a correctly formed tuple constructor according to the formalism?",
    "options": {
      "A": "`tupleT1,...,Tn(M1,...,Mn)` where each `Mi` is a name",
      "B": "`tupleT1,...,Tn(fail, x)`",
      "C": "`tupleT1,...,Tn(true, false, 5)`",
      "D": "All of the above"
    },
    "answer": "D"
  },
  {
    "id": "topic10_8",
    "question": "How is the evaluation of a ground expression `D` defined in this formalism?",
    "options": {
      "A": "By reducing it to another expression using type inference.",
      "B": "By rewriting it repeatedly until it evaluates to a value `V`.",
      "C": "By checking its syntactic structure without executing it.",
      "D": "By comparing it directly to a known set of constants."
    },
    "answer": "B"
  },
  {
    "id": "topic10_9",
    "question": "In the context of expressions, what role do destructors play when evaluating terms?",
    "options": {
      "A": "They are used exclusively to declare new names.",
      "B": "They allow processes to manipulate terms by extracting or transforming components.",
      "C": "They enforce that all expressions must terminate successfully.",
      "D": "They prevent the use of tuples in cryptographic operations."
    },
    "answer": "B"
  },
  {
    "id": "topic10_10",
    "question": "Which of the following is",
    "options": {
      "A": "Constructor function symbols",
      "B": "Destructor function symbols",
      "C": "Logical operators such as `&&`, `||`, and `not`",
      "D": "Variables bound by `let` expressions"
    },
    "answer": "C"
  },
  {
    "id": "topic11_1",
    "question": "Which of the following best describes the purpose of the `out(M, N); P` construct in ProVerif?",
    "options": {
      "A": "It receives a message from a channel and continues as process P.",
      "B": "It sends a term N on channel M and then continues as process P.",
      "C": "It evaluates the equality of terms M and N before proceeding.",
      "D": "It restricts the scope of a new name used in P."
    },
    "answer": "B"
  },
  {
    "id": "topic11_2",
    "question": "What is the function of the `0` (nil) process in ProVerif's process calculus?",
    "options": {
      "A": "It represents a process that infinitely replicates itself.",
      "B": "It acts as a placeholder for undefined behavior.",
      "C": "It does nothing and terminates immediately.",
      "D": "It waits indefinitely for input on a channel."
    },
    "answer": "C"
  },
  {
    "id": "topic11_3",
    "question": "How is conditional execution represented in ProVerif's process language?",
    "options": {
      "A": "`let x = M in P else Q`",
      "B": "`new x : T; if M then P`",
      "C": "`if M then P else Q`",
      "D": "`phase 1; when M do P`"
    },
    "answer": "C"
  },
  {
    "id": "topic11_4",
    "question": "Which of the following constructs allows a process to receive a message on a channel in ProVerif?",
    "options": {
      "A": "`out(M, N); P`",
      "B": "`in(M, x: t); P`",
      "C": "`event(e(x)); P`",
      "D": "`begin(x); P`"
    },
    "answer": "B"
  },
  {
    "id": "topic11_5",
    "question": "What does the replication operator `!P` signify in ProVerif?",
    "options": {
      "A": "The process P will run exactly once.",
      "B": "The process P can be executed multiple times in parallel.",
      "C": "The process P must terminate within a bounded time.",
      "D": "The process P runs only if a certain condition holds."
    },
    "answer": "B"
  },
  {
    "id": "topic11_6",
    "question": "In ProVerif, what is the primary use of the `new n : t; P` construct?",
    "options": {
      "A": "To declare a global constant of type t.",
      "B": "To create a fresh name with restricted scope for use in P.",
      "C": "To evaluate an expression involving names or variables.",
      "D": "To define a function that returns a value of type t."
    },
    "answer": "B"
  },
  {
    "id": "topic11_7",
    "question": "Which of the following best describes how control flow is managed in ProVerif processes?",
    "options": {
      "A": "Control flow is strictly linear with no branching or looping.",
      "B": "Control flow is managed using constructs like `if-then-else`, replication, and phases.",
      "C": "Control flow is determined entirely by external inputs and cannot be modeled internally.",
      "D": "Control flow is modeled exclusively through cryptographic primitives."
    },
    "answer": "B"
  },
  {
    "id": "topic11_8",
    "question": "What is the role of the `phase n; P` construct in ProVerif?",
    "options": {
      "A": "It delays the execution of P until after all other processes have completed.",
      "B": "It ensures that P is executed in phase n and discards any processes not reaching this phase.",
      "C": "It replicates P n times during execution.",
      "D": "It binds a variable n to the process P for future reference."
    },
    "answer": "B"
  },
  {
    "id": "topic11_9",
    "question": "Which of the following constructs is used to compose two processes so that they execute concurrently in ProVerif?",
    "options": {
      "A": "`P -> Q`",
      "B": "`P | Q`",
      "C": "`P + Q`",
      "D": "`P ; Q`"
    },
    "answer": "B"
  },
  {
    "id": "topic11_10",
    "question": "What happens when a process reaches an `event(e(M1,...,Mn)); P` statement in ProVerif?",
    "options": {
      "A": "The process halts permanently.",
      "B": "The event is recorded for verification purposes, and the process continues as P.",
      "C": "The process is replicated n times.",
      "D": "The process enters a new phase and restarts."
    },
    "answer": "B"
  },
  {
    "id": "topic12_1",
    "question": "In ProVerif, what is the purpose of defining a process macro using the `let` syntax?",
    "options": {
      "A": "To permanently replace all variables with constants",
      "B": "To define cryptographic primitives used in the protocol",
      "C": "To simplify development by encapsulating sub-processes",
      "D": "To enforce type checking across different phases"
    },
    "answer": "C"
  },
  {
    "id": "topic12_2",
    "question": "Which of the following correctly represents the structure of a process macro definition in ProVerif?",
    "options": {
      "A": "`let R = P(x1 : t1, ..., xn : tn)`",
      "B": "`let R(x1 : t1, ..., xn : tn) = P`",
      "C": "`def R(P) as let(x1,...,xn)`",
      "D": "`macro R(x1, ..., xn) { P }`"
    },
    "answer": "B"
  },
  {
    "id": "topic12_3",
    "question": "When a process macro like `R(M1, ..., Mn)` is expanded in ProVerif, what happens to the variables `x1, ..., xn` defined in its declaration?",
    "options": {
      "A": "They are discarded after expansion",
      "B": "They are automatically assigned global scope",
      "C": "They are replaced by the corresponding arguments M1, ..., Mn",
      "D": "They are converted into cryptographic keys"
    },
    "answer": "C"
  },
  {
    "id": "topic12_4",
    "question": "Why are macros considered useful but not essential in ProVerif models?",
    "options": {
      "A": "Because they only serve as comments and do not affect execution",
      "B": "Because they can be omitted and manually expanded in the main process",
      "C": "Because they are only applicable to symmetric cryptography",
      "D": "Because they cannot be used inside replication constructs"
    },
    "answer": "B"
  },
  {
    "id": "topic12_5",
    "question": "How does the `phase` construct function in ProVerif when modeling multi-phase protocols?",
    "options": {
      "A": "It defines new cryptographic types for each phase",
      "B": "It restricts variable visibility between phases",
      "C": "It acts as a synchronization barrier that controls process execution order",
      "D": "It prevents macros from being reused across phases"
    },
    "answer": "C"
  },
  {
    "id": "topic12_6",
    "question": "What is required before using any free name in a ProVerif input file?",
    "options": {
      "A": "It must be encrypted using a block cipher",
      "B": "It must be declared with its type using the `free` keyword",
      "C": "It must be associated with a destructor",
      "D": "It must be replicated using the `!` operator"
    },
    "answer": "B"
  },
  {
    "id": "topic12_7",
    "question": "In ProVerif, what effect does the use of the `def` block have when defining security assumptions on primitives?",
    "options": {
      "A": "It creates a new type for each invocation",
      "B": "It allows macros to be defined with local declarations",
      "C": "It limits the scope of a macro to a single phase",
      "D": "It enforces strict message ordering between processes"
    },
    "answer": "B"
  },
  {
    "id": "topic12_8",
    "question": "What does the phrase \"strongly typed\" imply in the context of ProVerif’s language?",
    "options": {
      "A": "Variables can change types during execution",
      "B": "All names and variables must have a declared type",
      "C": "Type declarations are optional but recommended",
      "D": "Types are inferred automatically without user input"
    },
    "answer": "B"
  },
  {
    "id": "topic12_9",
    "question": "After macro expansion, how does ProVerif treat the resulting process?",
    "options": {
      "A": "It treats it differently from manually written processes",
      "B": "It merges all processes into a single phase",
      "C": "It assigns unique identifiers to expanded components",
      "D": "It discards unused macros silently"
    },
    "answer": "C"
  },
  {
    "id": "topic12_10",
    "question": "Based on the material, which of the following best describes the role of process macros in protocol modeling?",
    "options": {
      "A": "They are solely used for documentation purposes",
      "B": "They help organize complex processes into manageable and reusable components",
      "C": "They are deprecated in newer versions of ProVerif",
      "D": "They are only used for defining public keys"
    },
    "answer": "B"
  },
  {
    "id": "topic13_1",
    "question": "In the given formalism, what must be done before using a variable or a name in a process declaration?",
    "options": {
      "A": "It can be used without prior declaration.",
      "B": "It must be declared with its type before use.",
      "C": "It must be declared only if used in a conditional statement.",
      "D": "Declaration is optional for free names."
    },
    "answer": "B"
  },
  {
    "id": "topic13_2",
    "question": "According to the scope determination rules, when is a name modeled without arguments?",
    "options": {
      "A": "When it appears inside an `if-then-else` construct.",
      "B": "When it is part of a function definition.",
      "C": "When it is not in the scope of any variables.",
      "D": "When it is globally quantified."
    },
    "answer": "C"
  },
  {
    "id": "topic13_3",
    "question": "What does it mean when a variable is said to be \"in the scope\" of another variable?",
    "options": {
      "A": "It is defined after the other variable in the code.",
      "B": "Its value depends on the value of the other variable at runtime.",
      "C": "It has the same name as the other variable.",
      "D": "It is always declared globally."
    },
    "answer": "B"
  },
  {
    "id": "topic13_4",
    "question": "Why might a restriction need to be annotated with variables?",
    "options": {
      "A": "To allow substitution of constructors.",
      "B": "To indicate which variables influence the internal representation of fresh names.",
      "C": "To optimize the compilation process.",
      "D": "To simplify the syntax of the language."
    },
    "answer": "B"
  },
  {
    "id": "topic13_5",
    "question": "Which of the following best describes identifier uniqueness in this formalism?",
    "options": {
      "A": "Names and variables can share the same identifier freely.",
      "B": "All identifiers must be globally unique across the entire system.",
      "C": "Distinct naming of names and variables is recommended to avoid confusion.",
      "D": "Identifiers can be reused in different scopes without conflict."
    },
    "answer": "C"
  },
  {
    "id": "topic13_6",
    "question": "In what situation can the `forall x1 : t1, ..., xn : tn;` prefix be omitted in a clause?",
    "options": {
      "A": "When all variables are declared globally.",
      "B": "When the clause contains no function symbols.",
      "C": "When F1, ..., Fm, F contain no variables.",
      "D": "When the types are inferred automatically."
    },
    "answer": "C"
  },
  {
    "id": "topic13_7",
    "question": "What is the significance of annotating an input with `[precise]` in ProVerif?",
    "options": {
      "A": "It disables all optimizations during verification.",
      "B": "It ensures that the input is interpreted exactly once.",
      "C": "It allows the omission of else branches in conditionals.",
      "D": "It tells ProVerif to consider the input as precisely as possible."
    },
    "answer": "D"
  },
  {
    "id": "topic13_8",
    "question": "How are new names represented when they are created within the scope of variables?",
    "options": {
      "A": "As atomic values without any additional information.",
      "B": "With a list of substitutions corresponding to the current values of the scoped variables.",
      "C": "Using infix operators like `||` or `&&`.",
      "D": "By defaulting to a global session identifier."
    },
    "answer": "B"
  },
  {
    "id": "topic13_9",
    "question": "Which of the following is NOT allowed as an identifier in noninterference declarations?",
    "options": {
      "A": "Function symbols",
      "B": "Predicates",
      "C": "Names",
      "D": "Variables"
    },
    "answer": "C"
  },
  {
    "id": "topic13_10",
    "question": "What kind of ambiguity can arise from omitting the `else 0` clause in conditional expressions?",
    "options": {
      "A": "Confusion about which `if` the `else` applies to.",
      "B": "Incorrect type inference for variables.",
      "C": "Errors in quantifier scoping.",
      "D": "Failure to compile the process into ProVerif format."
    },
    "answer": "A"
  },
  {
    "id": "topic14_1",
    "question": "In ProVerif, what is a requirement for a destructor function symbol when used in a pattern-matching context?",
    "options": {
      "A": "It must be defined without any rewrite rules.",
      "B": "It must always return a boolean value.",
      "C": "It must only appear within conditional expressions like `if M = N`.",
      "D": "It must be applied to terms that do not contain constructor symbols."
    },
    "answer": "C"
  },
  {
    "id": "topic14_2",
    "question": "What is a key condition for using a function symbol as a data constructor in pattern-matching?",
    "options": {
      "A": "The function must have no associated destructors.",
      "B": "The function must be declared with a single rewrite rule.",
      "C": "The function must be accompanied by destructors that extract its arguments.",
      "D": "The function must return a built-in type such as `bool` or `int`."
    },
    "answer": "C"
  },
  {
    "id": "topic14_3",
    "question": "When matching a pattern of the form `f(pat1, ..., patn)` in ProVerif, what must be true about the function `f`?",
    "options": {
      "A": "It must be a destructor function.",
      "B": "It must be a public function.",
      "C": "It must be a data constructor.",
      "D": "It must be a conditional expression."
    },
    "answer": "C"
  },
  {
    "id": "topic14_4",
    "question": "What happens if a destructor function is applied to a term for which none of its rewrite rules are applicable?",
    "options": {
      "A": "The term evaluates to zero.",
      "B": "The pattern-matching succeeds silently.",
      "C": "The destructor fails and the pattern-matching fails accordingly.",
      "D": "The system automatically applies a default rewrite rule."
    },
    "answer": "C"
  },
  {
    "id": "topic14_5",
    "question": "For a destructor `g` with arity `k`, what must be consistent across all rewrite rules defining it?",
    "options": {
      "A": "The number of variables used in each rule.",
      "B": "The types of its arguments across all rules.",
      "C": "The return type of the destructor in each rule.",
      "D": "Both B and C."
    },
    "answer": "D"
  },
  {
    "id": "topic14_6",
    "question": "Which of the following best describes a \"simple\" pattern in the context of ProVerif’s pattern-matching semantics?",
    "options": {
      "A": "A pattern containing only built-in constants like `true` or `false`.",
      "B": "A pattern where all occurrences of `=D` involve a may-fail constructor term `U`.",
      "C": "A pattern that does not include any destructors.",
      "D": "A pattern that uses only one variable binding."
    },
    "answer": "B"
  },
  {
    "id": "topic14_7",
    "question": "What is a necessary condition for a let-binding like `let x = M in P else Q` to succeed when `M` contains destructors?",
    "options": {
      "A": "`M` must be a constructor-only term.",
      "B": "All destructors in `M` must evaluate successfully.",
      "C": "`Q` must be the null process.",
      "D": "`x` must be of a base type like `int` or `bool`."
    },
    "answer": "B"
  },
  {
    "id": "topic14_8",
    "question": "Why must a type converter function produce a value different from values obtained without applying the same converter?",
    "options": {
      "A": "To allow polymorphic behavior.",
      "B": "To ensure termination of evaluation.",
      "C": "To uniquely identify which type conversion was applied during pattern-matching.",
      "D": "To simplify the syntax of constructor applications."
    },
    "answer": "C"
  },
  {
    "id": "topic14_9",
    "question": "In ProVerif, what must be true about the use of the equality destructor `equal(M, N)` outside of conditional expressions?",
    "options": {
      "A": "It can be used freely in any term.",
      "B": "It must be enclosed in a tuple.",
      "C": "It must be part of a function macro definition.",
      "D": "It cannot occur outside of conditional expressions."
    },
    "answer": "D"
  },
  {
    "id": "topic14_10",
    "question": "Which of the following is NOT allowed when using enriched terms in ProVerif with equations?",
    "options": {
      "A": "Declaring all function symbols as public.",
      "B": "Using the expression evaluation construct.",
      "C": "Writing conditionals of the form `if M = N`.",
      "D": "Using equations to define destructors."
    },
    "answer": "B"
  },
  {
    "id": "topic15_1",
    "question": "In the context of ProVerif, what does a query like `query attacker(M)` aim to verify?",
    "options": {
      "A": "Whether the process terminates successfully.",
      "B": "Whether the term M can be reconstructed or obtained by an attacker.",
      "C": "Whether the protocol is type-safe.",
      "D": "Whether two processes are equivalent under observation."
    },
    "answer": "B"
  },
  {
    "id": "topic15_2",
    "question": "Which of the following best describes the concept of \"syntactic secrecy\" in the symbolic (Dolev-Yao) model?",
    "options": {
      "A": "The secrecy of a message based on computational hardness assumptions.",
      "B": "The inability of an attacker to syntactically derive a specific term from available knowledge.",
      "C": "The encryption strength of a symmetric key algorithm.",
      "D": "The runtime complexity of an attacker's ability to guess a secret."
    },
    "answer": "B"
  },
  {
    "id": "topic15_3",
    "question": "What is the main purpose of using reachability analysis in security verification tools like ProVerif?",
    "options": {
      "A": "To determine if a system will always terminate.",
      "B": "To evaluate whether certain terms can be reached or constructed by an adversary.",
      "C": "To compute the number of messages exchanged in a protocol.",
      "D": "To simulate network latency and packet loss."
    },
    "answer": "B"
  },
  {
    "id": "topic15_4",
    "question": "In the symbolic model used by ProVerif, how are cryptographic primitives typically represented?",
    "options": {
      "A": "As probabilistic functions with real-world implementation details.",
      "B": "As perfect black boxes modeled by function symbols in a formal term algebra.",
      "C": "As simplified versions of their real-world counterparts with limited functionality.",
      "D": "As hardware modules that cannot be analyzed directly."
    },
    "answer": "B"
  },
  {
    "id": "topic15_5",
    "question": "What does it mean for a process to preserve \"strong secrecy\" of a term M in ProVerif?",
    "options": {
      "A": "The term M must never be sent over the network.",
      "B": "The adversary cannot distinguish between two versions of the protocol using different values of M.",
      "C": "The term M must be encrypted at all times.",
      "D": "The term M must be hashed before being used in any computation."
    },
    "answer": "B"
  },
  {
    "id": "topic15_6",
    "question": "Which of the following best defines the role of an adversary in the symbolic model?",
    "options": {
      "A": "A passive observer who only eavesdrops on communications.",
      "B": "An entity that can intercept, modify, and inject messages but can only compute using available cryptographic primitives.",
      "C": "An all-powerful entity capable of breaking any encryption scheme.",
      "D": "A trusted third party responsible for message routing."
    },
    "answer": "B"
  },
  {
    "id": "topic15_7",
    "question": "Why are destructors not allowed in the term M when using the query `query attacker(M)` in ProVerif?",
    "options": {
      "A": "Because M must represent a final output rather than an intermediate step.",
      "B": "Because M must be a ground term that the tool can fully analyze without needing to break it down further.",
      "C": "Because destructors are computationally expensive and slow down the verification.",
      "D": "Because destructors imply that the term has already been compromised."
    },
    "answer": "B"
  },
  {
    "id": "topic15_8",
    "question": "Which of the following statements correctly reflects the relationship between secrecy and reachability in ProVerif?",
    "options": {
      "A": "Reachability is irrelevant to secrecy; they are separate concerns.",
      "B": "Secrecy can be verified by checking whether a secret term is reachable by the attacker.",
      "C": "Secrecy ensures that all terms are unreachable by the attacker.",
      "D": "Reachability guarantees that all secrets are exposed."
    },
    "answer": "B"
  },
  {
    "id": "topic15_9",
    "question": "What is the significance of including free names in the term M when testing secrecy in ProVerif?",
    "options": {
      "A": "Free names make the term more complex and harder to encrypt.",
      "B": "Free names allow the representation of private or secret values that might be leaked to the adversary.",
      "C": "Free names are automatically ignored during analysis.",
      "D": "Free names ensure that the term is public by default."
    },
    "answer": "B"
  },
  {
    "id": "topic15_10",
    "question": "According to the theoretical foundations discussed, which of the following is NOT a primary focus of ProVerif’s verification capabilities?",
    "options": {
      "A": "Verifying secrecy of terms",
      "B": "Checking correspondence assertions",
      "C": "Proving computational indistinguishability",
      "D": "Analyzing equivalence of processes"
    },
    "answer": "C"
  },
  {
    "id": "topic16_1",
    "question": "What is the primary purpose of using correspondence assertions in the context of authentication verification?",
    "options": {
      "A": "To ensure that messages are encrypted properly during protocol execution.",
      "B": "To verify that specific events occur in a certain order or relationship during the protocol.",
      "C": "To count the number of sessions executed by the protocol.",
      "D": "To simulate network attacks on the protocol."
    },
    "answer": "B"
  },
  {
    "id": "topic16_2",
    "question": "Which of the following best describes how ProVerif verifies authentication properties?",
    "options": {
      "A": "By simulating each session manually and checking for errors.",
      "B": "By translating protocols into Horn clauses and using resolution to check derivability queries.",
      "C": "By executing the protocol in real-world conditions and monitoring behavior.",
      "D": "By comparing the protocol to known insecure protocols."
    },
    "answer": "B"
  },
  {
    "id": "topic16_3",
    "question": "In the context of protocol verification, what does an unbounded number of sessions mean?",
    "options": {
      "A": "The protocol can only be executed once.",
      "B": "The analysis assumes the protocol may be run any number of times concurrently.",
      "C": "The protocol must be terminated after a fixed number of executions.",
      "D": "Each session must be identical to the previous one."
    },
    "answer": "B"
  },
  {
    "id": "topic16_4",
    "question": "Why are observational equivalence properties important in protocol verification?",
    "options": {
      "A": "They allow the protocol to be visualized graphically.",
      "B": "They ensure that two processes behave identically from an external observer's perspective.",
      "C": "They limit the number of cryptographic primitives used.",
      "D": "They increase the speed of protocol execution."
    },
    "answer": "B"
  },
  {
    "id": "topic16_5",
    "question": "What is the main advantage of computational soundness results in protocol verification?",
    "options": {
      "A": "They allow symbolic model proofs to imply security in the computational model under certain conditions.",
      "B": "They reduce the number of variables used in the protocol.",
      "C": "They eliminate the need for correspondence assertions.",
      "D": "They simplify the user interface of verification tools."
    },
    "answer": "A"
  },
  {
    "id": "topic16_6",
    "question": "Which tool automatically translates protocols into Horn clauses for verification?",
    "options": {
      "A": "Tamarin",
      "B": "ProVerif",
      "C": "Isabelle",
      "D": "IPSec"
    },
    "answer": "B"
  },
  {
    "id": "topic16_7",
    "question": "What does it mean when a correspondence assertion states: \"If event e₁ has occurred, then event e₂ must have occurred or will occur\"?",
    "options": {
      "A": "It ensures that both events happen simultaneously.",
      "B": "It establishes a causal or temporal dependency between the two events.",
      "C": "It guarantees that e₂ happens before e₁.",
      "D": "It proves that e₁ and e₂ are mutually exclusive."
    },
    "answer": "B"
  },
  {
    "id": "topic16_8",
    "question": "Which of the following is",
    "options": {
      "A": "Verifying secrecy properties",
      "B": "Proving observational equivalence",
      "C": "Automatically reconstructing attacks",
      "D": "Guaranteeing hardware-level performance"
    },
    "answer": "D"
  },
  {
    "id": "topic16_9",
    "question": "How does Tamarin differ from ProVerif in its approach to proving security properties?",
    "options": {
      "A": "Tamarin only supports symmetric encryption, while ProVerif supports asymmetric encryption.",
      "B": "Tamarin requires more user guidance (e.g., lemmas), while ProVerif is more fully automatic.",
      "C": "Tamarin cannot handle unbounded message spaces.",
      "D": "Tamarin is limited to bounded session analysis."
    },
    "answer": "B"
  },
  {
    "id": "topic16_10",
    "question": "Which of the following best defines a subterm convergent equational theory in the context of protocol verification?",
    "options": {
      "A": "A method to visualize protocol steps",
      "B": "A way to define cryptographic primitives with rewrite rules that terminate and are confluent",
      "C": "A technique for limiting the size of messages",
      "D": "An algorithm for encrypting data faster"
    },
    "answer": "B"
  },
  {
    "id": "topic1_1",
    "question": "What is the input language of ProVerif based on?",
    "options": {
      "A": "Pi calculus with cryptography",
      "B": "Applied pi calculus with equational theories",
      "C": "Horn clauses with derivability queries",
      "D": "Resolution with selection"
    },
    "answer": "B"
  },
  {
    "id": "topic1_2",
    "question": "What is the main difference between ProVerif's calculus and the applied pi calculus?",
    "options": {
      "A": "ProVerif uses equational theories, while applied pi calculus uses destructors.",
      "B": "ProVerif uses destructors, while applied pi calculus uses equational theories.",
      "C": "ProVerif supports all equational theories, while applied pi calculus does not.",
      "D": "ProVerif does not support error-handling, while applied pi calculus does."
    },
    "answer": "B"
  },
  {
    "id": "topic1_3",
    "question": "What is the purpose of the else branch in ProVerif's expression evaluation?",
    "options": {
      "A": "To handle errors in the protocol",
      "B": "To verify security properties",
      "C": "To model cryptographic primitives",
      "D": "To define function symbols"
    },
    "answer": "A"
  },
  {
    "id": "topic1_4",
    "question": "What type of properties can ProVerif verify?",
    "options": {
      "A": "Only secrecy properties",
      "B": "Only authentication properties",
      "C": "Various security properties, including secrecy and authentication",
      "D": "Only observational equivalence properties"
    },
    "answer": "C"
  },
  {
    "id": "topic1_5",
    "question": "How does ProVerif handle equations?",
    "options": {
      "A": "Using equational theories",
      "B": "Using destructors",
      "C": "Using rewrite rules",
      "D": "Using Horn clauses"
    },
    "answer": "B"
  },
  {
    "id": "topic1_6",
    "question": "What is the relationship between ProVerif's calculus and the applied pi calculus?",
    "options": {
      "A": "They are identical",
      "B": "ProVerif's calculus is an extension of the applied pi calculus",
      "C": "The applied pi calculus is an extension of ProVerif's calculus",
      "D": "They are unrelated"
    },
    "answer": "B"
  },
  {
    "id": "topic1_7",
    "question": "What is the purpose of the automatic translator in ProVerif?",
    "options": {
      "A": "To translate the protocol specification into Horn clauses",
      "B": "To translate the security properties into pi calculus",
      "C": "To translate the pi calculus into applied pi calculus",
      "D": "To translate the applied pi calculus into ProVerif's calculus"
    },
    "answer": "A"
  },
  {
    "id": "topic1_8",
    "question": "What happens when ProVerif finds a potential attack?",
    "options": {
      "A": "It stops the verification process",
      "B": "It reconstructs the attack at the Horn clause level",
      "C": "It ignores the attack and continues verification",
      "D": "It reports a false attack"
    },
    "answer": "B"
  },
  {
    "id": "topic1_9",
    "question": "What is the structure of ProVerif's input language?",
    "options": {
      "A": "Pi calculus with cryptography and security properties",
      "B": "Applied pi calculus with equational theories and security properties",
      "C": "Horn clauses with derivability queries and security properties",
      "D": "Resolution with selection and security properties"
    },
    "answer": "A"
  },
  {
    "id": "topic1_10",
    "question": "What is the purpose of substitutions in ProVerif's calculus?",
    "options": {
      "A": "To map variables to expressions",
      "B": "To map names to terms",
      "C": "To substitute fail or may-fail variables for ordinary variables",
      "D": "To define function symbols"
    },
    "answer": "A"
  },
  {
    "id": "topic2_1",
    "question": "What is the primary goal of ProVerif?",
    "options": {
      "A": "To verify the correctness of cryptographic algorithms",
      "B": "To verify the security of cryptographic protocols",
      "C": "To analyze the performance of network protocols",
      "D": "To design new cryptographic protocols"
    },
    "answer": "B"
  },
  {
    "id": "topic2_2",
    "question": "Which of the following protocols has been verified using ProVerif?",
    "options": {
      "A": "Only TLS",
      "B": "Only Signal",
      "C": "Both TLS and Signal, among others",
      "D": "Neither TLS nor Signal"
    },
    "answer": "C"
  },
  {
    "id": "topic2_3",
    "question": "What is the abstract representation of protocols used by ProVerif?",
    "options": {
      "A": "Tree-automata",
      "B": "Horn clauses",
      "C": "Finite state machines",
      "D": "Petri nets"
    },
    "answer": "B"
  },
  {
    "id": "topic2_4",
    "question": "What type of properties can ProVerif prove?",
    "options": {
      "A": "Only secrecy properties",
      "B": "Only authentication properties",
      "C": "Both secrecy and authentication properties, among others",
      "D": "Only reachability properties"
    },
    "answer": "C"
  },
  {
    "id": "topic2_5",
    "question": "How does ProVerif represent security properties to be proven?",
    "options": {
      "A": "As Horn clauses",
      "B": "As derivability queries on Horn clauses",
      "C": "As logical formulas",
      "D": "As algebraic equations"
    },
    "answer": "B"
  },
  {
    "id": "topic2_6",
    "question": "What is the algorithm used by ProVerif to prove security properties?",
    "options": {
      "A": "Resolution with selection",
      "B": "Model checking",
      "C": "Theorem proving",
      "D": "Constraint solving"
    },
    "answer": "A"
  },
  {
    "id": "topic2_7",
    "question": "Can ProVerif handle an unbounded number of sessions and message space?",
    "options": {
      "A": "Yes",
      "B": "No",
      "C": "Only for specific protocols",
      "D": "Only for small-scale systems"
    },
    "answer": "A"
  },
  {
    "id": "topic2_8",
    "question": "What is the input to ProVerif?",
    "options": {
      "A": "A model of the protocol in pi calculus with cryptography",
      "B": "A specification of the protocol in a formal language",
      "C": "A runnable implementation of the protocol",
      "D": "A set of security properties to be proven"
    },
    "answer": "A"
  },
  {
    "id": "topic2_9",
    "question": "How does ProVerif support cryptographic primitives?",
    "options": {
      "A": "By predefined functions",
      "B": "By rewrite rules or equations",
      "C": "By built-in algorithms",
      "D": "By external libraries"
    },
    "answer": "B"
  },
  {
    "id": "topic2_10",
    "question": "What is one of the applications of ProVerif mentioned in the text?",
    "options": {
      "A": "Verifying voting protocols",
      "B": "Analyzing network performance",
      "C": "Designing new cryptographic algorithms",
      "D": "Testing software implementations"
    },
    "answer": "A"
  },
  {
    "id": "topic3_1",
    "question": "What is the purpose of declaring names and variables with their types in the given formalism?",
    "options": {
      "A": "To specify the length of the identifiers",
      "B": "To reserve keywords for special use",
      "C": "To define the scope of the variables",
      "D": "To specify the data type of the variables and names"
    },
    "answer": "D"
  },
  {
    "id": "topic3_2",
    "question": "Which of the following is a valid first character for an identifier in the given formalism?",
    "options": {
      "A": "A digit (0-9)",
      "B": "An underscore (_)",
      "C": "A letter (a-z, A-Z)",
      "D": "A special character (!, @, #, etc.)"
    },
    "answer": "C"
  },
  {
    "id": "topic3_3",
    "question": "What is the convention for naming identifiers in the given formalism?",
    "options": {
      "A": "Identifiers can be any sequence of characters",
      "B": "Identifiers must start with a letter and can contain letters, digits, and underscores",
      "C": "Identifiers must be a single character",
      "D": "Identifiers can only contain letters"
    },
    "answer": "B"
  },
  {
    "id": "topic3_4",
    "question": "Which of the following is a reserved word in the ProVerif language?",
    "options": {
      "A": "let",
      "B": "if",
      "C": "then",
      "D": "all of the above"
    },
    "answer": "D"
  },
  {
    "id": "topic3_5",
    "question": "What is the purpose of the \"new\" keyword in the given formalism?",
    "options": {
      "A": "To declare a new variable",
      "B": "To restrict the scope of a name",
      "C": "To define a new function",
      "D": "To specify a new type"
    },
    "answer": "B"
  },
  {
    "id": "topic3_6",
    "question": "Which of the following types is a built-in type in the ProVerif language?",
    "options": {
      "A": "nat",
      "B": "bool",
      "C": "sid",
      "D": "all of the above"
    },
    "answer": "D"
  },
  {
    "id": "topic3_7",
    "question": "What is the purpose of the \"let\" keyword in the given formalism?",
    "options": {
      "A": "To declare a new variable",
      "B": "To assign a value to a variable",
      "C": "To define a new function",
      "D": "To specify a new type"
    },
    "answer": "B"
  },
  {
    "id": "topic3_8",
    "question": "Which of the following is a valid way to specify the type of a variable in the given formalism?",
    "options": {
      "A": "x : nat",
      "B": "x nat",
      "C": "nat x",
      "D": "x = nat"
    },
    "answer": "A"
  },
  {
    "id": "topic3_9",
    "question": "What is the purpose of the \"noninterf\" declaration in the given formalism?",
    "options": {
      "A": "To specify a new type",
      "B": "To declare a new variable",
      "C": "To restrict the scope of a name",
      "D": "To define a new function"
    },
    "answer": "C"
  },
  {
    "id": "topic3_10",
    "question": "Which of the following is a valid way to specify a fact in the given formalism?",
    "options": {
      "A": "p(M1,..., Mk)",
      "B": "p(M1,..., Mk) = true",
      "C": "p(M1,..., Mk) = false",
      "D": "p(M1,..., Mk) :- true"
    },
    "answer": "A"
  },
  {
    "id": "topic4_1",
    "question": "What is the purpose of the ⟨ident⟩ non-terminal in the given formalism?",
    "options": {
      "A": "To denote natural numbers.",
      "B": "To denote identifiers, which can be letters, digits, underscores, single-quotes, and accented letters.",
      "C": "To denote types, which can be identifiers or the reserved word channel.",
      "D": "To denote terms, which can be identifiers, function applications, or tuples."
    },
    "answer": "B"
  },
  {
    "id": "topic4_2",
    "question": "What is the difference between ⟨nat⟩ and ⟨int⟩ in the given formalism?",
    "options": {
      "A": "⟨nat⟩ ranges over natural numbers, while ⟨int⟩ ranges over integer numbers, including negative numbers.",
      "B": "⟨nat⟩ ranges over integer numbers, while ⟨int⟩ ranges over natural numbers.",
      "C": "⟨nat⟩ and ⟨int⟩ are interchangeable and have the same meaning.",
      "D": "⟨nat⟩ is used for identifiers, while ⟨int⟩ is used for types."
    },
    "answer": "A"
  },
  {
    "id": "topic4_3",
    "question": "What is the purpose of the ⟨typeid⟩ non-terminal in the given formalism?",
    "options": {
      "A": "To denote identifiers, which can be letters, digits, underscores, single-quotes, and accented letters.",
      "B": "To denote types, which can be identifiers or the reserved word channel.",
      "C": "To denote terms, which can be identifiers, function applications, or tuples.",
      "D": "To denote natural numbers."
    },
    "answer": "B"
  },
  {
    "id": "topic4_4",
    "question": "What is the meaning of the syntax \"seq+⟨ident⟩\" in the given formalism?",
    "options": {
      "A": "A sequence of one or more identifiers separated by commas.",
      "B": "A sequence of zero or more identifiers separated by commas.",
      "C": "A single identifier.",
      "D": "A type declaration."
    },
    "answer": "A"
  },
  {
    "id": "topic4_5",
    "question": "What is the purpose of the ⟨gterm⟩ non-terminal in the given formalism?",
    "options": {
      "A": "To denote general terms, which can be identifiers, function applications, or tuples.",
      "B": "To denote types, which can be identifiers or the reserved word channel.",
      "C": "To denote natural numbers.",
      "D": "To denote identifiers, which can be letters, digits, underscores, single-quotes, and accented letters."
    },
    "answer": "A"
  },
  {
    "id": "topic4_6",
    "question": "What is the meaning of the syntax \"inj-event(seq⟨gterm⟩) [@⟨ident⟩]\" in the given formalism?",
    "options": {
      "A": "An injective event with a sequence of general terms and an optional identifier.",
      "B": "A non-injective event with a sequence of general terms and an optional identifier.",
      "C": "A type declaration with a sequence of general terms and an optional identifier.",
      "D": "A function application with a sequence of general terms and an optional identifier."
    },
    "answer": "A"
  },
  {
    "id": "topic4_7",
    "question": "What is the purpose of the ⟨lemma⟩ non-terminal in the given formalism?",
    "options": {
      "A": "To denote lemmas, which can be general terms or tuples of general terms.",
      "B": "To denote types, which can be identifiers or the reserved word channel.",
      "C": "To denote natural numbers.",
      "D": "To denote identifiers, which can be letters, digits, underscores, single-quotes, and accented letters."
    },
    "answer": "A"
  },
  {
    "id": "topic4_8",
    "question": "What is the meaning of the syntax \"⟨ident⟩(seq⟨gterm⟩) [phase ⟨nat⟩] [@⟨ident⟩]\" in the given formalism?",
    "options": {
      "A": "A function application with a sequence of general terms, an optional phase, and an optional identifier.",
      "B": "A type declaration with a sequence of general terms, an optional phase, and an optional identifier.",
      "C": "A general term with a sequence of general terms, an optional phase, and an optional identifier.",
      "D": "An event with a sequence of general terms, an optional phase, and an optional identifier."
    },
    "answer": "A"
  },
  {
    "id": "topic4_9",
    "question": "What is the purpose of the ⟨pattern⟩ non-terminal in the given formalism?",
    "options": {
      "A": "To denote patterns, which can be identifiers, natural numbers, or tuples of patterns.",
      "B": "To denote types, which can be identifiers or the reserved word channel.",
      "C": "To denote natural numbers.",
      "D": "To denote identifiers, which can be letters, digits, underscores, single-quotes, and accented letters."
    },
    "answer": "A"
  },
  {
    "id": "topic4_10",
    "question": "What is the meaning of the syntax \"get ⟨ident⟩(seq⟨pattern⟩) [suchthat ⟨pterm⟩] ⟨options⟩ in ⟨pterm⟩ [else ⟨pterm⟩]\" in the given formalism?",
    "options": {
      "A": "A get operation with a sequence of patterns, an optional suchthat clause, and an optional else clause.",
      "B": "A type declaration with a sequence of patterns, an optional suchthat clause, and an optional else clause.",
      "C": "A general term with a sequence of patterns, an optional suchthat clause, and an optional else clause.",
      "D": "An event with a sequence of patterns, an optional suchthat clause, and an optional else clause."
    },
    "answer": "A"
  },
  {
    "id": "topic5_1",
    "question": "What is the purpose of the \"new\" operator in ProVerif?",
    "options": {
      "A": "To declare a new variable",
      "B": "To create a fresh name",
      "C": "To define a new function symbol",
      "D": "To specify a new destructor"
    },
    "answer": "B"
  },
  {
    "id": "topic5_2",
    "question": "Which operator is used to represent term equality in ProVerif?",
    "options": {
      "A": "=",
      "B": "<>",
      "C": "&&",
      "D": "||"
    },
    "answer": "A"
  },
  {
    "id": "topic5_3",
    "question": "What is the effect of the \"set movenew = true\" option in ProVerif?",
    "options": {
      "A": "It disables the creation of fresh names",
      "B": "It enables the creation of fresh names with adjusted arguments",
      "C": "It has no effect on the analysis",
      "D": "It changes the semantics of the processes"
    },
    "answer": "B"
  },
  {
    "id": "topic5_4",
    "question": "Which of the following is NOT a reserved word in ProVerif?",
    "options": {
      "A": "among",
      "B": "def",
      "C": "let",
      "D": "example"
    },
    "answer": "D"
  },
  {
    "id": "topic5_5",
    "question": "What is the purpose of the \"elimtrue\" operator in ProVerif?",
    "options": {
      "A": "To eliminate true values from a term",
      "B": "To eliminate false values from a term",
      "C": "To simplify a term by removing unnecessary operators",
      "D": "To check if a term is true"
    },
    "answer": "A"
  },
  {
    "id": "topic5_6",
    "question": "How are fresh names represented internally in ProVerif?",
    "options": {
      "A": "As variables",
      "B": "As functions of variables bound above the new",
      "C": "As constants",
      "D": "As destructors"
    },
    "answer": "B"
  },
  {
    "id": "topic5_7",
    "question": "What is the effect of the \"set allowDiffPatterns = false\" option in ProVerif?",
    "options": {
      "A": "It enables the use of patterns with diff or choice",
      "B": "It disables the use of patterns with diff or choice",
      "C": "It has no effect on the analysis",
      "D": "It changes the semantics of the processes"
    },
    "answer": "B"
  },
  {
    "id": "topic5_8",
    "question": "Which operator is used to represent term disequality in ProVerif?",
    "options": {
      "A": "=",
      "B": "<>",
      "C": "&&",
      "D": "||"
    },
    "answer": "B"
  },
  {
    "id": "topic5_9",
    "question": "What is the purpose of the \"if\" operator in ProVerif?",
    "options": {
      "A": "To declare a new variable",
      "B": "To create a fresh name",
      "C": "To specify a conditional statement",
      "D": "To define a new function symbol"
    },
    "answer": "C"
  },
  {
    "id": "topic5_10",
    "question": "How can the precision of the analysis be fine-tuned in ProVerif?",
    "options": {
      "A": "By adjusting the arguments of patterns that represent names",
      "B": "By changing the semantics of the processes",
      "C": "By disabling the creation of fresh names",
      "D": "By enabling the use of patterns with diff or choice"
    },
    "answer": "A"
  },
  {
    "id": "topic6_1",
    "question": "What is the purpose of the `⟨ident⟩` non-terminal in the given formalism?",
    "options": {
      "A": "To denote natural numbers.",
      "B": "To denote identifiers, which range over an unlimited sequence of letters, digits, underscores, single-quotes, and accented letters.",
      "C": "To denote types, which can be identifiers or the reserved word channel.",
      "D": "To denote integer numbers."
    },
    "answer": "B"
  },
  {
    "id": "topic6_2",
    "question": "What is the syntax for declaring a variable or a name with its type?",
    "options": {
      "A": "`let ⟨ident⟩ = ⟨gterm⟩ in ⟨gterm⟩`",
      "B": "`⟨ident⟩ : ⟨typeid⟩`",
      "C": "`new ⟨ident⟩[[[⟨gbinding⟩]]]`",
      "D": "`⟨ident⟩ ==> ⟨gterm⟩`"
    },
    "answer": "B"
  },
  {
    "id": "topic6_3",
    "question": "What is the purpose of the `⟨nat⟩` non-terminal in the given formalism?",
    "options": {
      "A": "To denote identifiers.",
      "B": "To denote natural numbers.",
      "C": "To denote types.",
      "D": "To denote integer numbers."
    },
    "answer": "B"
  },
  {
    "id": "topic6_4",
    "question": "What is the syntax for declaring a function symbol with its type?",
    "options": {
      "A": "`h(T1,...,Tn) : T`",
      "B": "`⟨ident⟩ : ⟨typeid⟩`",
      "C": "`new ⟨ident⟩[[[⟨gbinding⟩]]]`",
      "D": "`⟨ident⟩ ==> ⟨gterm⟩`"
    },
    "answer": "A"
  },
  {
    "id": "topic6_5",
    "question": "What is the purpose of the `⟨typeid⟩` non-terminal in the given formalism?",
    "options": {
      "A": "To denote identifiers.",
      "B": "To denote natural numbers.",
      "C": "To denote types, which can be identifiers or the reserved word channel.",
      "D": "To denote integer numbers."
    },
    "answer": "C"
  },
  {
    "id": "topic6_6",
    "question": "What is the syntax for declaring a destructor with its type?",
    "options": {
      "A": "`g(T1,...,Tn) : T`",
      "B": "`⟨ident⟩ : ⟨typeid⟩`",
      "C": "`new ⟨ident⟩[[[⟨gbinding⟩]]]`",
      "D": "`⟨ident⟩ ==> ⟨gterm⟩`"
    },
    "answer": "A"
  },
  {
    "id": "topic6_7",
    "question": "What is the purpose of the `⟨options⟩` non-terminal in the given formalism?",
    "options": {
      "A": "To denote identifiers.",
      "B": "To denote natural numbers.",
      "C": "To denote a sequence of identifiers, where the allowed identifiers are data, private, and topic.",
      "D": "To denote integer numbers."
    },
    "answer": "C"
  },
  {
    "id": "topic6_8",
    "question": "What is the syntax for declaring a lemma?",
    "options": {
      "A": "`lemma ⟨ident⟩ : ⟨typeid⟩`",
      "B": "`⟨ident⟩ : ⟨typeid⟩`",
      "C": "`new ⟨ident⟩[[[⟨gbinding⟩]]]`",
      "D": "`⟨ident⟩ ==> ⟨gterm⟩`"
    },
    "answer": "A"
  },
  {
    "id": "topic6_9",
    "question": "What is the purpose of the `⟨gterm⟩` non-terminal in the given formalism?",
    "options": {
      "A": "To denote identifiers.",
      "B": "To denote natural numbers.",
      "C": "To denote a general term, which can be a variable, a name, or a function symbol applied to arguments.",
      "D": "To denote integer numbers."
    },
    "answer": "C"
  },
  {
    "id": "topic6_10",
    "question": "What is the syntax for declaring a nounif option?",
    "options": {
      "A": "`⟨ident⟩ [among (seq+⟨term⟩)]`",
      "B": "`⟨ident⟩ : ⟨typeid⟩`",
      "C": "`new ⟨ident⟩[[[⟨gbinding⟩]]]`",
      "D": "`⟨ident⟩ ==> ⟨gterm⟩`"
    },
    "answer": "A"
  },
  {
    "id": "topic7_1",
    "question": "What is the purpose of the \"new\" keyword in ProVerif?",
    "options": {
      "A": "To declare a new variable or name.",
      "B": "To restrict the scope of a name.",
      "C": "To create a new process.",
      "D": "To define a new function."
    },
    "answer": "B"
  },
  {
    "id": "topic7_2",
    "question": "Which of the following is NOT a reserved word in ProVerif?",
    "options": {
      "A": "among",
      "B": "choice",
      "C": "clauses",
      "D": "protocol"
    },
    "answer": "D"
  },
  {
    "id": "topic7_3",
    "question": "What is the syntax for comments in ProVerif?",
    "options": {
      "A": "// comment",
      "B": "/* comment */",
      "C": "# comment",
      "D": "Not specified in the provided content."
    },
    "answer": "D"
  },
  {
    "id": "topic7_4",
    "question": "What is the role of spaces, tabs, and newline characters in ProVerif?",
    "options": {
      "A": "They are used to separate keywords and identifiers.",
      "B": "They are used to indicate the end of a statement.",
      "C": "They are ignored by the compiler.",
      "D": "They are used to define the scope of a process."
    },
    "answer": "A"
  },
  {
    "id": "topic7_5",
    "question": "What is the purpose of the \"let\" keyword in ProVerif?",
    "options": {
      "A": "To declare a new variable or name.",
      "B": "To assign a value to a variable.",
      "C": "To create a new process.",
      "D": "To define a new function."
    },
    "answer": "B"
  },
  {
    "id": "topic7_6",
    "question": "Which of the following is a type of term in ProVerif?",
    "options": {
      "A": "channel",
      "B": "bool",
      "C": "bitstring",
      "D": "All of the above."
    },
    "answer": "D"
  },
  {
    "id": "topic7_7",
    "question": "What is the purpose of the \"event\" keyword in ProVerif?",
    "options": {
      "A": "To declare a new event.",
      "B": "To trigger an event.",
      "C": "To define a new function.",
      "D": "To create a new process."
    },
    "answer": "B"
  },
  {
    "id": "topic7_8",
    "question": "How does ProVerif represent fresh names internally?",
    "options": {
      "A": "As functions of the variables bound above the new.",
      "B": "As strings.",
      "C": "As integers.",
      "D": "As booleans."
    },
    "answer": "A"
  },
  {
    "id": "topic7_9",
    "question": "What is the purpose of the \"set movenew\" command in ProVerif?",
    "options": {
      "A": "To adjust the precision of the analysis.",
      "B": "To enable or disable the automatic movement of new names.",
      "C": "To define a new function.",
      "D": "To create a new process."
    },
    "answer": "A"
  },
  {
    "id": "topic7_10",
    "question": "What is the purpose of the \"out\" keyword in ProVerif?",
    "options": {
      "A": "To declare a new output channel.",
      "B": "To send a message on a channel.",
      "C": "To create a new process.",
      "D": "To define a new function."
    },
    "answer": "B"
  },
  {
    "id": "topic8_1",
    "question": "What is the purpose of the \"const\" construct in ProVerif?",
    "options": {
      "A": "To declare a function with arity 0.",
      "B": "To declare a constant with a specific type.",
      "C": "To declare a variable with a specific type.",
      "D": "To declare a function with a specific return type."
    },
    "answer": "B"
  },
  {
    "id": "topic8_2",
    "question": "What is the role of names in the ProVerif language?",
    "options": {
      "A": "They represent complex data structures.",
      "B": "They represent atomic data, such as keys and nonces.",
      "C": "They represent function symbols.",
      "D": "They represent process declarations."
    },
    "answer": "B"
  },
  {
    "id": "topic8_3",
    "question": "What is the purpose of the \"type\" declaration in ProVerif?",
    "options": {
      "A": "To declare a function with a specific return type.",
      "B": "To declare a constant with a specific type.",
      "C": "To declare a user-defined type.",
      "D": "To declare a variable with a specific type."
    },
    "answer": "C"
  },
  {
    "id": "topic8_4",
    "question": "What is the purpose of the \"free\" declaration in ProVerif?",
    "options": {
      "A": "To declare a function with a specific return type.",
      "B": "To declare a constant with a specific type.",
      "C": "To declare a free name with a specific type.",
      "D": "To declare a variable with a specific type."
    },
    "answer": "C"
  },
  {
    "id": "topic8_5",
    "question": "What is the role of function symbols in the ProVerif language?",
    "options": {
      "A": "They represent atomic data, such as keys and nonces.",
      "B": "They represent complex data structures.",
      "C": "They represent constructors and destructors.",
      "D": "They represent process declarations."
    },
    "answer": "C"
  },
  {
    "id": "topic8_6",
    "question": "What is the purpose of the \"fun\" declaration in ProVerif?",
    "options": {
      "A": "To declare a constant with a specific type.",
      "B": "To declare a function with a specific return type.",
      "C": "To declare a function with arity 0.",
      "D": "To declare a variable with a specific type."
    },
    "answer": "B"
  },
  {
    "id": "topic8_7",
    "question": "What is the role of variables in the ProVerif language?",
    "options": {
      "A": "They represent atomic data, such as keys and nonces.",
      "B": "They represent complex data structures.",
      "C": "They can be substituted by terms.",
      "D": "They represent process declarations."
    },
    "answer": "C"
  },
  {
    "id": "topic8_8",
    "question": "What is the purpose of the \"letfun\" declaration in ProVerif?",
    "options": {
      "A": "To declare a function with a specific return type.",
      "B": "To declare a constant with a specific type.",
      "C": "To declare a function with arity 0.",
      "D": "To define a function in terms of other functions."
    },
    "answer": "D"
  },
  {
    "id": "topic8_9",
    "question": "What is the role of the \"reduc\" declaration in ProVerif?",
    "options": {
      "A": "To declare a function with a specific return type.",
      "B": "To declare a constant with a specific type.",
      "C": "To define a reduction rule for a function.",
      "D": "To declare a variable with a specific type."
    },
    "answer": "C"
  },
  {
    "id": "topic8_10",
    "question": "What is the purpose of the \"equivalence\" query in ProVerif?",
    "options": {
      "A": "To check if two processes are syntactically equivalent.",
      "B": "To check if two processes are semantically equivalent.",
      "C": "To declare a function with a specific return type.",
      "D": "To declare a constant with a specific type."
    },
    "answer": "B"
  },
  {
    "id": "topic9_1",
    "question": "What is the purpose of declaring a type in the given formalism?",
    "options": {
      "A": "To define a new destructor",
      "B": "To declare a variable or a name with its type",
      "C": "To define a new constructor",
      "D": "To declare a function symbol"
    },
    "answer": "B"
  },
  {
    "id": "topic9_2",
    "question": "How are destructors defined in the given formalism?",
    "options": {
      "A": "Using a single rewrite rule",
      "B": "Using an ordered list of rewrite rules",
      "C": "Using a set of equations",
      "D": "Using a conditional statement"
    },
    "answer": "B"
  },
  {
    "id": "topic9_3",
    "question": "What is the role of the \"reduc\" declaration in the given formalism?",
    "options": {
      "A": "To declare a new constructor",
      "B": "To define a new destructor",
      "C": "To declare a function symbol",
      "D": "To define a set of equations"
    },
    "answer": "B"
  },
  {
    "id": "topic9_4",
    "question": "What is the difference between a constructor and a destructor in the given formalism?",
    "options": {
      "A": "A constructor is used to build terms, while a destructor is used to manipulate terms",
      "B": "A constructor is used to manipulate terms, while a destructor is used to build terms",
      "C": "A constructor is used to declare variables, while a destructor is used to declare names",
      "D": "A constructor is used to define equations, while a destructor is used to define rewrite rules"
    },
    "answer": "A"
  },
  {
    "id": "topic9_5",
    "question": "How are constants defined in the given formalism?",
    "options": {
      "A": "Using the \"const\" declaration",
      "B": "Using the \"fun\" declaration with arity 0",
      "C": "Using the \"reduc\" declaration",
      "D": "Using the \"type\" declaration"
    },
    "answer": "A"
  },
  {
    "id": "topic9_6",
    "question": "What is the purpose of the \"forall\" keyword in the given formalism?",
    "options": {
      "A": "To declare a new variable",
      "B": "To define a new destructor",
      "C": "To declare a function symbol",
      "D": "To define a set of equations"
    },
    "answer": "B"
  },
  {
    "id": "topic9_7",
    "question": "How are function symbols declared in the given formalism?",
    "options": {
      "A": "Using the \"fun\" declaration",
      "B": "Using the \"reduc\" declaration",
      "C": "Using the \"const\" declaration",
      "D": "Using the \"type\" declaration"
    },
    "answer": "A"
  },
  {
    "id": "topic9_8",
    "question": "What is the role of the \"free\" declaration in the given formalism?",
    "options": {
      "A": "To declare a new variable",
      "B": "To declare a new name",
      "C": "To declare a function symbol",
      "D": "To define a set of equations"
    },
    "answer": "B"
  },
  {
    "id": "topic9_9",
    "question": "How are terms built in the given formalism?",
    "options": {
      "A": "Using constructors and variables",
      "B": "Using destructors and names",
      "C": "Using function symbols and constants",
      "D": "Using equations and rewrite rules"
    },
    "answer": "A"
  },
  {
    "id": "topic9_10",
    "question": "What is the purpose of the \"def\" keyword in the given formalism?",
    "options": {
      "A": "To declare a new variable",
      "B": "To define a new destructor",
      "C": "To declare a function symbol",
      "D": "To define a set of equations"
    },
    "answer": "B"
  },
  {
    "id": "topic10_1",
    "question": "What is the purpose of the evaluation relation D⇓V in the given formalism?",
    "options": {
      "A": "To define the syntax of expressions",
      "B": "To specify the semantics of expressions by evaluating them to values",
      "C": "To declare variables and names",
      "D": "To define the structure of processes"
    },
    "answer": "B"
  },
  {
    "id": "topic10_2",
    "question": "What is a value V in the given formalism?",
    "options": {
      "A": "A term containing variables",
      "B": "A ground term or the constant fail",
      "C": "A process declaration",
      "D": "A conditional statement"
    },
    "answer": "B"
  },
  {
    "id": "topic10_3",
    "question": "How is a ground expression D evaluated in the given formalism?",
    "options": {
      "A": "By rewriting it until a value V is obtained",
      "B": "By declaring its variables and names",
      "C": "By applying constructors and destructors",
      "D": "By using it in a process declaration"
    },
    "answer": "A"
  },
  {
    "id": "topic10_4",
    "question": "What is the purpose of the let x: T = D in D′else D′′ expression evaluation construct?",
    "options": {
      "A": "To declare a variable x of type T",
      "B": "To evaluate an expression D and assign its value to x",
      "C": "To specify a conditional statement",
      "D": "To define a function application"
    },
    "answer": "B"
  },
  {
    "id": "topic10_5",
    "question": "What is the difference between a constructor and a destructor in the given formalism?",
    "options": {
      "A": "A constructor is used to define a function application, while a destructor is used to define a process declaration",
      "B": "A constructor is used to build data structures, while a destructor is used to manipulate terms in expressions",
      "C": "A constructor is used to declare variables, while a destructor is used to declare names",
      "D": "A constructor is used to specify a conditional statement, while a destructor is used to specify a loop"
    },
    "answer": "B"
  },
  {
    "id": "topic10_6",
    "question": "How is a term if M then N else N′ evaluated in the given formalism?",
    "options": {
      "A": "It is evaluated to N if M is equal to true, and to N′ otherwise",
      "B": "It is evaluated to N if M is not equal to true, and to N′ otherwise",
      "C": "It is evaluated to fail if M fails, or if the else branch is omitted and M is not equal to true",
      "D": "It is evaluated to true if M is equal to true, and to false otherwise"
    },
    "answer": "C"
  },
  {
    "id": "topic10_7",
    "question": "What is the purpose of the new a: T; M construct in the given formalism?",
    "options": {
      "A": "To declare a variable a of type T",
      "B": "To construct a new name a of type T and evaluate the enriched term M",
      "C": "To specify a conditional statement",
      "D": "To define a function application"
    },
    "answer": "B"
  },
  {
    "id": "topic10_8",
    "question": "What is the result of evaluating an expression g(D1,...,Dn) if no rewrite rule applies?",
    "options": {
      "A": "The expression is evaluated to a value V",
      "B": "The expression is evaluated to the constant fail",
      "C": "The expression is evaluated to a constructor application",
      "D": "The expression is evaluated to a destructor application"
    },
    "answer": "B"
  },
  {
    "id": "topic10_9",
    "question": "How are constructors and destructors used in the given formalism?",
    "options": {
      "A": "To represent data structures and cryptographic operations",
      "B": "To declare variables and names",
      "C": "To specify conditional statements",
      "D": "To define function applications"
    },
    "answer": "A"
  },
  {
    "id": "topic10_10",
    "question": "What is the purpose of the pattern-matching construct in(D,pat); P in the given formalism?",
    "options": {
      "A": "To declare a variable pat of type T",
      "B": "To evaluate an expression D and assign its value to pat",
      "C": "To specify a conditional statement",
      "D": "To enrich the input and expression evaluation constructs with pattern-matching"
    },
    "answer": "D"
  },
  {
    "id": "topic11_1",
    "question": "What is the purpose of the \"phase\" construct in ProVerif?",
    "options": {
      "A": "To declare a new variable or name.",
      "B": "To introduce a global synchronization point in the process execution.",
      "C": "To specify a conditional statement.",
      "D": "To define a new event."
    },
    "answer": "B"
  },
  {
    "id": "topic11_2",
    "question": "Which of the following is NOT a valid process construct in ProVerif?",
    "options": {
      "A": "if M then P else Q",
      "B": "in(M, x: t); P",
      "C": "out(M, N); P",
      "D": "loop(P)"
    },
    "answer": "D"
  },
  {
    "id": "topic11_3",
    "question": "What is the effect of the \"new\" construct in ProVerif?",
    "options": {
      "A": "It introduces a new variable or name with a given type.",
      "B": "It restricts the scope of a name or variable.",
      "C": "It defines a new event.",
      "D": "It specifies a conditional statement."
    },
    "answer": "B"
  },
  {
    "id": "topic11_4",
    "question": "What is the purpose of the \"event\" construct in ProVerif?",
    "options": {
      "A": "To declare a new variable or name.",
      "B": "To specify a conditional statement.",
      "C": "To record that a certain program point has been reached.",
      "D": "To define a new process."
    },
    "answer": "C"
  },
  {
    "id": "topic11_5",
    "question": "Which of the following process constructs is used to input a message on a channel?",
    "options": {
      "A": "out(M, N); P",
      "B": "in(M, x: t); P",
      "C": "if M then P else Q",
      "D": "new n : t; P"
    },
    "answer": "B"
  },
  {
    "id": "topic11_6",
    "question": "What is the effect of the \"let\" construct in ProVerif?",
    "options": {
      "A": "It introduces a new variable or name with a given type.",
      "B": "It assigns a value to a variable.",
      "C": "It specifies a conditional statement.",
      "D": "It defines a new event."
    },
    "answer": "B"
  },
  {
    "id": "topic11_7",
    "question": "Which of the following process constructs is used to specify a conditional statement?",
    "options": {
      "A": "if M then P else Q",
      "B": "in(M, x: t); P",
      "C": "out(M, N); P",
      "D": "new n : t; P"
    },
    "answer": "A"
  },
  {
    "id": "topic11_8",
    "question": "What is the purpose of the \"begin\" and \"end\" constructs in ProVerif?",
    "options": {
      "A": "To declare a new variable or name.",
      "B": "To specify a conditional statement.",
      "C": "To record that a certain program point has been reached.",
      "D": "To prove security properties of the form \"if a certain end event has been executed, then certain begin events have been executed\"."
    },
    "answer": "D"
  },
  {
    "id": "topic11_9",
    "question": "Which of the following process constructs is used to output a message on a channel?",
    "options": {
      "A": "in(M, x: t); P",
      "B": "out(M, N); P",
      "C": "if M then P else Q",
      "D": "new n : t; P"
    },
    "answer": "B"
  },
  {
    "id": "topic11_10",
    "question": "What is the effect of the \"!\" construct in ProVerif?",
    "options": {
      "A": "It introduces a new variable or name with a given type.",
      "B": "It restricts the scope of a name or variable.",
      "C": "It specifies a conditional statement.",
      "D": "It replicates a process."
    },
    "answer": "D"
  },
  {
    "id": "topic12_1",
    "question": "What is the purpose of process macros in ProVerif?",
    "options": {
      "A": "To define new cryptographic primitives.",
      "B": "To facilitate development by allowing sub-processes to be defined.",
      "C": "To specify the security assumptions on primitives.",
      "D": "To declare free names and variables."
    },
    "answer": "B"
  },
  {
    "id": "topic12_2",
    "question": "How are process macros defined in ProVerif?",
    "options": {
      "A": "Using the syntax `let R(x1 : t1,..., xn : tn) = P`.",
      "B": "Using the syntax `def R(x1 : t1,..., xn : tn) { P }`.",
      "C": "Using the syntax `process R(x1 : t1,..., xn : tn) = P`.",
      "D": "Using the syntax `macro R(x1 : t1,..., xn : tn) = P`."
    },
    "answer": "A"
  },
  {
    "id": "topic12_3",
    "question": "What is the effect of expanding a process macro in ProVerif?",
    "options": {
      "A": "It creates a new process with the same name.",
      "B": "It replaces the macro with its definition in the main process.",
      "C": "It declares new free names and variables.",
      "D": "It defines a new cryptographic primitive."
    },
    "answer": "B"
  },
  {
    "id": "topic12_4",
    "question": "What is the purpose of the `phase` construct in ProVerif?",
    "options": {
      "A": "To define new cryptographic primitives.",
      "B": "To specify the security assumptions on primitives.",
      "C": "To model different phases of a protocol.",
      "D": "To declare free names and variables."
    },
    "answer": "C"
  },
  {
    "id": "topic12_5",
    "question": "How do phases work in ProVerif?",
    "options": {
      "A": "All processes run in parallel and phases are ignored.",
      "B": "Processes that did not reach a phase construct are discarded.",
      "C": "Phases are used to define new cryptographic primitives.",
      "D": "Phases are used to specify the security assumptions on primitives."
    },
    "answer": "B"
  },
  {
    "id": "topic12_6",
    "question": "What is the purpose of the `def` keyword in ProVerif?",
    "options": {
      "A": "To define new cryptographic primitives.",
      "B": "To specify the security assumptions on primitives.",
      "C": "To define a macro for security assumptions on primitives.",
      "D": "To declare free names and variables."
    },
    "answer": "C"
  },
  {
    "id": "topic12_7",
    "question": "How are security assumptions on primitives defined in ProVerif?",
    "options": {
      "A": "Using the syntax `def name(i1,..., in) { declarations }`.",
      "B": "Using the syntax `let name(i1,..., in) = declarations`.",
      "C": "Using the syntax `process name(i1,..., in) = declarations`.",
      "D": "Using the syntax `macro name(i1,..., in) = declarations`."
    },
    "answer": "A"
  },
  {
    "id": "topic12_8",
    "question": "What is the purpose of the `[Equations]` section in ProVerif's output?",
    "options": {
      "A": "To display the input process with all macros expanded.",
      "B": "To summarize the internal representation of the equations given in the input file.",
      "C": "To display the security assumptions on primitives.",
      "D": "To declare free names and variables."
    },
    "answer": "B"
  },
  {
    "id": "topic12_9",
    "question": "What is the purpose of the `[Process]` section in ProVerif's output?",
    "options": {
      "A": "To display the input process with all macros expanded.",
      "B": "To summarize the internal representation of the equations given in the input file.",
      "C": "To display the security assumptions on primitives.",
      "D": "To declare free names and variables."
    },
    "answer": "A"
  },
  {
    "id": "topic12_10",
    "question": "What happens to processes that did not reach a phase construct with a higher phase number in ProVerif?",
    "options": {
      "A": "They are executed in parallel with processes in the higher phase.",
      "B": "They are discarded and processes in the higher phase are executed.",
      "C": "They are suspended until the higher phase is reached.",
      "D": "They are executed before processes in the higher phase."
    },
    "answer": "B"
  },
  {
    "id": "topic13_1",
    "question": "What is the purpose of the \"forall\" keyword in the given formalism?",
    "options": {
      "A": "To declare a new variable or name.",
      "B": "To universally quantify variables in a clause.",
      "C": "To specify the type of a variable or name.",
      "D": "To indicate the scope of a variable or name."
    },
    "answer": "B"
  },
  {
    "id": "topic13_2",
    "question": "What happens when F1,..., Fm, F contain no variables in a clause?",
    "options": {
      "A": "The \"forall\" keyword must still be used.",
      "B": "The \"forall\" keyword can be omitted.",
      "C": "The clause is considered invalid.",
      "D": "The variables are assumed to be universally quantified."
    },
    "answer": "B"
  },
  {
    "id": "topic13_3",
    "question": "What is the meaning of \"t or fail\" in the context of variable types?",
    "options": {
      "A": "The variable can take any value except fail.",
      "B": "The variable can take the special value fail in addition to its normal type.",
      "C": "The variable can only take the value fail.",
      "D": "The variable cannot take the value fail."
    },
    "answer": "B"
  },
  {
    "id": "topic13_4",
    "question": "How are names represented in the given formalism when they are in the scope of variables?",
    "options": {
      "A": "Without arguments, e.g. a[ ].",
      "B": "With arguments, e.g. b[x=M, y=N].",
      "C": "As a single identifier, e.g. c.",
      "D": "As a function symbol, e.g. f(x, y)."
    },
    "answer": "B"
  },
  {
    "id": "topic13_5",
    "question": "What is the purpose of annotating restrictions with variables in the internal representation of fresh names?",
    "options": {
      "A": "To avoid confusion between names and variables.",
      "B": "To ensure that matching names have the same arguments.",
      "C": "To specify the type of a variable or name.",
      "D": "To universally quantify variables in a clause."
    },
    "answer": "B"
  },
  {
    "id": "topic13_6",
    "question": "What is the convention for omitting \"else 0\" in the if-then-else construct?",
    "options": {
      "A": "It is always omitted.",
      "B": "It is never omitted.",
      "C": "It is omitted only when the \"if\" statement is nested.",
      "D": "It is omitted only when the \"else\" clause is empty."
    },
    "answer": "D"
  },
  {
    "id": "topic13_7",
    "question": "What is the purpose of the \"[precise]\" annotation for inputs?",
    "options": {
      "A": "To specify the type of a variable or name.",
      "B": "To universally quantify variables in a clause.",
      "C": "To ensure that the input is taken into account as precisely as possible.",
      "D": "To avoid confusion between names and variables."
    },
    "answer": "C"
  },
  {
    "id": "topic13_8",
    "question": "What is the format of the input file in the given formalism?",
    "options": {
      "A": "A list of declarations followed by the keyword \"process\" and a process.",
      "B": "A list of processes followed by the keyword \"declaration\" and a declaration.",
      "C": "A single declaration followed by the keyword \"process\" and a process.",
      "D": "A single process followed by the keyword \"declaration\" and a declaration."
    },
    "answer": "A"
  },
  {
    "id": "topic13_9",
    "question": "What is the purpose of the \"type\" keyword in the given formalism?",
    "options": {
      "A": "To declare a new variable or name.",
      "B": "To specify the type of a variable or name.",
      "C": "To universally quantify variables in a clause.",
      "D": "To define a new function symbol."
    },
    "answer": "B"
  },
  {
    "id": "topic13_10",
    "question": "What is the purpose of the \"free\" keyword in the given formalism?",
    "options": {
      "A": "To declare a new variable or name.",
      "B": "To specify the type of a variable or name.",
      "C": "To universally quantify variables in a clause.",
      "D": "To declare a free name with its type."
    },
    "answer": "D"
  },
  {
    "id": "topic14_1",
    "question": "What is the purpose of a destructor function symbol in the given formalism?",
    "options": {
      "A": "To construct new terms from existing ones.",
      "B": "To define a new data type.",
      "C": "To extract information from a term.",
      "D": "To declare a new variable."
    },
    "answer": "C"
  },
  {
    "id": "topic14_2",
    "question": "What is a simple pattern in the context of pattern-matching?",
    "options": {
      "A": "A pattern that contains at least one destructor function symbol.",
      "B": "A pattern that contains only constructor function symbols.",
      "C": "A pattern that corresponds to an element from Figure A.1.",
      "D": "A pattern that contains at least one conditional statement."
    },
    "answer": "C"
  },
  {
    "id": "topic14_3",
    "question": "What happens when a term M fails in the context of pattern-matching?",
    "options": {
      "A": "The pattern-matching succeeds with a default value.",
      "B": "The pattern-matching fails.",
      "C": "The term M is replaced with a new term.",
      "D": "The pattern-matching is retried with a different pattern."
    },
    "answer": "B"
  },
  {
    "id": "topic14_4",
    "question": "What is the purpose of the `let x = M in P else Q` statement?",
    "options": {
      "A": "To declare a new variable x.",
      "B": "To assign a value to a variable x.",
      "C": "To evaluate a term M and bind the result to x.",
      "D": "To execute a process P if a term M evaluates to true."
    },
    "answer": "C"
  },
  {
    "id": "topic14_5",
    "question": "What is a data constructor in the context of the given formalism?",
    "options": {
      "A": "A constructor function symbol with no associated destructors.",
      "B": "A constructor function symbol with associated destructors.",
      "C": "A destructor function symbol with associated constructors.",
      "D": "A function symbol that can be used as both a constructor and a destructor."
    },
    "answer": "B"
  },
  {
    "id": "topic14_6",
    "question": "What is the requirement for the arguments of a destructor function symbol?",
    "options": {
      "A": "They must have different types.",
      "B": "They must have the same type.",
      "C": "They must be constructor terms.",
      "D": "They must be destructor terms."
    },
    "answer": "B"
  },
  {
    "id": "topic14_7",
    "question": "What happens when a destructor function symbol is applied to a term that does not match its rewrite rule?",
    "options": {
      "A": "The term is replaced with a default value.",
      "B": "The destructor function symbol fails.",
      "C": "The term is retried with a different rewrite rule.",
      "D": "The destructor function symbol is ignored."
    },
    "answer": "B"
  },
  {
    "id": "topic14_8",
    "question": "What is the purpose of the `reduc` declaration?",
    "options": {
      "A": "To declare a new constructor function symbol.",
      "B": "To declare a new destructor function symbol.",
      "C": "To define a new rewrite rule for a destructor function symbol.",
      "D": "To declare a new variable."
    },
    "answer": "C"
  },
  {
    "id": "topic14_9",
    "question": "What is the requirement for the return type of a destructor function symbol?",
    "options": {
      "A": "It must be different from the types of its arguments.",
      "B": "It must be the same as the types of its arguments.",
      "C": "It must be a constructor term.",
      "D": "It must be a destructor term."
    },
    "answer": "B"
  },
  {
    "id": "topic14_10",
    "question": "What is the purpose of the `forall` keyword in the context of rewrite rules?",
    "options": {
      "A": "To declare a new variable.",
      "B": "To define a new rewrite rule for a destructor function symbol.",
      "C": "To specify the types of the arguments of a destructor function symbol.",
      "D": "To specify the return type of a destructor function symbol."
    },
    "answer": "C"
  },
  {
    "id": "topic15_1",
    "question": "What is the primary capability of ProVerif in terms of security property verification?",
    "options": {
      "A": "Verifying correspondence assertions",
      "B": "Proving reachability properties",
      "C": "Analyzing security protocols with secrecy types",
      "D": "Modeling security protocols with the applied pi calculus"
    },
    "answer": "B"
  },
  {
    "id": "topic15_2",
    "question": "How is secrecy of a term M evaluated in ProVerif?",
    "options": {
      "A": "By including the query \"attacker(M)\" in the input file",
      "B": "By declaring M as a private name",
      "C": "By using a destructor to extract M",
      "D": "By verifying correspondence assertions"
    },
    "answer": "A"
  },
  {
    "id": "topic15_3",
    "question": "What is the definition of strong secrecy in the context of security protocols?",
    "options": {
      "A": "The adversary cannot distinguish two versions of the protocol that use different values of the secret",
      "B": "The adversary can compute the secret using cryptographic primitives",
      "C": "The protocol preserves the secrecy of a term M",
      "D": "The protocol ensures authentication"
    },
    "answer": "A"
  },
  {
    "id": "topic15_4",
    "question": "What is the purpose of the \"query attacker(M)\" statement in ProVerif?",
    "options": {
      "A": "To declare M as a private name",
      "B": "To verify correspondence assertions",
      "C": "To evaluate the secrecy of term M",
      "D": "To model security protocols with the applied pi calculus"
    },
    "answer": "C"
  },
  {
    "id": "topic15_5",
    "question": "What is the core calculus used in ProVerif for security protocol verification?",
    "options": {
      "A": "The applied pi calculus",
      "B": "The symbolic model",
      "C": "The computational model",
      "D": "The Dolev-Yao model"
    },
    "answer": "A"
  },
  {
    "id": "topic15_6",
    "question": "How does ProVerif handle equivalences in security protocol verification?",
    "options": {
      "A": "By verifying strong secrecy",
      "B": "By analyzing security protocols with secrecy types",
      "C": "By modeling security protocols with the applied pi calculus",
      "D": "By verifying correspondence assertions"
    },
    "answer": "A"
  },
  {
    "id": "topic15_7",
    "question": "What is the main reference for the proof of secrecy and correspondences in ProVerif?",
    "options": {
      "A": "Blanchet (2009)",
      "B": "Blanchet et al. (2008)",
      "C": "Abadi and Blanchet (2003)",
      "D": "Blanchet (2014)"
    },
    "answer": "A"
  },
  {
    "id": "topic15_8",
    "question": "What is the simplest class of equivalences that ProVerif verifies?",
    "options": {
      "A": "Strong secrecy",
      "B": "Correspondence assertions",
      "C": "Authentication",
      "D": "Secrecy types"
    },
    "answer": "A"
  },
  {
    "id": "topic15_9",
    "question": "How does ProVerif model security protocols?",
    "options": {
      "A": "Using the symbolic model",
      "B": "Using the computational model",
      "C": "Using the applied pi calculus",
      "D": "Using secrecy types"
    },
    "answer": "C"
  },
  {
    "id": "topic15_10",
    "question": "What is the primary goal of reachability analysis in security protocol verification?",
    "options": {
      "A": "To verify correspondence assertions",
      "B": "To evaluate the secrecy of a term M",
      "C": "To prove reachability properties",
      "D": "To model security protocols with the applied pi calculus"
    },
    "answer": "C"
  },
  {
    "id": "topic16_1",
    "question": "What is the primary purpose of using correspondence assertions in authentication verification?",
    "options": {
      "A": "To prove secrecy properties",
      "B": "To verify authentication properties",
      "C": "To analyze observational equivalence",
      "D": "To ensure privacy"
    },
    "answer": "B"
  },
  {
    "id": "topic16_2",
    "question": "Which of the following tools is capable of verifying protocols for an unbounded number of sessions?",
    "options": {
      "A": "ProVerif",
      "B": "Tamarin",
      "C": "Isabelle",
      "D": "All of the above"
    },
    "answer": "B"
  },
  {
    "id": "topic16_3",
    "question": "What is the main idea behind using Horn clauses for verifying protocols?",
    "options": {
      "A": "To translate protocols into a set of Horn clauses and security properties into derivability queries",
      "B": "To use resolution to prove security properties",
      "C": "To verify protocols in the computational model",
      "D": "To analyze secrecy properties"
    },
    "answer": "A"
  },
  {
    "id": "topic16_4",
    "question": "Which of the following is NOT a capability of the ProVerif tool?",
    "options": {
      "A": "Verifying secrecy properties",
      "B": "Verifying authentication properties",
      "C": "Analyzing observational equivalence",
      "D": "Verifying protocols in the symbolic model only"
    },
    "answer": "D"
  },
  {
    "id": "topic16_5",
    "question": "What is the purpose of the correspondence assertion in the handshake protocol example?",
    "options": {
      "A": "To prove secrecy of the session key",
      "B": "To verify authentication of the client and server",
      "C": "To analyze observational equivalence",
      "D": "To ensure privacy"
    },
    "answer": "B"
  },
  {
    "id": "topic16_6",
    "question": "Which of the following papers introduced the idea of using Horn clauses for verifying protocols?",
    "options": {
      "A": "Weidenbach (1999)",
      "B": "Blanchet (2014)",
      "C": "Abadi & Blanchet (2005)",
      "D": "Backes et al. (2014)"
    },
    "answer": "A"
  },
  {
    "id": "topic16_7",
    "question": "What is the benefit of using correspondence assertions in authentication verification?",
    "options": {
      "A": "It allows for fully automatic proof of security properties",
      "B": "It constitutes the most important part of the proof",
      "C": "It is only useful for secrecy properties",
      "D": "It is not necessary for authentication verification"
    },
    "answer": "B"
  },
  {
    "id": "topic16_8",
    "question": "Which of the following is an example of a protocol analyzed using correspondence assertions?",
    "options": {
      "A": "Certified email protocol",
      "B": "JFK (Just Fast Keying) protocol",
      "C": "Plutus file system",
      "D": "All of the above"
    },
    "answer": "D"
  },
  {
    "id": "topic16_9",
    "question": "What is the purpose of the Tamarin tool?",
    "options": {
      "A": "To verify protocols in the symbolic model",
      "B": "To analyze secrecy properties",
      "C": "To verify protocols for an unbounded number of sessions",
      "D": "To analyze observational equivalence"
    },
    "answer": "C"
  },
  {
    "id": "topic16_10",
    "question": "Which of the following is a limitation of the ProVerif tool?",
    "options": {
      "A": "It cannot handle an unbounded number of sessions",
      "B": "It cannot analyze observational equivalence",
      "C": "It relies on the user to provide some lemmas",
      "D": "It cannot verify protocols in the computational model"
    },
    "answer": "C"
  },
  {
    "id": "topic1_1",
    "question": "What is the input language of ProVerif a dialect of?",
    "options": {
      "A": "The pi calculus",
      "B": "The applied pi calculus",
      "C": "The lambda calculus",
      "D": "The calculus of constructions"
    },
    "answer": "B"
  },
  {
    "id": "topic1_2",
    "question": "How is the applied pi calculus related to the pi calculus?",
    "options": {
      "A": "It is a subset of the pi calculus.",
      "B": "It is an extension of the pi calculus with function symbols defined by an equational theory.",
      "C": "It has no relation to the pi calculus.",
      "D": "It is a completely different calculus with no similarities to the pi calculus."
    },
    "answer": "B"
  },
  {
    "id": "topic1_3",
    "question": "What is one of the differences between ProVerif and the applied pi calculus?",
    "options": {
      "A": "ProVerif supports all equational theories while the applied pi calculus does not.",
      "B": "ProVerif uses destructors in addition to the equational theories of the applied pi calculus, but does not support all equational theories.",
      "C": "The applied pi calculus uses destructors and ProVerif does not.",
      "D": "There are no differences between them."
    },
    "answer": "B"
  },
  {
    "id": "topic1_4",
    "question": "What does ProVerif take as input regarding the protocol?",
    "options": {
      "A": "A model of the protocol in the pi calculus without any extensions.",
      "B": "A model of the protocol in an extension of the pi calculus with cryptography.",
      "C": "A model of the protocol in the lambda calculus.",
      "D": "A model of the protocol in natural language description."
    },
    "answer": "B"
  },
  {
    "id": "topic1_5",
    "question": "Which of the following security properties can ProVerif verify?",
    "options": {
      "A": "Only secrecy",
      "B": "Secrecy, authentication, and some observational equivalence properties",
      "C": "Only authentication",
      "D": "No security properties can be verified by ProVerif."
    },
    "answer": "B"
  },
  {
    "id": "topic1_6",
    "question": "In the context of ProVerif and the applied pi calculus, if ProVerif processes are equivalent in a certain sense, what can be said about the corresponding applied pi calculus processes?",
    "options": {
      "A": "They are not related in terms of equivalence.",
      "B": "The corresponding applied pi calculus processes are observationally equivalent.",
      "C": "The applied pi calculus processes are always non - equivalent.",
      "D": "The equivalence of ProVerif processes has no bearing on the applied pi calculus processes."
    },
    "answer": "B"
  },
  {
    "id": "topic1_7",
    "question": "What is the significance of the destructors in ProVerif compared to the applied pi calculus?",
    "options": {
      "A": "Destructors are used in the applied pi calculus but not in ProVerif.",
      "B": "ProVerif uses destructors instead of the equational theories of the applied pi calculus.",
      "C": "Destructors are just an optional feature in ProVerif with no real difference from the applied pi calculus.",
      "D": "Destructors make ProVerif less powerful than the applied pi calculus."
    },
    "answer": "B"
  },
  {
    "id": "topic1_8",
    "question": "What is the role of the automatic translator in the structure of ProVerif?",
    "options": {
      "A": "It translates natural language descriptions of protocols into ProVerif code.",
      "B": "It is not part of the ProVerif structure.",
      "C": "It is involved in the process of dealing with Horn clauses and derivability queries.",
      "D": "It translates the protocol model and security properties into a form suitable for ProVerif's internal processing."
    },
    "answer": "D"
  },
  {
    "id": "topic1_9",
    "question": "What kind of functions do both ProVerif's calculus and the applied pi calculus extend the pi calculus with?",
    "options": {
      "A": "Only linear functions on terms.",
      "B": "(Fairly arbitrary) functions on terms.",
      "C": "Only polynomial functions on terms.",
      "D": "Only constant functions on terms."
    },
    "answer": "B"
  },
  {
    "id": "topic1_10",
    "question": "What do substitutions in ProVerif's protocol specification language always map?",
    "options": {
      "A": "Names to expressions.",
      "B": "Variables (not names) to terms.",
      "C": "Variables to fail or may - fail variables.",
      "D": "Names to terms."
    },
    "answer": "B"
  },
  {
    "id": "topic2_1",
    "question": "What is the primary goal of ProVerif?",
    "options": {
      "A": "To develop new cryptographic protocols.",
      "B": "To verify cryptographic protocols.",
      "C": "To analyze network traffic.",
      "D": "To design new security algorithms."
    },
    "answer": "B"
  },
  {
    "id": "topic2_2",
    "question": "Which of the following types of protocols has ProVerif been used to verify?",
    "options": {
      "A": "File transfer protocols.",
      "B": "E - voting protocols.",
      "C": "Video streaming protocols.",
      "D": "Social media communication protocols."
    },
    "answer": "B"
  },
  {
    "id": "topic2_3",
    "question": "ProVerif takes as input a model of the protocol in an extension of what calculus with cryptography?",
    "options": {
      "A": "Lambda calculus.",
      "B": "Pi calculus.",
      "C": "Differential calculus.",
      "D": "Integral calculus."
    },
    "answer": "B"
  },
  {
    "id": "topic2_4",
    "question": "What kind of properties can ProVerif prove?",
    "options": {
      "A": "Only reachability properties.",
      "B": "Secrecy, authenticity, and some observational equivalence properties.",
      "C": "Only authentication properties.",
      "D": "Only observational equivalence properties."
    },
    "answer": "B"
  },
  {
    "id": "topic2_5",
    "question": "ProVerif uses an abstract representation of protocols by what?",
    "options": {
      "A": "Tree - automata.",
      "B": "Horn clauses.",
      "C": "Finite state machines.",
      "D": "Neural networks."
    },
    "answer": "B"
  },
  {
    "id": "topic2_6",
    "question": "When ProVerif is used as a back - end, it is mainly for what purpose?",
    "options": {
      "A": "Building web servers.",
      "B": "Building other verification tools.",
      "C": "Building data storage systems.",
      "D": "Building mobile applications."
    },
    "answer": "B"
  },
  {
    "id": "topic2_7",
    "question": "ProVerif can work for what kind of session and message space?",
    "options": {
      "A": "A fixed number of sessions and a fixed message space.",
      "B": "An unbounded number of sessions and an unbounded message space.",
      "C": "A bounded number of sessions and an unbounded message space.",
      "D": "An unbounded number of sessions and a bounded message space."
    },
    "answer": "B"
  },
  {
    "id": "topic2_8",
    "question": "Which of the following is a major deployed protocol that ProVerif has been used to analyze?",
    "options": {
      "A": "FTP.",
      "B": "TLS.",
      "C": "SMTP.",
      "D": "HTTP."
    },
    "answer": "B"
  },
  {
    "id": "topic2_9",
    "question": "ProVerif automatically translates the protocol and security properties into what internal representation?",
    "options": {
      "A": "A matrix representation.",
      "B": "A graph representation.",
      "C": "Horn clauses and derivability queries.",
      "D": "A list representation."
    },
    "answer": "C"
  },
  {
    "id": "topic2_10",
    "question": "In the context of ProVerif, what does the “Dolev - Yao” model represent?",
    "options": {
      "A": "A model of a friendly network environment.",
      "B": "A model of a very powerful attacker in the network.",
      "C": "A model of a network service provider.",
      "D": "A model of a network infrastructure component."
    },
    "answer": "B"
  },
  {
    "id": "topic3_1",
    "question": "What is the rule for the first character of an identifier in the described language?",
    "options": {
      "A": "It can be any character from the ISO Latin 1 character set.",
      "B": "It must be a digit.",
      "C": "It must be a letter.",
      "D": "It can be an underscore."
    },
    "answer": "C"
  },
  {
    "id": "topic3_2",
    "question": "Which of the following character sets are allowed in identifiers?",
    "options": {
      "A": "Only letters (a - z, A - Z) and digits (0 - 9).",
      "B": "Letters (a - z, A - Z), digits (0 - 9), underscores, single - quotes, and accented letters from the ISO Latin 1 character set.",
      "C": "Only letters (a - z, A - Z) and underscores.",
      "D": "Letters (a - z, A - Z), digits (0 - 9), and special symbols like @ and #."
    },
    "answer": "B"
  },
  {
    "id": "topic3_3",
    "question": "What is the policy regarding reserved words and identifiers?",
    "options": {
      "A": "Reserved words can be used as identifiers if they are in lowercase.",
      "B": "Reserved words cannot be used as identifiers.",
      "C": "Reserved words can be used as identifiers if they are part of a longer name.",
      "D": "There is no policy regarding reserved words and identifiers."
    },
    "answer": "B"
  },
  {
    "id": "topic3_4",
    "question": "Are there any length restrictions for identifiers?",
    "options": {
      "A": "Identifiers must be at least 3 characters long.",
      "B": "Identifiers must be at most 10 characters long.",
      "C": "The text does not mention any length restrictions, so identifiers can be of an unlimited length.",
      "D": "Identifiers must be exactly 5 characters long."
    },
    "answer": "C"
  },
  {
    "id": "topic3_5",
    "question": "Can an identifier start with a single - quote?",
    "options": {
      "A": "Yes, as long as the rest of the characters are valid.",
      "B": "No, the first character of an identifier must be a letter.",
      "C": "It depends on whether it is a variable or a function identifier.",
      "D": "Yes, but only for function identifiers."
    },
    "answer": "B"
  },
  {
    "id": "topic3_6",
    "question": "In the context of identifiers, are identifiers case - sensitive?",
    "options": {
      "A": "No, all identifiers are treated the same regardless of case.",
      "B": "Yes, identifiers are case - sensitive.",
      "C": "Only function identifiers are case - sensitive.",
      "D": "Only variable identifiers are case - sensitive."
    },
    "answer": "B"
  },
  {
    "id": "topic3_7",
    "question": "Which of the following is a valid identifier according to the given rules?",
    "options": {
      "A": "among (a reserved word)",
      "B": "1abc (starts with a digit)",
      "C": "'abc (starts with a single - quote)",
      "D": "validName"
    },
    "answer": "D"
  },
  {
    "id": "topic3_8",
    "question": "If a user wants to use a word that is similar to a reserved word but not exactly the same, can it be used as an identifier?",
    "options": {
      "A": "No, any word close to a reserved word cannot be used.",
      "B": "Yes, as long as it is distinct from the reserved words and follows the other identifier rules.",
      "C": "It can only be used if it is a variable identifier.",
      "D": "It can only be used if it is a function identifier."
    },
    "answer": "B"
  },
  {
    "id": "topic3_9",
    "question": "Can a reserved word be used as an identifier if it is in a comment?",
    "options": {
      "A": "No, it is still not allowed even in a comment.",
      "B": "Yes, reserved words can be used freely in comments.",
      "C": "It depends on the type of comment (single - line or multi - line).",
      "D": "Only some reserved words can be used in comments."
    },
    "answer": "B"
  },
  {
    "id": "topic3_10",
    "question": "If an identifier contains an accented letter from the ISO Latin 1 character set, is it still valid?",
    "options": {
      "A": "No, accented letters are not allowed in identifiers.",
      "B": "Yes, as long as it follows the other rules like starting with a letter and being distinct from reserved words.",
      "C": "It is only valid for variable identifiers.",
      "D": "It is only valid for function identifiers."
    },
    "answer": "B"
  },
  {
    "id": "topic4_1",
    "question": "Which of the following is a keyword mentioned in the context with a special syntactic meaning?",
    "options": {
      "A": "\"var\"",
      "B": "\"event\"",
      "C": "\"forloop\"",
      "D": "\"list\""
    },
    "answer": "B"
  },
  {
    "id": "topic4_2",
    "question": "What is the semantic role of the keyword \"event\" in the given context?",
    "options": {
      "A": "It is used to declare a new variable.",
      "B": "It is used to denote an event occurrence with associated terms.",
      "C": "It is used to define a function.",
      "D": "It is used to create a loop structure."
    },
    "answer": "B"
  },
  {
    "id": "topic4_3",
    "question": "The keyword \"let\" in the provided content is mainly used for:",
    "options": {
      "A": "Defining a new type.",
      "B": "Declaring a secret variable.",
      "C": "Assigning a value to an identifier and using it in an expression.",
      "D": "Creating a conditional statement."
    },
    "answer": "C"
  },
  {
    "id": "topic4_4",
    "question": "In the context, the keyword \"choice\" is used to:",
    "options": {
      "A": "Select a random element from a list.",
      "B": "Represent a choice between two terms.",
      "C": "Define a new function.",
      "D": "Declare a public variable."
    },
    "answer": "B"
  },
  {
    "id": "topic4_5",
    "question": "What does the keyword \"new\" do in the given formalism?",
    "options": {
      "A": "It creates a new function.",
      "B": "It initializes a new variable with a default value.",
      "C": "It is used to introduce a new identifier with associated bindings.",
      "D": "It starts a new block of code."
    },
    "answer": "C"
  },
  {
    "id": "topic4_6",
    "question": "The keyword \"get\" in the provided text is used in the context of:",
    "options": {
      "A": "Retrieving values from a data structure based on a pattern and options.",
      "B": "Defining a new event.",
      "C": "Declaring a type.",
      "D": "Performing a mathematical operation."
    },
    "answer": "A"
  },
  {
    "id": "topic4_7",
    "question": "Which of the following statements about the keyword \"if\" (not explicitly shown but a common keyword conceptually) in programming - like semantics is true based on the context's overall style?",
    "options": {
      "A": "It is used to create a loop.",
      "B": "It is used for conditional execution of code blocks.",
      "C": "It is used to declare a new class.",
      "D": "It is used to define a new operator."
    },
    "answer": "B"
  },
  {
    "id": "topic4_8",
    "question": "The keyword \"seq\" in the context is related to:",
    "options": {
      "A": "Sequencing events in a chronological order.",
      "B": "Representing a non - empty sequence of elements of a certain type.",
      "C": "Defining a sequential function.",
      "D": "Creating a sequential loop."
    },
    "answer": "B"
  },
  {
    "id": "topic4_9",
    "question": "What is the semantic role of the keyword \"phase\" in the given context?",
    "options": {
      "A": "It is used to define the phase of a moon in a simulation.",
      "B": "It is used to specify a phase number associated with a term.",
      "C": "It is used to start a new section in the code.",
      "D": "It is used to declare a phase - related variable."
    },
    "answer": "B"
  },
  {
    "id": "topic4_10",
    "question": "The keyword \"channel\" in the content is used as:",
    "options": {
      "A": "A variable name.",
      "B": "A type identifier.",
      "C": "A function name.",
      "D": "A loop control keyword."
    },
    "answer": "B"
  },
  {
    "id": "topic5_1",
    "question": "Which of the following is a keyword in the ProVerif language and cannot be used as an identifier?",
    "options": {
      "A": "variable",
      "B": "const",
      "C": "function",
      "D": "process"
    },
    "answer": "B"
  },
  {
    "id": "topic5_2",
    "question": "In ProVerif, when aiming for better performance, what should be used instead of equations?",
    "options": {
      "A": "Constructors",
      "B": "Destructors",
      "C": "Variables",
      "D": "Names"
    },
    "answer": "B"
  },
  {
    "id": "topic5_3",
    "question": "How can you adjust the precision and cost of the analysis in ProVerif?",
    "options": {
      "A": "By changing the number of parallel processes",
      "B": "By adjusting the arguments of patterns that represent names",
      "C": "By using more function symbols",
      "D": "By increasing the number of conditional statements"
    },
    "answer": "B"
  },
  {
    "id": "topic5_4",
    "question": "What is the default behavior in ProVerif regarding testing the attacker's ability?",
    "options": {
      "A": "Testing if the attacker can distinguish a value from a fresh random value",
      "B": "Testing if the attacker can compute the value of x",
      "C": "Testing if the attacker can create new names",
      "D": "Testing if the attacker can break the encryption"
    },
    "answer": "B"
  },
  {
    "id": "topic5_5",
    "question": "What is the main difference between ProVerif's calculus and the applied pi calculus?",
    "options": {
      "A": "ProVerif uses equations instead of destructors",
      "B": "ProVerif uses destructors instead of equational theories",
      "C": "The applied pi calculus has no functions on terms",
      "D": "ProVerif does not extend the pi calculus"
    },
    "answer": "B"
  },
  {
    "id": "topic5_6",
    "question": "In the ProVerif language with certain additional conditions, how is the destructor “equal” written?",
    "options": {
      "A": "equal(M, N)",
      "B": "M == N",
      "C": "M = N",
      "D": "eq(M, N)"
    },
    "answer": "C"
  },
  {
    "id": "topic5_7",
    "question": "In ProVerif, what is an evaluation context?",
    "options": {
      "A": "A process with a hole not under a replication, a conditional, an input, or an output",
      "B": "A process with a hole only under a replication",
      "C": "A process with a hole under any operator",
      "D": "A process without any holes"
    },
    "answer": "A"
  },
  {
    "id": "topic5_8",
    "question": "What does setting “set predicatesImplementable = check” do in ProVerif?",
    "options": {
      "A": "It checks if predicate calls are implementable",
      "B": "It disables all predicate calls",
      "C": "It makes all predicates public",
      "D": "It checks if all names are fresh"
    },
    "answer": "A"
  },
  {
    "id": "topic5_9",
    "question": "In ProVerif, what does the “new” operator do in a process declaration?",
    "options": {
      "A": "It creates a new function symbol",
      "B": "It creates a new predicate",
      "C": "It creates a new name restriction",
      "D": "It creates a new conditional statement"
    },
    "answer": "C"
  },
  {
    "id": "topic5_10",
    "question": "When using “set movenew = true” in ProVerif, what is the result?",
    "options": {
      "A": "It disables the analysis of fresh names",
      "B": "It yields the most precise analysis",
      "C": "It makes all names public",
      "D": "It reduces the number of function symbols"
    },
    "answer": "B"
  },
  {
    "id": "topic6_1",
    "question": "In the given content, which symbols are used for separating or grouping structural elements?",
    "options": {
      "A": "+, -, *",
      "B": "(), [], {}, ., ;",
      "C": "&&, ||, =",
      "D": "<, >, <=, >="
    },
    "answer": "B"
  },
  {
    "id": "topic6_2",
    "question": "For the sequence construction seq+⟨X ⟩, which delimiter is used to separate elements in the sequence?",
    "options": {
      "A": ":",
      "B": ";",
      "C": ",",
      "D": "*"
    },
    "answer": "C"
  },
  {
    "id": "topic6_3",
    "question": "In the declaration ⟨gbinding⟩ ::= !⟨nat⟩ = ⟨gterm⟩ [; ⟨gbinding⟩], what is the delimiter used to separate multiple ⟨gbinding⟩ elements?",
    "options": {
      "A": ".",
      "B": ";",
      "C": ",",
      "D": ":"
    },
    "answer": "B"
  },
  {
    "id": "topic6_4",
    "question": "In the construction [ [seq+⟨ident⟩]], what is the main purpose of the square - brackets []?",
    "options": {
      "A": "To denote multiplication",
      "B": "To separate the sequence from other elements",
      "C": "To group the sequence of identifiers",
      "D": "To indicate a negative value"
    },
    "answer": "C"
  },
  {
    "id": "topic6_5",
    "question": "In the rule E,P∪{{out(N,M); P,in(N,x); Q}},A msg(N,M) −−−−−−−→E,P∪{{P,Q{M/x}}},A, what is the role of the semicolon ; in out(N,M); P and in(N,x); Q?",
    "options": {
      "A": "It is used for multiplication",
      "B": "It separates different actions in the process",
      "C": "It indicates a conditional statement",
      "D": "It is used for logical AND operation"
    },
    "answer": "B"
  },
  {
    "id": "topic6_6",
    "question": "In the grammar ⟨failtypedecl⟩ ::= seq+⟨ident⟩: ⟨typeid⟩[or fail][,⟨failtypedecl⟩], what does the comma , do?",
    "options": {
      "A": "It is used for logical OR operation",
      "B": "It separates multiple ⟨failtypedecl⟩ declarations",
      "C": "It is used for arithmetic addition",
      "D": "It indicates a function call"
    },
    "answer": "B"
  },
  {
    "id": "topic6_7",
    "question": "In the syntax [ [seq+⟨ident⟩]], if we want to add another identifier to the sequence, what delimiter should we use between the identifiers?",
    "options": {
      "A": ":",
      "B": ";",
      "C": ",",
      "D": "*"
    },
    "answer": "C"
  },
  {
    "id": "topic6_8",
    "question": "In the rule E,P∪{{new a; P}},A− →E∪{a′},P∪{{P{a′ /a}}},A, what is the function of the semicolon ; in new a; P?",
    "options": {
      "A": "It is used to indicate a logical AND operation",
      "B": "It separates the new declaration from the following process",
      "C": "It is used for arithmetic subtraction",
      "D": "It indicates a loop"
    },
    "answer": "B"
  },
  {
    "id": "topic6_9",
    "question": "In the construction let ⟨ident⟩ = ⟨gterm⟩ in ⟨gterm⟩, what is the role of the keyword in?",
    "options": {
      "A": "It is a delimiter that separates the assignment part from the expression where the assigned value is used",
      "B": "It is used for logical OR operation",
      "C": "It is used for arithmetic multiplication",
      "D": "It indicates a conditional statement"
    },
    "answer": "A"
  },
  {
    "id": "topic6_10",
    "question": "In the grammar ⟨options⟩ ::= [ [seq+⟨ident⟩]], if the sequence has only one identifier, are the square - brackets [] still necessary?",
    "options": {
      "A": "No, they are not necessary",
      "B": "Yes, they are used to group the single identifier",
      "C": "They are only necessary if the identifier is a reserved word",
      "D": "They are only necessary if the identifier is a number"
    },
    "answer": "B"
  },
  {
    "id": "topic7_1",
    "question": "Which of the following best describes the role of spaces, tabs, and newline characters in the ProVerif language?",
    "options": {
      "A": "They are strictly for aesthetic purposes and have no impact on the semantics of the code.",
      "B": "They are used to separate keywords and identifiers, but their use is completely interchangeable.",
      "C": "They are crucial for indicating the structure of the code, like separating different elements of a process or expression.",
      "D": "They are ignored by the ProVerif compiler and do not affect how the code is parsed."
    },
    "answer": "C"
  },
  {
    "id": "topic7_2",
    "question": "In ProVerif, if you want to write a comment, which of the following statements is correct?",
    "options": {
      "A": "There is no syntax for comments in ProVerif.",
      "B": "Comments start with a single - dash (-) and end at the end of the line.",
      "C": "Comments are written between /* and */, similar to C - style comments.",
      "D": "Comments are written after a semicolon (;) and are ignored by the compiler."
    },
    "answer": "C"
  },
  {
    "id": "topic7_3",
    "question": "What happens if you forget to use proper whitespace to separate keywords in a ProVerif code?",
    "options": {
      "A": "The code will still run correctly as long as the keywords are in the right order.",
      "B": "The ProVerif compiler will automatically insert the necessary whitespace.",
      "C": "It may lead to a syntax error as the compiler may not be able to distinguish between different elements.",
      "D": "The code will run, but the performance will be significantly degraded."
    },
    "answer": "C"
  },
  {
    "id": "topic7_4",
    "question": "Which of the following statements about whitespace in ProVerif is false?",
    "options": {
      "A": "Whitespace can be used to make the code more readable.",
      "B": "Too much whitespace can cause the code to run slower.",
      "C": "Spaces, tabs, and newlines can be used to separate different parts of an expression.",
      "D": "The use of whitespace follows certain rules to ensure correct parsing."
    },
    "answer": "B"
  },
  {
    "id": "topic7_5",
    "question": "In a ProVerif code, if you write two keywords right next to each other without any whitespace, what will the compiler do?",
    "options": {
      "A": "It will assume that one of the keywords is a misspelled identifier.",
      "B": "It will generate a warning and try to correct the code by inserting whitespace.",
      "C": "It will throw a syntax error because it cannot parse the code correctly.",
      "D": "It will treat the combined keywords as a new, valid keyword."
    },
    "answer": "C"
  },
  {
    "id": "topic7_6",
    "question": "Which of the following is a correct way to use whitespace in a ProVerif process declaration?",
    "options": {
      "A": "Write all parts of the process on a single line without any spaces.",
      "B": "Use spaces to separate the different components of the process, like separating an output operation from the rest of the process.",
      "C": "Use only tabs and avoid spaces altogether.",
      "D": "Use newlines only at the end of a complete protocol model, not within a single process."
    },
    "answer": "B"
  },
  {
    "id": "topic7_7",
    "question": "Regarding comments in ProVerif, which of the following is true?",
    "options": {
      "A": "Comments can be nested within other comments.",
      "B": "Comments can contain ProVerif code, but it will be ignored.",
      "C": "Comments can only be placed at the beginning of a file.",
      "D": "Comments must be written in uppercase letters."
    },
    "answer": "B"
  },
  {
    "id": "topic7_8",
    "question": "If you use an inconsistent mix of spaces and tabs for indentation in a ProVerif code, what is the likely outcome?",
    "options": {
      "A": "The code will not compile due to an indentation error.",
      "B": "The compiler will automatically standardize the indentation to either spaces or tabs.",
      "C": "It may make the code harder to read, but it should not cause a syntax error.",
      "D": "The code will run, but the results may be incorrect."
    },
    "answer": "C"
  },
  {
    "id": "topic7_9",
    "question": "What is the main purpose of using comments in ProVerif?",
    "options": {
      "A": "To make the code look more professional.",
      "B": "To provide explanations for the code, making it easier for others (or yourself in the future) to understand.",
      "C": "To add hidden functionality to the code that is not visible to the compiler.",
      "D": "To increase the security of the code by obfuscating certain parts."
    },
    "answer": "B"
  },
  {
    "id": "topic7_10",
    "question": "In ProVerif, can you use whitespace to break a long line of code into multiple lines?",
    "options": {
      "A": "No, each line of code must be written as a single, unbroken statement.",
      "B": "Yes, but you need to use a special character to indicate the line - break.",
      "C": "Yes, you can use spaces, tabs, or newlines to break a long line, as long as the code remains syntactically correct.",
      "D": "Only newlines can be used to break a long line, and spaces and tabs are not allowed."
    },
    "answer": "C"
  },
  {
    "id": "topic8_1",
    "question": "How can a constant be defined in the described system?",
    "options": {
      "A": "A constant can only be defined using the “const c : t” construct.",
      "B": "A constant may be defined as a function of arity 0, like “fun c() : t.”",
      "C": "A constant is always an atomic data like keys and nonces.",
      "D": "Constants are defined without any type declaration."
    },
    "answer": "B"
  },
  {
    "id": "topic8_2",
    "question": "What is the role of names in the system?",
    "options": {
      "A": "Names can be substituted by terms just like variables.",
      "B": "Names represent atomic data such as keys and nonces.",
      "C": "Names are used only for defining constructors.",
      "D": "Names are always declared as free names."
    },
    "answer": "B"
  },
  {
    "id": "topic8_3",
    "question": "When declaring function symbols, what does “h(T1,...,Tn) : T” mean?",
    "options": {
      "A": "The function h takes T arguments of types T1,...,Tn respectively.",
      "B": "The function h takes n arguments of the same type T.",
      "C": "The function h takes n arguments of types T1,...,Tn respectively, and returns a value of type T.",
      "D": "The function h returns n values of types T1,...,Tn respectively."
    },
    "answer": "C"
  },
  {
    "id": "topic8_4",
    "question": "How should all free names appearing within an input file be declared?",
    "options": {
      "A": "Using the syntax “type n : t”.",
      "B": "Using the syntax “free n : t”.",
      "C": "Using the syntax “const n : t”.",
      "D": "Free names do not need to be declared."
    },
    "answer": "B"
  },
  {
    "id": "topic8_5",
    "question": "Which of the following is a built - in type in ProVerif?",
    "options": {
      "A": "integer",
      "B": "bitstring",
      "C": "float",
      "D": "char"
    },
    "answer": "B"
  },
  {
    "id": "topic8_6",
    "question": "What is the correct way to declare a user - defined type?",
    "options": {
      "A": "const t.",
      "B": "fun t().",
      "C": "type t.",
      "D": "free t."
    },
    "answer": "C"
  },
  {
    "id": "topic8_7",
    "question": "What is the meaning of the construct “⟨decl⟩∗ process ⟨process⟩”?",
    "options": {
      "A": "It represents a single declaration followed by a process.",
      "B": "It represents a list of declarations followed by a process.",
      "C": "It represents an equivalence query between two processes.",
      "D": "It represents a single declaration followed by an equivalence query."
    },
    "answer": "B"
  },
  {
    "id": "topic8_8",
    "question": "Regarding the identifiers in ProVerif, which of the following statements is correct?",
    "options": {
      "A": "The built - in identifiers like “attacker” can be freely reused without any issues.",
      "B": "The authors encourage reusing built - in identifiers as regular identifiers.",
      "C": "Although the built - in identifiers can be reused, the authors strongly discourage this practice.",
      "D": "Built - in identifiers cannot be reused under any circumstances."
    },
    "answer": "C"
  },
  {
    "id": "topic8_9",
    "question": "Which of the following is a destructor in ProVerif?",
    "options": {
      "A": "attacker",
      "B": "is nat",
      "C": "mess",
      "D": "subterm"
    },
    "answer": "B"
  },
  {
    "id": "topic8_10",
    "question": "What does the syntax “⟨decl⟩∗ equivalence ⟨process⟩ ⟨process⟩” represent?",
    "options": {
      "A": "A single declaration followed by an equivalence between two processes.",
      "B": "A list of declarations followed by an equivalence query between two processes.",
      "C": "A single declaration followed by a process.",
      "D": "A list of declarations followed by a single process."
    },
    "answer": "B"
  },
  {
    "id": "topic9_1",
    "question": "How are function symbols declared in the given syntax?",
    "options": {
      "A": "Function symbols are declared without any types.",
      "B": "Function symbols are declared with types, e.g., h(T1,...,Tn) : T.",
      "C": "Only constructors are declared with types, destructors are not.",
      "D": "Function symbols are declared with only one type, regardless of the number of arguments."
    },
    "answer": "B"
  },
  {
    "id": "topic9_2",
    "question": "What is the role of destructor function symbols in the system?",
    "options": {
      "A": "Destructor function symbols can only create new terms.",
      "B": "Destructor function symbols can manipulate terms and are defined by rewrite rules.",
      "C": "Destructor function symbols have no specific role and can be used interchangeably with constructors.",
      "D": "Destructor function symbols can only be used in the main process."
    },
    "answer": "B"
  },
  {
    "id": "topic9_3",
    "question": "How are free names declared in an input file?",
    "options": {
      "A": "Free names are declared using the syntax “name n : t”.",
      "B": "Free names are declared using the syntax “free n : t”, where n is a name and t is its type.",
      "C": "Free names are declared without specifying their types.",
      "D": "Free names do not need to be declared in the input file."
    },
    "answer": "B"
  },
  {
    "id": "topic9_4",
    "question": "What does a constant in the system refer to?",
    "options": {
      "A": "A constant is a variable that never changes its value.",
      "B": "A constant can be defined as a function of arity 0, e.g., “fun c() : t” or “const c : t”.",
      "C": "A constant is a special type of constructor.",
      "D": "A constant is a term that contains only destructor function symbols."
    },
    "answer": "B"
  },
  {
    "id": "topic9_5",
    "question": "How are destructors defined in the “reduc” declaration?",
    "options": {
      "A": "Destructors are defined as simple functions without any rules.",
      "B": "Destructors are defined by an ordered list of rewrite rules of the form forall x1,1 : t1,1, ..., x1,n1 : t1,n1 ; g(M1,1, ..., M1,k) = M1,0.",
      "C": "Destructors are defined by a single rule that applies to all cases.",
      "D": "Destructors in the “reduc” declaration are the same as normal destructors and do not have special rules."
    },
    "answer": "B"
  },
  {
    "id": "topic9_6",
    "question": "What happens if no rewrite rule can be applied to a destructor function?",
    "options": {
      "A": "The destructor creates a new term randomly.",
      "B": "The destructor fails.",
      "C": "The system uses a default rewrite rule.",
      "D": "The destructor is treated as a constructor."
    },
    "answer": "B"
  },
  {
    "id": "topic9_7",
    "question": "What are terms in the system?",
    "options": {
      "A": "Terms can only be variables.",
      "B": "Terms can be a variable, a name, or the application of a constructor function symbol to terms.",
      "C": "Terms can only be names representing atomic data.",
      "D": "Terms can only be the result of a destructor operation."
    },
    "answer": "B"
  },
  {
    "id": "topic9_8",
    "question": "Which of the following is a built - in constructor in the system?",
    "options": {
      "A": "not",
      "B": "true",
      "C": "||",
      "D": "-k for each k natural number"
    },
    "answer": "B"
  },
  {
    "id": "topic9_9",
    "question": "How does the “reduc” declaration for destructors differ from the basic destructor definition in Section 3.1.1?",
    "options": {
      "A": "There is no difference between the two definitions.",
      "B": "The “reduc” declaration allows for the definition of new destructors that could not be defined in Section 3.1.1.",
      "C": "The “reduc” declaration only applies to constructors, not destructors.",
      "D": "The “reduc” declaration uses a different syntax but has the same functionality as the basic definition."
    },
    "answer": "B"
  },
  {
    "id": "topic9_10",
    "question": "What does it mean when a destructor is defined by an ordered list of rewrite rules?",
    "options": {
      "A": "All rewrite rules are applied simultaneously to a destructor operation.",
      "B": "ProVerif tries the rewrite rules in the sequence one by one, and if a rule is applicable, the term is reduced according to that rule.",
      "C": "Only the first rewrite rule in the list is ever considered.",
      "D": "Rewrite rules for destructors are randomly selected for application."
    },
    "answer": "B"
  },
  {
    "id": "topic10_1",
    "question": "Which of the following is a valid way to represent a function application in the given expressions?",
    "options": {
      "A": "`h(D1, D2)` where `h` is a function and `D1`, `D2` are expressions.",
      "B": "`D1 + D2` where `D1` and `D2` are expressions (assuming `+` is not allowed in this context).",
      "C": "`f()` where `f` is a function but no arguments are provided (and the function requires arguments).",
      "D": "`(D1, D2)` which is just a tuple and not a function application."
    },
    "answer": "A"
  },
  {
    "id": "topic10_2",
    "question": "When evaluating a function `g(D1,...,Dn)` and no rewrite rule applies, what is the result?",
    "options": {
      "A": "The function keeps evaluating indefinitely.",
      "B": "It evaluates to the constant `fail`.",
      "C": "It evaluates to the first argument `D1`.",
      "D": "It raises an undefined function error."
    },
    "answer": "B"
  },
  {
    "id": "topic10_3",
    "question": "Which of the following is a valid tuple construction according to the given context?",
    "options": {
      "A": "`tupleT1,T2(M1, M2)` where `tupleT1,T2` is a constructor taking arguments of types `T1` and `T2`.",
      "B": "`(M1, M2)` without a proper constructor (not in the defined tuple construction format).",
      "C": "`tuple(M1, M2)` where `tuple` is not a defined constructor in the given rules.",
      "D": "`M1,M2` which is just a list of terms and not a proper tuple construction."
    },
    "answer": "A"
  },
  {
    "id": "topic10_4",
    "question": "An expression can be composed of all of the following except",
    "options": {
      "A": "Variables.",
      "B": "Constants.",
      "C": "Infix symbols that are not allowed in the grammar of terms (e.g., `||` in reduc and equation declarations).",
      "D": "Function calls."
    },
    "answer": "C"
  },
  {
    "id": "topic10_5",
    "question": "If we have a function `g` defined by rewrite rules `g(U1,...,Un) → U`, and `U1,...,Un` are may - fail terms, what does it mean if `U1` is `fail`?",
    "options": {
      "A": "The evaluation of `g(U1,...,Un)` will always succeed and return a valid term.",
      "B": "The evaluation of `g(U1,...,Un)` may fail depending on the rewrite rules.",
      "C": "The evaluation of `g(U1,...,Un)` will always succeed and return `fail`.",
      "D": "The function `g` cannot accept `fail` as an argument."
    },
    "answer": "B"
  },
  {
    "id": "topic10_6",
    "question": "In the expression `h(D1,...,Dk)` where `h` is in `Fd ∪ Fc`, what does `Fd ∪ Fc` represent?",
    "options": {
      "A": "A set of constants.",
      "B": "A set of variables.",
      "C": "A set of function symbols that can be used in function applications.",
      "D": "A set of terms that can be used as operands."
    },
    "answer": "C"
  },
  {
    "id": "topic10_7",
    "question": "Which of the following is a correct way to represent an expression evaluation construct?",
    "options": {
      "A": "`let x: T = D in D′ else D′′`",
      "B": "`let x = D; D′; D′′` (not in the correct format).",
      "C": "`x: T = D; D′; D′′` (not a valid expression evaluation construct).",
      "D": "`let x: T = D D′ D′′` (not in the correct format)."
    },
    "answer": "A"
  },
  {
    "id": "topic10_8",
    "question": "If we have a function `g` with rewrite rules and we want to evaluate `g(D1, D2)`, and the first rewrite rule does not apply, what should we do next?",
    "options": {
      "A": "Stop the evaluation and return `fail`.",
      "B": "Try the second rewrite rule.",
      "C": "Try to apply the first rewrite rule again with different arguments.",
      "D": "Change the function `g` to a different function."
    },
    "answer": "B"
  },
  {
    "id": "topic10_9",
    "question": "A tuple `tupleT1,T2(M1, M2)` is a data structure that",
    "options": {
      "A": "Can only be used in a conditional statement.",
      "B": "Is used to represent a single value of type `bitstring` composed of `M1` and `M2`.",
      "C": "Can only be used in a parallel composition process.",
      "D": "Is not an evaluable unit."
    },
    "answer": "B"
  },
  {
    "id": "topic10_10",
    "question": "In an expression, a variable can be",
    "options": {
      "A": "Only used as an operand in a constant.",
      "B": "Substituted by a term.",
      "C": "Only used in a function call but not as an argument.",
      "D": "Only used in a conditional statement."
    },
    "answer": "B"
  },
  {
    "id": "topic11_1",
    "question": "Which of the following represents the null process in ProVerif?",
    "options": {
      "A": "`!P`",
      "B": "`0`",
      "C": "`P | Q`",
      "D": "`new n : t; P`"
    },
    "answer": "B"
  },
  {
    "id": "topic11_2",
    "question": "In ProVerif, what does the `in(M, x: t); P` construct do?",
    "options": {
      "A": "It outputs the message `M` on the channel `x`.",
      "B": "It inputs a message on the channel `M` and binds it to the variable `x`, then runs `P`.",
      "C": "It creates a new name `n` of type `t` and runs `P`.",
      "D": "It replicates the process `P`."
    },
    "answer": "B"
  },
  {
    "id": "topic11_3",
    "question": "What is the purpose of the `phase n; P` construct in ProVerif?",
    "options": {
      "A": "It creates a new phase of the process `P` without any synchronization.",
      "B": "It acts as a global synchronization; processes not reaching a `phase n` construct with `n ≥ 1` are discarded, and processes starting with `phase 1` run.",
      "C": "It terminates the process `P` when the phase `n` is reached.",
      "D": "It restricts the process `P` to run only in phase `n`."
    },
    "answer": "B"
  },
  {
    "id": "topic11_4",
    "question": "Which construct in ProVerif is used for parallel composition of processes?",
    "options": {
      "A": "`!P`",
      "B": "`P | Q`",
      "C": "`if M then P else Q`",
      "D": "`event(e(M1,...,M n)); P`"
    },
    "answer": "B"
  },
  {
    "id": "topic11_5",
    "question": "In ProVerif, what does the `out(M, N); P` construct represent?",
    "options": {
      "A": "It inputs a message on the channel `M` and binds it to `N`, then runs `P`.",
      "B": "It outputs the message `N` on the channel `M`, then runs `P`.",
      "C": "It creates a new name `N` of type `M` and runs `P`.",
      "D": "It checks if `M` is equal to `N` and then runs `P`."
    },
    "answer": "B"
  },
  {
    "id": "topic11_6",
    "question": "What is the function of the `if M then P else Q` construct in ProVerif?",
    "options": {
      "A": "It always runs both `P` and `Q` regardless of the value of `M`.",
      "B": "It runs `P` if `M` is true, otherwise it runs `Q`.",
      "C": "It creates a new name if `M` is true and runs `P`, otherwise it runs `Q`.",
      "D": "It replicates `P` if `M` is true, otherwise it replicates `Q`."
    },
    "answer": "B"
  },
  {
    "id": "topic11_7",
    "question": "The `new n : t; P` construct in ProVerif is used for:",
    "options": {
      "A": "Outputting a new message `n` of type `t` on the channel `P`.",
      "B": "Inputting a new message `n` of type `t` from the channel `P`.",
      "C": "Restricting the scope of a new name `n` of type `t` within the process `P`.",
      "D": "Replicating the process `P` with a new name `n` of type `t`."
    },
    "answer": "C"
  },
  {
    "id": "topic11_8",
    "question": "In ProVerif, the `!P` construct is used to:",
    "options": {
      "A": "Terminate the process `P`.",
      "B": "Replicate the process `P` indefinitely.",
      "C": "Check if the process `P` is valid.",
      "D": "Create a new phase for the process `P`."
    },
    "answer": "B"
  },
  {
    "id": "topic11_9",
    "question": "Which of the following is an auxiliary event construct in ProVerif used to specify security properties?",
    "options": {
      "A": "`event(e(M1,...,M n)); P`",
      "B": "`begin(M).P`",
      "C": "`phase n; P`",
      "D": "`in(M, x: t); P`"
    },
    "answer": "B"
  },
  {
    "id": "topic11_10",
    "question": "What does the `let x: T = D in D′ else D′′` construct in ProVerif do?",
    "options": {
      "A": "It outputs the value of `D` to the variable `x` of type `T` and then runs `D′` if `D` is valid, otherwise `D′′`.",
      "B": "It inputs a value from `D` and binds it to the variable `x` of type `T`, then runs `D′` if `D` is true, otherwise `D′′`.",
      "C": "It evaluates the expression `D` and binds the result to the variable `x` of type `T`, then runs `D′`; if the evaluation fails, it runs `D′′`.",
      "D": "It creates a new name `x` of type `T` and runs `D′` if `D` is a valid name, otherwise `D′′`."
    },
    "answer": "C"
  },
  {
    "id": "topic12_1",
    "question": "In ProVerif, how are sub - processes specified in the declarations to facilitate development?",
    "options": {
      "A": "By encoding them directly into the main process without any additional syntax.",
      "B": "Using macros of the form let R(x1 : t1, ..., xn : tn) = P.",
      "C": "By writing them as separate functions outside the main code.",
      "D": "By using a special \"sub - process\" keyword."
    },
    "answer": "B"
  },
  {
    "id": "topic12_2",
    "question": "What does the macro expansion R(M1, ..., Mn) do in ProVerif?",
    "options": {
      "A": "It replaces the macro name R with a random value.",
      "B": "It expands to P with M1, ..., Mn substituted for x1, ..., xn respectively.",
      "C": "It deletes the macro definition from the code.",
      "D": "It creates a new macro with the given arguments."
    },
    "answer": "B"
  },
  {
    "id": "topic12_3",
    "question": "In ProVerif, how are user - defined types declared?",
    "options": {
      "A": "Using the syntax type t.",
      "B": "By writing t = type.",
      "C": "By using the \"user - type\" keyword followed by the type name.",
      "D": "There is no way to declare user - defined types."
    },
    "answer": "A"
  },
  {
    "id": "topic12_4",
    "question": "How should free names appearing within an input file in ProVerif be declared?",
    "options": {
      "A": "Using the syntax free n : t.",
      "B": "By just writing the name n without any type specification.",
      "C": "Using the \"free - name\" keyword followed by the name.",
      "D": "They don't need to be declared."
    },
    "answer": "A"
  },
  {
    "id": "topic12_5",
    "question": "What is the purpose of the phase construct in ProVerif?",
    "options": {
      "A": "It is used to define the color scheme of the code for better readability.",
      "B": "It acts as a global synchronization for processes.",
      "C": "It is used to create a new type of process.",
      "D": "It is used to delete old processes from the code."
    },
    "answer": "B"
  },
  {
    "id": "topic12_6",
    "question": "In ProVerif, how can you define a macro for security assumptions on primitives?",
    "options": {
      "A": "By writing macro name(i1, ..., in) = declarations.",
      "B": "By using the def name(i1, ..., in) { declarations } syntax.",
      "C": "By using a \"security - macro\" keyword followed by the name and declarations.",
      "D": "It is not possible to define such macros."
    },
    "answer": "B"
  },
  {
    "id": "topic12_7",
    "question": "What does the macro expansion of name(a1, ..., an) do when name is defined using the def syntax in ProVerif?",
    "options": {
      "A": "It creates a new macro with the arguments a1, ..., an.",
      "B": "It expands to the declarations inside def with a1, ..., an substituted for i1, ..., in.",
      "C": "It deletes the macro definition from the code.",
      "D": "It prints the values of a1, ..., an."
    },
    "answer": "B"
  },
  {
    "id": "topic12_8",
    "question": "In ProVerif, when using the phase construct, what happens when phase 1 starts?",
    "options": {
      "A": "All processes continue running as normal.",
      "B": "All processes that did not reach a phase n construct with n ≥ 1 are discarded, and processes that start with phase 1 run.",
      "C": "All processes are paused until the user manually resumes them.",
      "D": "All processes are deleted from the code."
    },
    "answer": "B"
  },
  {
    "id": "topic12_9",
    "question": "What is the advantage of using process macros in ProVerif?",
    "options": {
      "A": "They make the code run faster.",
      "B": "They are only an encoding useful for development and can be expanded in the main process.",
      "C": "They change the programming language used by ProVerif.",
      "D": "They are required for all protocols in ProVerif."
    },
    "answer": "B"
  },
  {
    "id": "topic12_10",
    "question": "ProVerif uses an abstract representation of protocols by Horn clauses. What is an advantage of this approach?",
    "options": {
      "A": "It guarantees termination in all cases.",
      "B": "It is more precise than tree - automata because it keeps relational information on messages.",
      "C": "It makes the code easier to write without any rules.",
      "D": "It allows for the use of any programming language within ProVerif."
    },
    "answer": "B"
  },
  {
    "id": "topic13_1",
    "question": "In the given content, what is the requirement for using variables F1, ..., Fm, F in clauses?",
    "options": {
      "A": "They can be used without any quantification.",
      "B": "They must be universally quantified by forall x1 : t1, ..., xn : tn.",
      "C": "They only need to be quantified if they are used in a conditional clause.",
      "D": "Quantification is optional for these variables."
    },
    "answer": "B"
  },
  {
    "id": "topic13_2",
    "question": "When F1, ..., Fm, F contain no variables, what can be omitted in the quantification part?",
    "options": {
      "A": "The entire clause.",
      "B": "The part forall x1 : t1, ..., xn : tn.",
      "C": "Only the type identifiers t1, ..., tn.",
      "D": "Nothing can be omitted."
    },
    "answer": "B"
  },
  {
    "id": "topic13_3",
    "question": "In forall x1 : t1, ..., xn : tn, what can the types t1, ..., tn be?",
    "options": {
      "A": "Only a type identifier.",
      "B": "Only of the form t or fail.",
      "C": "Either a type identifier or of the form t or fail.",
      "D": "They must be primitive data types."
    },
    "answer": "C"
  },
  {
    "id": "topic13_4",
    "question": "Consider the process new a:nonce. Where is the name a in terms of variable scope?",
    "options": {
      "A": "It is in the scope of all variables in the process.",
      "B": "It is not in the scope of any variables and is modeled as a[ ].",
      "C": "It is in the scope of some default variables.",
      "D": "Its scope is determined by the next process step."
    },
    "answer": "B"
  },
  {
    "id": "topic13_5",
    "question": "In the process in(c,(x: bitstring ,y: bitstring )); new b:nonce, how is the name b represented?",
    "options": {
      "A": "As b[ ] because it is a new name.",
      "B": "As b[x= M,y=N] where M, N are the values of x and y at run - time.",
      "C": "As b[x, y] without considering their values.",
      "D": "As b[c] because c is the input channel."
    },
    "answer": "B"
  },
  {
    "id": "topic13_6",
    "question": "What is the purpose of annotating restrictions with variables in the internal representation of fresh names?",
    "options": {
      "A": "To make the code look more organized.",
      "B": "To avoid false attacks in the proof of equivalences by ensuring matching names have the same arguments.",
      "C": "To increase the execution speed of the process.",
      "D": "To simplify the variable substitution process."
    },
    "answer": "B"
  },
  {
    "id": "topic13_7",
    "question": "Why is distinct naming of names and variables recommended?",
    "options": {
      "A": "To make the code more concise.",
      "B": "To avoid confusion, especially for new users.",
      "C": "To follow a coding standard.",
      "D": "To reduce the memory usage of the program."
    },
    "answer": "B"
  },
  {
    "id": "topic13_8",
    "question": "What is the ambiguity in the expression if M = M′ then if N = N′ then P else Q?",
    "options": {
      "A": "It is not clear which if the else applies to.",
      "B": "The comparison operators are not standard.",
      "C": "The variables M, M′, N, N′ are not properly declared.",
      "D": "The process P and Q are not well - defined."
    },
    "answer": "A"
  },
  {
    "id": "topic13_9",
    "question": "What can be done to tell ProVerif to take an input into account as precisely as possible?",
    "options": {
      "A": "Add a comment in the code.",
      "B": "Annotate the input with [precise].",
      "C": "Use a specific keyword before the input.",
      "D": "Define the input in a separate file."
    },
    "answer": "B"
  },
  {
    "id": "topic13_10",
    "question": "In the set - to - clause resolution algorithm, how are existing clauses stored?",
    "options": {
      "A": "In a simple list.",
      "B": "In a tree indexed by the function symbols of the selected fact, starting from the root.",
      "C": "In a hash table with variable names as keys.",
      "D": "In a stack data structure."
    },
    "answer": "B"
  },
  {
    "id": "topic14_1",
    "question": "For a destructor \\(g\\) of arity \\(k\\) with rewrite rules, what is the requirement regarding the types of its arguments?",
    "options": {
      "A": "The arguments of \\(g\\) can have different types in each rewrite rule.",
      "B": "The arguments \\(M_{1,1}, \\ldots, M_{1,k}\\) must have the same types as \\(M_{i,1}, \\ldots, M_{i,k}\\) for \\(i \\in [2, m]\\), and these are the types of the arguments of \\(g\\).",
      "C": "Only the first argument \\(M_{1,1}\\) needs to have a consistent type across all rewrite rules.",
      "D": "The types of the arguments are determined by the return type of \\(g\\)."
    },
    "answer": "B"
  },
  {
    "id": "topic14_2",
    "question": "What happens when a destructor \\(g\\) of arity \\(k\\) is encountered during execution and no rewrite rule can be applied?",
    "options": {
      "A": "The program continues execution ignoring the destructor.",
      "B": "The destructor is replaced with a default value.",
      "C": "The destructor fails.",
      "D": "The program tries to find an alternative rewrite rule in a different section of the code."
    },
    "answer": "C"
  },
  {
    "id": "topic14_3",
    "question": "In the context of pattern - matching, if a pattern \\(f(pat_1,\\ldots,pat_n)\\) is used, what condition must hold for it to match a term \\(f(M_1,\\ldots,M_n)\\)?",
    "options": {
      "A": "The pattern can match regardless of whether \\(pat_i\\) matches \\(M_i\\) for \\(i\\leq n\\).",
      "B": "\\(pat_i\\) must match \\(M_i\\) for all \\(i\\leq n\\), and \\(f\\) must be a data constructor.",
      "C": "Only the first \\(pat_1\\) needs to match \\(M_1\\).",
      "D": "\\(f\\) can be any function symbol, not necessarily a data constructor."
    },
    "answer": "B"
  },
  {
    "id": "topic14_4",
    "question": "Regarding the return type of a destructor \\(g\\) defined by rewrite rules, which of the following is true?",
    "options": {
      "A": "The return type can be different for each rewrite rule of \\(g\\).",
      "B": "The return types \\(M_{1,0}, \\ldots, M_{m,0}\\) of all rewrite rules of \\(g\\) must have the same type.",
      "C": "The return type is determined by the type of the first argument of \\(g\\).",
      "D": "The return type is always a built - in type."
    },
    "answer": "B"
  },
  {
    "id": "topic14_5",
    "question": "What does it mean for a destructor to \"fail\" during execution?",
    "options": {
      "A": "The program crashes immediately.",
      "B": "The pattern - matching associated with the destructor fails.",
      "C": "The destructor is re - evaluated with different arguments.",
      "D": "The destructor is replaced with a null value."
    },
    "answer": "B"
  },
  {
    "id": "topic14_6",
    "question": "When defining a destructor using rewrite rules of the form \\(\\forall x_{1,1}:t_{1,1}, \\ldots, x_{1,n_1}:t_{1,n_1}; g(M_{1,1}, \\ldots, M_{1,k}) = M_{1,0}\\), what are the terms \\(M_{1,1}, \\ldots, M_{1,k}, M_{1,0}\\) built from?",
    "options": {
      "A": "They are built from destructor applications only.",
      "B": "They are built from the application of constructors to variables \\(x_{1,1}, \\ldots, x_{1,n_1}\\) of types \\(t_{1,1}, \\ldots, t_{1,n_1}\\) respectively.",
      "C": "They are built from random values.",
      "D": "They are built from a combination of built - in functions only."
    },
    "answer": "B"
  },
  {
    "id": "topic14_7",
    "question": "In the ProVerif language, for a destructor call, what is the requirement for parameter count matching?",
    "options": {
      "A": "The number of parameters can vary in each call.",
      "B": "The number of parameters in the call must match the arity of the destructor.",
      "C": "The number of parameters is determined by the context of the call.",
      "D": "The destructor can accept any number of parameters."
    },
    "answer": "B"
  },
  {
    "id": "topic14_8",
    "question": "What is a key constraint on destructor - function calls regarding type consistency?",
    "options": {
      "A": "Only the first parameter of a destructor call needs to have the correct type.",
      "B": "The types of all parameters in a destructor call must be consistent with the types specified in the rewrite rules.",
      "C": "Type consistency is not a requirement for destructor calls.",
      "D": "The return type of a destructor call does not need to match the types in the rewrite rules."
    },
    "answer": "B"
  },
  {
    "id": "topic14_9",
    "question": "For a data constructor \\(f\\) of arity \\(n\\) with associated destructors \\(g_i\\) for \\(i\\in\\{1,\\ldots,n\\}\\), how are these destructors defined?",
    "options": {
      "A": "\\(g_i\\) can be defined in any way as long as they are related to \\(f\\).",
      "B": "\\(g_i(f(x_1,\\ldots,x_n)) \\to x_i\\).",
      "C": "\\(g_i\\) is defined based on the number of times \\(f\\) is used.",
      "D": "\\(g_i\\) is defined independently of \\(f\\)."
    },
    "answer": "B"
  },
  {
    "id": "topic14_10",
    "question": "If a destructor \\(g\\) has multiple rewrite rules, and an instance of the term \\(g(M_{1,1}, \\ldots, M_{1,k})\\) is encountered during execution, what is the process for handling it?",
    "options": {
      "A": "It is replaced with a random value.",
      "B": "The program tries the first rewrite rule. If it is applicable, the term is reduced according to that rule. Otherwise, it tries the second rewrite rule and so on.",
      "C": "It is always replaced with the first result \\(M_{1,0}\\) from the first rewrite rule.",
      "D": "The program skips all rewrite rules and continues execution."
    },
    "answer": "B"
  },
  {
    "id": "topic15_1",
    "question": "What is ProVerif's most basic capability?",
    "options": {
      "A": "Proving correspondence properties.",
      "B": "Proving reachability properties.",
      "C": "Proving equivalence properties.",
      "D": "Proving authentication properties."
    },
    "answer": "B"
  },
  {
    "id": "topic15_2",
    "question": "To test the secrecy of the term M in the model in ProVerif, what query should be included in the input file before the main process?",
    "options": {
      "A": "query secrecy(M).",
      "B": "query reachable(M).",
      "C": "query attacker(M).",
      "D": "query secure(M)."
    },
    "answer": "C"
  },
  {
    "id": "topic15_3",
    "question": "What does the symbolic model, often called the Dolev - Yao model, consider cryptographic primitives as?",
    "options": {
      "A": "Imperfect blackboxes with random behavior.",
      "B": "Perfect blackboxes modeled by function symbols in an algebra of terms.",
      "C": "Complex algorithms with internal states.",
      "D": "User - defined functions."
    },
    "answer": "B"
  },
  {
    "id": "topic15_4",
    "question": "In the context of ProVerif, which of the following is the main reference for the proof of equivalences?",
    "options": {
      "A": "Blanchet, 2009",
      "B": "Blanchet et al., 2008",
      "C": "Blanchet, 2014",
      "D": "Blanchet, 2016"
    },
    "answer": "B"
  },
  {
    "id": "topic15_5",
    "question": "What does strong secrecy (in the case without equational theory) verified by ProVerif mean?",
    "options": {
      "A": "The adversary can distinguish two versions of the protocol using different secret values.",
      "B": "The secret is always encrypted during the protocol.",
      "C": "The adversary cannot distinguish two versions of the protocol that use different values of the secret.",
      "D": "The secret is shared only between trusted parties."
    },
    "answer": "C"
  },
  {
    "id": "topic15_6",
    "question": "In the symbolic model, what can the adversary compute using?",
    "options": {
      "A": "Any arbitrary algorithm.",
      "B": "Only the cryptographic primitives modeled in the algebra of terms.",
      "C": "Only brute - force methods.",
      "D": "Special encryption keys."
    },
    "answer": "B"
  },
  {
    "id": "topic15_7",
    "question": "Which of the following is the simplest security property ProVerif deals with?",
    "options": {
      "A": "Correspondences",
      "B": "Equivalences",
      "C": "Secrecy",
      "D": "Authentication"
    },
    "answer": "C"
  },
  {
    "id": "topic15_8",
    "question": "What kind of terms can be used in the query \"query attacker(M)\"?",
    "options": {
      "A": "Terms with destructors.",
      "B": "Ground terms without destructors and containing free names.",
      "C": "Non - ground terms.",
      "D": "Terms with complex logical operators."
    },
    "answer": "B"
  },
  {
    "id": "topic15_9",
    "question": "The reference \"Blanchet, B. 2014\" is mainly about?",
    "options": {
      "A": "Automated verification of selected equivalences for security protocols.",
      "B": "Automatic verification of security protocols in the symbolic model: the verifier ProVerif.",
      "C": "Modeling and verifying security protocols with the applied pi calculus and ProVerif.",
      "D": "Secrecy types for asymmetric communication."
    },
    "answer": "B"
  },
  {
    "id": "topic15_10",
    "question": "In the context of ProVerif, when dealing with secrecy, what is the first step in the verification process?",
    "options": {
      "A": "Formalize the notion of an adversary.",
      "B": "Define the cryptographic primitives.",
      "C": "Write the main process in the input file.",
      "D": "Test the equivalence properties."
    },
    "answer": "A"
  },
  {
    "id": "topic16_1",
    "question": "What can be used to capture authentication in the handshake protocol?",
    "options": {
      "A": "Secrecy assertions",
      "B": "Correspondence assertions",
      "C": "Observational equivalence assertions",
      "D": "Privacy assertions"
    },
    "answer": "B"
  },
  {
    "id": "topic16_2",
    "question": "What is the purpose of the handshake protocol regarding authentication?",
    "options": {
      "A": "To ensure the client can communicate with any server",
      "B": "To ensure that if client A thinks she executes the protocol with server B, she really does so",
      "C": "To ensure the server can authenticate multiple clients simultaneously",
      "D": "To ensure the secrecy of the communication between the client and the server"
    },
    "answer": "B"
  },
  {
    "id": "topic16_3",
    "question": "Which of the following is not a security property that ProVerif can verify?",
    "options": {
      "A": "Secrecy",
      "B": "Traceability",
      "C": "Randomness",
      "D": "Authentication"
    },
    "answer": "C"
  },
  {
    "id": "topic16_4",
    "question": "How does ProVerif translate the protocol and security properties to be proved?",
    "options": {
      "A": "It translates them into linear equations",
      "B": "It translates them into an internal representation by Horn clauses",
      "C": "It translates them into a set of differential equations",
      "D": "It translates them into a graphical representation"
    },
    "answer": "B"
  },
  {
    "id": "topic16_5",
    "question": "What does Tamarin need from the user to guide the proof when verifying protocols for an unbounded number of sessions?",
    "options": {
      "A": "Some lemmas",
      "B": "A set of initial values",
      "C": "A graphical model of the protocol",
      "D": "A list of all possible events"
    },
    "answer": "A"
  },
  {
    "id": "topic16_6",
    "question": "Which of the following is an advantage of using correspondence assertions in authentication verification?",
    "options": {
      "A": "They can only be used for simple protocols",
      "B": "They can capture authentication and are useful for analyzing secrecy and authentication properties",
      "C": "They are only applicable to the computational model",
      "D": "They are difficult to represent and verify"
    },
    "answer": "B"
  },
  {
    "id": "topic16_7",
    "question": "When proving properties of the form “if some event e1 has been executed, then some event e2 has or will be executed”, what can the verifier show automatically?",
    "options": {
      "A": "The exact time when e2 will be executed",
      "B": "The correspondence assertion: if e1 has been executed, then some events e′2",
      "C": "The probability of e2 being executed",
      "D": "The sequence of all events between e1 and e2"
    },
    "answer": "B"
  },
  {
    "id": "topic16_8",
    "question": "Which of the following protocols was analyzed by combining manual proofs with ProVerif proofs of correspondences and equivalences?",
    "options": {
      "A": "Certified email protocol",
      "B": "JFK (Just Fast Keying) protocol",
      "C": "Plutus file system protocol",
      "D": "Direct Anonymous Attestation protocol"
    },
    "answer": "B"
  },
  {
    "id": "topic16_9",
    "question": "What did Weidenbach introduce in 1999 regarding protocol verification?",
    "options": {
      "A": "The use of differential equations for protocol verification",
      "B": "The idea of using Horn clauses for verifying protocols",
      "C": "The concept of observational equivalence for authentication",
      "D": "The method of using correspondence assertions for secrecy verification"
    },
    "answer": "B"
  },
  {
    "id": "topic16_10",
    "question": "Canetti and Herzog (2006) showed that for a restricted class of protocols using only public - key encryption, what does a proof in the Dolev - Yao model imply?",
    "options": {
      "A": "Security in the symbolic model",
      "B": "Security in the computational model in the universal composability framework",
      "C": "Security in the observational equivalence model",
      "D": "Security in the correspondence assertion model"
    },
    "answer": "B"
  },
  {
    "id": "topic1_1",
    "question": "What is the applied pi calculus in relation to ProVerif?",
    "options": {
      "A": "A subset of ProVerif's input language.",
      "B": "A dialect of the pi calculus with function symbols defined by an equational theory.",
      "C": "A programming language used to write ProVerif.",
      "D": "A separate verification tool that competes with ProVerif."
    },
    "answer": "B"
  },
  {
    "id": "topic1_2",
    "question": "Which of the following is a feature of the applied pi calculus that ProVerif does not support?",
    "options": {
      "A": "Destructors.",
      "B": "Equational theories.",
      "C": "Functions on terms.",
      "D": "Cryptography."
    },
    "answer": "A"
  },
  {
    "id": "topic1_3",
    "question": "What does ProVerif use in addition to the equational theories of the applied pi calculus?",
    "options": {
      "A": "Constructors.",
      "B": "Destructors.",
      "C": "Equational theories.",
      "D": "Cryptography."
    },
    "answer": "B"
  },
  {
    "id": "topic1_4",
    "question": "How does ProVerif handle errors in the context of the applied pi calculus?",
    "options": {
      "A": "It uses destructors.",
      "B": "It has a built-in error-handling construct.",
      "C": "It does not handle errors.",
      "D": "It relies on external libraries."
    },
    "answer": "B"
  },
  {
    "id": "topic1_5",
    "question": "What type of equivalence does ProVerif prove in practice?",
    "options": {
      "A": "Observational equivalence.",
      "B": "Divergence.",
      "C": "Diﬀ-equivalence.",
      "D": "Equivalence."
    },
    "answer": "C"
  },
  {
    "id": "topic1_6",
    "question": "What is the core of the input language of ProVerif?",
    "options": {
      "A": "The pi calculus.",
      "B": "The applied pi calculus.",
      "C": "The equational theory.",
      "D": "Cryptography."
    },
    "answer": "B"
  },
  {
    "id": "topic1_7",
    "question": "What does ProVerif take as input besides the model of the protocol?",
    "options": {
      "A": "Security properties.",
      "B": "Equational theories.",
      "C": "Destructors.",
      "D": "Functions on terms."
    },
    "answer": "A"
  },
  {
    "id": "topic1_8",
    "question": "Which of the following is a security property that ProVerif can verify?",
    "options": {
      "A": "Secrecy.",
      "B": "Equational theories.",
      "C": "Destructors.",
      "D": "Functions on terms."
    },
    "answer": "A"
  },
  {
    "id": "topic1_9",
    "question": "What is the structure of ProVerif represented by?",
    "options": {
      "A": "A figure.",
      "B": "A table.",
      "C": "An equation.",
      "D": "A list."
    },
    "answer": "A"
  },
  {
    "id": "topic1_10",
    "question": "What is the extension of the applied pi calculus with state called?",
    "options": {
      "A": "The pi calculus.",
      "B": "The applied pi calculus.",
      "C": "The extended applied pi calculus.",
      "D": "The stateful applied pi calculus."
    },
    "answer": "D"
  },
  {
    "id": "topic2_1",
    "question": "What is the primary goal of ProVerif?",
    "options": {
      "A": "To design new cryptographic protocols.",
      "B": "To verify the performance of concurrent programs.",
      "C": "To verify the correctness of mathematical proofs.",
      "D": "To verify cryptographic protocols."
    },
    "answer": "D"
  },
  {
    "id": "topic2_2",
    "question": "Which of the following is NOT a capability of an attacker in the context of ProVerif?",
    "options": {
      "A": "Intercepting messages.",
      "B": "Modifying messages.",
      "C": "Sending arbitrary messages.",
      "D": "Ignoring the communication channels."
    },
    "answer": "D"
  },
  {
    "id": "topic2_3",
    "question": "What type of properties does ProVerif aim to prove for cryptographic protocols?",
    "options": {
      "A": "Only computational properties.",
      "B": "Only functional properties.",
      "C": "Both secrecy and authentication properties.",
      "D": "Only performance properties."
    },
    "answer": "C"
  },
  {
    "id": "topic2_4",
    "question": "In which of the following scenarios would ProVerif be most useful?",
    "options": {
      "A": "Designing a new type of database.",
      "B": "Analyzing the efficiency of a sorting algorithm.",
      "C": "Verifying the security of an email web service.",
      "D": "Optimizing a compiler's code generation."
    },
    "answer": "C"
  },
  {
    "id": "topic2_5",
    "question": "What is the structure of ProVerif based on?",
    "options": {
      "A": "Lambda calculus.",
      "B": "Pi calculus with cryptography.",
      "C": "Turing machines.",
      "D": "Boolean algebra."
    },
    "answer": "B"
  },
  {
    "id": "topic2_6",
    "question": "What is the method ProVerif uses to represent protocols abstractly?",
    "options": {
      "A": "Decision trees.",
      "B": "Horn clauses.",
      "C": "Petri nets.",
      "D": "State machines."
    },
    "answer": "B"
  },
  {
    "id": "topic2_7",
    "question": "Which of the following is NOT a feature of ProVerif?",
    "options": {
      "A": "It can handle an unbounded number of sessions.",
      "B": "It supports many cryptographic primitives.",
      "C": "It is limited to a fixed number of sessions.",
      "D": "It can prove various security properties."
    },
    "answer": "C"
  },
  {
    "id": "topic2_8",
    "question": "What is the approach used by ProVerif to translate protocols and security properties?",
    "options": {
      "A": "It uses a set of if-then rules.",
      "B": "It uses a set of Horn clauses.",
      "C": "It uses a set of first-order logic statements.",
      "D": "It uses a set of decision trees."
    },
    "answer": "B"
  },
  {
    "id": "topic2_9",
    "question": "What is one of the applications of ProVerif mentioned in the text?",
    "options": {
      "A": "Verifying a certified email web service.",
      "B": "Designing a new type of database.",
      "C": "Optimizing a compiler's code generation.",
      "D": "Analyzing the efficiency of a sorting algorithm."
    },
    "answer": "A"
  },
  {
    "id": "topic2_10",
    "question": "What is one of the protocols that ProVerif has been used to analyze?",
    "options": {
      "A": "TLS.",
      "B": "A new type of database.",
      "C": "A compiler's code generation.",
      "D": "A new sorting algorithm."
    },
    "answer": "A"
  },
  {
    "id": "topic3_1",
    "question": "What type of characters can be used in identifiers according to the ProVerif language specifications?",
    "options": {
      "A": "Only letters (a-z, A-Z)",
      "B": "Only digits (0-9)",
      "C": "Letters, digits, underscores, single-quotes, and accented letters from the ISO Latin 1 character set",
      "D": "Special characters and punctuation marks"
    },
    "answer": "C"
  },
  {
    "id": "topic3_2",
    "question": "What is the rule for the first character of an identifier in the ProVerif language?",
    "options": {
      "A": "It must be a digit.",
      "B": "It must be a special character.",
      "C": "It must be a letter.",
      "D": "It can be any character."
    },
    "answer": "C"
  },
  {
    "id": "topic3_3",
    "question": "Are identifiers in the ProVerif language case sensitive?",
    "options": {
      "A": "Yes, identifiers are case sensitive.",
      "B": "No, identifiers are not case sensitive.",
      "C": "Case sensitivity depends on the version of ProVerif.",
      "D": "Case sensitivity is optional and can be toggled by the user."
    },
    "answer": "A"
  },
  {
    "id": "topic3_4",
    "question": "Which of the following is NOT a reserved word in the ProVerif language and can be used as an identifier?",
    "options": {
      "A": "channel",
      "B": "let",
      "C": "new",
      "D": "apple"
    },
    "answer": "D"
  },
  {
    "id": "topic3_5",
    "question": "What is the purpose of the character set rule for identifiers in the ProVerif language?",
    "options": {
      "A": "To ensure compatibility with other programming languages.",
      "B": "To prevent conflicts with reserved words.",
      "C": "To standardize the look and feel of code.",
      "D": "To limit the complexity of the language."
    },
    "answer": "B"
  },
  {
    "id": "topic3_6",
    "question": "What is the significance of the '⟨nat⟩' notation in the ProVerif language?",
    "options": {
      "A": "It represents a set of natural numbers.",
      "B": "It represents a set of integer numbers.",
      "C": "It denotes types for identifiers.",
      "D": "It is used for denoting channels."
    },
    "answer": "A"
  },
  {
    "id": "topic3_7",
    "question": "In the ProVerif language, what is the role of the '⟨typeid⟩' notation?",
    "options": {
      "A": "It denotes types which can be identifiers or the reserved word 'channel'.",
      "B": "It is used to represent natural numbers.",
      "C": "It is used to denote function symbols for constructors and destructors.",
      "D": "It is used to represent integer numbers."
    },
    "answer": "A"
  },
  {
    "id": "topic3_8",
    "question": "What is the correct syntax for declaring a variable in the ProVerif language?",
    "options": {
      "A": "var x;",
      "B": "x : type;",
      "C": "type x;",
      "D": "x = type;"
    },
    "answer": "B"
  },
  {
    "id": "topic3_9",
    "question": "In the ProVerif language, which of the following is NOT a valid way to include comments?",
    "options": {
      "A": "Surrounded by (* and *)",
      "B": "Using // for single-line comments",
      "C": "Nested comments are supported",
      "D": "Surrounded by /* and */"
    },
    "answer": "D"
  },
  {
    "id": "topic3_10",
    "question": "What is the rule for using function symbols in the ProVerif language?",
    "options": {
      "A": "Function symbols can be any sequence of characters.",
      "B": "Function symbols must be declared with their types.",
      "C": "Function symbols are case insensitive.",
      "D": "Function symbols cannot be reused as identifiers."
    },
    "answer": "B"
  },
  {
    "id": "topic4_1",
    "question": "What is the first character of an identifier in the given character set?",
    "options": {
      "A": "A digit (0-9)",
      "B": "A letter (a-z, A-Z)",
      "C": "A special character (e.g., underscore, single-quote)",
      "D": "A reserved word of the language"
    },
    "answer": "B"
  },
  {
    "id": "topic4_2",
    "question": "What is the purpose of ⟨nat⟩ in the given formalism?",
    "options": {
      "A": "To range over natural numbers",
      "B": "To denote types",
      "C": "To represent identifiers",
      "D": "To denote reserved words"
    },
    "answer": "A"
  },
  {
    "id": "topic4_3",
    "question": "What does ⟨int⟩ represent in the given formalism?",
    "options": {
      "A": "Integer numbers (⟨nat⟩ or −⟨nat⟩)",
      "B": "Reserved words of the language",
      "C": "Identifiers",
      "D": "Types"
    },
    "answer": "A"
  },
  {
    "id": "topic4_4",
    "question": "What is the role of ⟨typeid⟩ in the given formalism?",
    "options": {
      "A": "To denote types",
      "B": "To represent identifiers",
      "C": "To denote reserved words",
      "D": "To range over natural numbers"
    },
    "answer": "A"
  },
  {
    "id": "topic4_5",
    "question": "In the given formalism, what is the allowed sequence of identifiers in ⟨options⟩?",
    "options": {
      "A": "[seq+⟨ident⟩]",
      "B": "[seq+⟨nat⟩]",
      "C": "[seq+⟨gterm⟩]",
      "D": "[seq+⟨typeid⟩]"
    },
    "answer": "A"
  },
  {
    "id": "topic4_6",
    "question": "What is the precedence of the infix symbol '==' in the given formalism?",
    "options": {
      "A": "The lowest",
      "B": "The highest",
      "C": "Between '||' and '&&'",
      "D": "Between '=<' and '>'"
    },
    "answer": "D"
  },
  {
    "id": "topic4_7",
    "question": "In the given formalism, what is the meaning of ⟨gterm⟩?",
    "options": {
      "A": "A sequence of identifiers",
      "B": "A sequence of natural numbers",
      "C": "A general term that can be an identifier, a function application, or an event",
      "D": "A type declaration"
    },
    "answer": "C"
  },
  {
    "id": "topic4_8",
    "question": "What is the purpose of ⟨pattern⟩ in the given formalism?",
    "options": {
      "A": "To represent a sequence of identifiers",
      "B": "To denote types",
      "C": "To represent a pattern that can be an identifier, a type, a natural number, or a combination of these",
      "D": "To denote reserved words"
    },
    "answer": "C"
  },
  {
    "id": "topic4_9",
    "question": "What is the meaning of ⟨mayfailterm⟩ in the given formalism?",
    "options": {
      "A": "A term that may fail",
      "B": "A sequence of identifiers",
      "C": "A type declaration",
      "D": "A general term"
    },
    "answer": "A"
  },
  {
    "id": "topic4_10",
    "question": "In the given formalism, what is the purpose of ⟨typedecl⟩?",
    "options": {
      "A": "To declare a sequence of identifiers with a type",
      "B": "To denote reserved words",
      "C": "To represent a general term",
      "D": "To represent a pattern"
    },
    "answer": "A"
  },
  {
    "id": "topic5_1",
    "question": "Which of the following is a reserved word in the ProVerif language and cannot be used as an identifier?",
    "options": {
      "A": "variable",
      "B": "function",
      "C": "channel",
      "D": "pattern"
    },
    "answer": "C"
  },
  {
    "id": "topic5_2",
    "question": "In ProVerif, what do names particularly represent?",
    "options": {
      "A": "Functions",
      "B": "Random numbers",
      "C": "Principals",
      "D": "Messages"
    },
    "answer": "B"
  },
  {
    "id": "topic5_3",
    "question": "According to the usage heuristics in ProVerif, which of the following yields better performance than equations?",
    "options": {
      "A": "Using destructors",
      "B": "Using equations",
      "C": "Using conditionals",
      "D": "Using replication"
    },
    "answer": "A"
  },
  {
    "id": "topic5_4",
    "question": "How can the precision and cost of the analysis in ProVerif be tuned?",
    "options": {
      "A": "By adjusting the arguments of patterns that represent names",
      "B": "By changing the syntax tree structure",
      "C": "By modifying the destructors",
      "D": "By altering the operational semantics"
    },
    "answer": "A"
  },
  {
    "id": "topic5_5",
    "question": "What is the default behavior in ProVerif when testing whether the attacker can compute the value of x?",
    "options": {
      "A": "It checks if the attacker can distinguish x from a fresh random value",
      "B": "It checks if the attacker can compute the value of x",
      "C": "It ignores the value of x",
      "D": "It assumes x is always a random value"
    },
    "answer": "B"
  },
  {
    "id": "topic5_6",
    "question": "In ProVerif, what is the only destructor defined by the language?",
    "options": {
      "A": "equal",
      "B": "destructor",
      "C": "not",
      "D": "diff"
    },
    "answer": "A"
  },
  {
    "id": "topic5_7",
    "question": "What is the structural equivalence relation used in ProVerif to prepare processes for reduction?",
    "options": {
      "A": "→⋄",
      "B": "≡",
      "C": "⋄≡",
      "D": "→"
    },
    "answer": "B"
  },
  {
    "id": "topic5_8",
    "question": "What does the setting 'set predicatesImplementable = check' do in ProVerif?",
    "options": {
      "A": "It turns off the check for implementable predicate calls",
      "B": "It turns on the check for implementable predicate calls",
      "C": "It sets the default value for predicate calls",
      "D": "It defines the behavior of predicate calls"
    },
    "answer": "B"
  },
  {
    "id": "topic5_9",
    "question": "In ProVerif, what is the effect of setting 'set allowDiffPatterns = false'?",
    "options": {
      "A": "It allows the use of diff patterns",
      "B": "It disallows the use of diff patterns",
      "C": "It changes the syntax tree structure",
      "D": "It modifies the operational semantics"
    },
    "answer": "B"
  },
  {
    "id": "topic5_10",
    "question": "What does the setting 'set movenew = true' do in ProVerif?",
    "options": {
      "A": "It moves fresh names to the most precise location",
      "B": "It leaves fresh names where the user has put them",
      "C": "It changes the cost of the analysis",
      "D": "It modifies the destructors"
    },
    "answer": "A"
  },
  {
    "id": "topic6_1",
    "question": "What does the notation ⟨X⟩ represent in the context of the given grammar?",
    "options": {
      "A": "A sequence of one or more elements of X separated by commas.",
      "B": "A single element of X.",
      "C": "A sequence of zero or more elements of X.",
      "D": "A sequence of exactly two elements of X."
    },
    "answer": "A"
  },
  {
    "id": "topic6_2",
    "question": "What is the purpose of the symbols (* and *) in the given content?",
    "options": {
      "A": "They are used to denote comments in the input files.",
      "B": "They are used to represent the start and end of a sequence.",
      "C": "They are used to denote the beginning and end of a function.",
      "D": "They are used to represent the start and end of a conditional statement."
    },
    "answer": "A"
  },
  {
    "id": "topic6_3",
    "question": "In the given grammar, what does the notation seq+⟨X⟩ represent?",
    "options": {
      "A": "A sequence of one or more elements of X.",
      "B": "A sequence of zero or more elements of X.",
      "C": "A sequence of exactly two elements of X.",
      "D": "A sequence of elements of X separated by commas."
    },
    "answer": "A"
  },
  {
    "id": "topic6_4",
    "question": "What is the first character of an identifier in the given grammar?",
    "options": {
      "A": "A digit.",
      "B": "An underscore.",
      "C": "A letter.",
      "D": "A single-quote."
    },
    "answer": "C"
  },
  {
    "id": "topic6_5",
    "question": "What is the meaning of the notation ⟨failtypedecl⟩ in the given grammar?",
    "options": {
      "A": "A type declaration that can fail.",
      "B": "A type declaration that must fail.",
      "C": "A sequence of type declarations that can fail.",
      "D": "A sequence of type declarations that must fail."
    },
    "answer": "C"
  },
  {
    "id": "topic6_6",
    "question": "In the given grammar, what is the precedence of the infix symbol '=='?",
    "options": {
      "A": "It has the lowest precedence.",
      "B": "It has a higher precedence than '||' and '&&'.",
      "C": "It has the same precedence as '||' and '&&'.",
      "D": "It has a lower precedence than '||' and '&&'."
    },
    "answer": "B"
  },
  {
    "id": "topic6_7",
    "question": "What is the meaning of the notation ⟨gterm⟩ in the given grammar?",
    "options": {
      "A": "A general term that can be a constructor or a destructor.",
      "B": "A general term that can be a constructor.",
      "C": "A general term that can be a destructor.",
      "D": "A general term that cannot be a constructor or a destructor."
    },
    "answer": "A"
  },
  {
    "id": "topic6_8",
    "question": "In the given grammar, what is the purpose of the notation ⟨ident⟩?",
    "options": {
      "A": "It represents a sequence of identifiers.",
      "B": "It represents a single identifier.",
      "C": "It represents a sequence of function symbols.",
      "D": "It represents a sequence of type declarations."
    },
    "answer": "B"
  },
  {
    "id": "topic6_9",
    "question": "What is the meaning of the notation ⟨nat⟩ in the given grammar?",
    "options": {
      "A": "It represents natural numbers.",
      "B": "It represents integer numbers.",
      "C": "It represents types.",
      "D": "It represents identifiers."
    },
    "answer": "A"
  },
  {
    "id": "topic6_10",
    "question": "In the given grammar, what is the purpose of the notation ⟨int⟩?",
    "options": {
      "A": "It represents natural numbers.",
      "B": "It represents integer numbers.",
      "C": "It represents types.",
      "D": "It represents identifiers."
    },
    "answer": "B"
  },
  {
    "id": "topic7_1",
    "question": "Which of the following is a reserved word in the ProVerif language and cannot be used as an identifier?",
    "options": {
      "A": "protocol",
      "B": "channel",
      "C": "function",
      "D": "variable"
    },
    "answer": "B"
  },
  {
    "id": "topic7_2",
    "question": "In ProVerif, what does the syntax 'out(N,M); P' represent?",
    "options": {
      "A": "An input operation where N is the name and M is the message.",
      "B": "An output operation where N is the name and M is the message.",
      "C": "A parallel composition of processes.",
      "D": "A conditional statement."
    },
    "answer": "B"
  },
  {
    "id": "topic7_3",
    "question": "What type of values does the type 'bool' in ProVerif represent?",
    "options": {
      "A": "Boolean values",
      "B": "Bitstrings",
      "C": "Channels",
      "D": "Natural numbers"
    },
    "answer": "A"
  },
  {
    "id": "topic7_4",
    "question": "What is the purpose of the 'new' keyword in ProVerif?",
    "options": {
      "A": "To define a new protocol",
      "B": "To create a new channel",
      "C": "To restrict the scope of a name",
      "D": "To generate a fresh name"
    },
    "answer": "D"
  },
  {
    "id": "topic7_5",
    "question": "In ProVerif, what does the syntax 'in(N,x); P' represent?",
    "options": {
      "A": "An output operation where N is the name and x is the variable.",
      "B": "An input operation where N is the name and x is the variable.",
      "C": "A parallel composition of processes.",
      "D": "A conditional statement."
    },
    "answer": "B"
  },
  {
    "id": "topic7_6",
    "question": "What is the role of spaces in ProVerif syntax?",
    "options": {
      "A": "They are used to separate keywords and identifiers.",
      "B": "They are used to indicate comments.",
      "C": "They are used to define the scope of variables.",
      "D": "They are not significant and can be ignored."
    },
    "answer": "A"
  },
  {
    "id": "topic7_7",
    "question": "What is the role of tabs in ProVerif syntax?",
    "options": {
      "A": "They are used to separate keywords and identifiers.",
      "B": "They are used to indicate comments.",
      "C": "They are used to define the scope of variables.",
      "D": "They are not significant and can be ignored."
    },
    "answer": "D"
  },
  {
    "id": "topic7_8",
    "question": "What is the role of newline characters in ProVerif syntax?",
    "options": {
      "A": "They are used to separate keywords and identifiers.",
      "B": "They are used to indicate comments.",
      "C": "They are used to define the scope of variables.",
      "D": "They are significant and used to separate statements."
    },
    "answer": "D"
  },
  {
    "id": "topic7_9",
    "question": "In ProVerif, what does the syntax 'P | Q' represent?",
    "options": {
      "A": "A conditional statement.",
      "B": "A parallel composition of processes P and Q.",
      "C": "A restriction of process P.",
      "D": "An assignment of process Q to variable P."
    },
    "answer": "B"
  },
  {
    "id": "topic7_10",
    "question": "What is the purpose of the 'let x= D in P else Q' construct in ProVerif?",
    "options": {
      "A": "To define a new protocol",
      "B": "To create a conditional assignment where x is assigned the value of D in process P, otherwise Q is executed.",
      "C": "To restrict the scope of a name",
      "D": "To generate a fresh name"
    },
    "answer": "B"
  },
  {
    "id": "topic8_1",
    "question": "In ProVerif, what is the correct way to define a constant?",
    "options": {
      "A": "Using the keyword `var` followed by the constant name and type.",
      "B": "Using the keyword `const` followed by the constant name and type.",
      "C": "Using the keyword `def` followed by the constant name and type.",
      "D": "Constants are implicitly defined and do not require a declaration."
    },
    "answer": "B"
  },
  {
    "id": "topic8_2",
    "question": "What is the role of identifiers such as a, b, c, k in ProVerif?",
    "options": {
      "A": "They represent variables that can be substituted by terms.",
      "B": "They represent atomic data, such as keys and nonces.",
      "C": "They are used to declare destructors.",
      "D": "They are used to declare user-defined types."
    },
    "answer": "B"
  },
  {
    "id": "topic8_3",
    "question": "What is the purpose of the `type` keyword in ProVerif declarations?",
    "options": {
      "A": "It is used to declare destructors for a given type.",
      "B": "It is used to declare a new user-defined type.",
      "C": "It is used to associate a type with a function symbol.",
      "D": "It is used to declare the arity of a function."
    },
    "answer": "B"
  },
  {
    "id": "topic8_4",
    "question": "In ProVerif, which of the following is NOT a built-in type?",
    "options": {
      "A": "bitstring",
      "B": "nat",
      "C": "bool",
      "D": "integer"
    },
    "answer": "D"
  },
  {
    "id": "topic8_5",
    "question": "What is the correct syntax for declaring a function symbol in ProVerif?",
    "options": {
      "A": "fun h(T1,...,Tn) : T",
      "B": "function h(T1,...,Tn) : T",
      "C": "symbol h(T1,...,Tn) : T",
      "D": "h(T1,...,Tn) : T"
    },
    "answer": "A"
  },
  {
    "id": "topic8_6",
    "question": "What is the purpose of the `free` keyword in ProVerif declarations?",
    "options": {
      "A": "It is used to declare a constant.",
      "B": "It is used to declare a destructor.",
      "C": "It is used to declare a function symbol.",
      "D": "It is used to declare a name that is not bound to any process."
    },
    "answer": "D"
  },
  {
    "id": "topic8_7",
    "question": "In ProVerif, which of the following is NOT a valid option for declarations?",
    "options": {
      "A": "options",
      "B": "private",
      "C": "memberOptim",
      "D": "public"
    },
    "answer": "D"
  },
  {
    "id": "topic8_8",
    "question": "What is the role of variables (e.g., x, y, z) in ProVerif?",
    "options": {
      "A": "They represent atomic data, such as keys and nonces.",
      "B": "They can be substituted by terms.",
      "C": "They are used to declare destructors.",
      "D": "They are used to declare user-defined types."
    },
    "answer": "B"
  },
  {
    "id": "topic8_9",
    "question": "In ProVerif, what is the correct way to declare a list of free names of the same type?",
    "options": {
      "A": "By using a comma-separated list within parentheses.",
      "B": "By using a plus sign (+) followed by the type.",
      "C": "By using a semicolon-separated list within square brackets.",
      "D": "By using a pipe symbol (|) followed by the type."
    },
    "answer": "A"
  },
  {
    "id": "topic8_10",
    "question": "What is the purpose of the `process` keyword in ProVerif?",
    "options": {
      "A": "It is used to declare a new user-defined type.",
      "B": "It is used to define a main process.",
      "C": "It is used to declare a function symbol.",
      "D": "It is used to declare a destructor."
    },
    "answer": "B"
  },
  {
    "id": "topic9_1",
    "question": "What do identifiers a, b, c, k represent in the context of process declarations?",
    "options": {
      "A": "Variables that can be substituted by terms.",
      "B": "Atomic data such as keys and nonces.",
      "C": "Function symbols for constructors and destructors.",
      "D": "User-defined types."
    },
    "answer": "B"
  },
  {
    "id": "topic9_2",
    "question": "What is the purpose of declaring names and variables with their type?",
    "options": {
      "A": "To enforce a strongly typed language.",
      "B": "To allow for polymorphism.",
      "C": "To enable type inference.",
      "D": "To reduce the number of function symbols."
    },
    "answer": "A"
  },
  {
    "id": "topic9_3",
    "question": "Which symbol is commonly used for a constructor function in the given syntax?",
    "options": {
      "A": "g",
      "B": "h",
      "C": "f",
      "D": "c"
    },
    "answer": "C"
  },
  {
    "id": "topic9_4",
    "question": "What is the syntax for declaring a user-defined type in the language?",
    "options": {
      "A": "type t.",
      "B": "newtype t.",
      "C": "define t.",
      "D": "typedef t."
    },
    "answer": "A"
  },
  {
    "id": "topic9_5",
    "question": "How can multiple free names of the same type be declared in the syntax?",
    "options": {
      "A": "By using a loop in the code.",
      "B": "By using a single declaration with a list of names.",
      "C": "By repeating the declaration for each name.",
      "D": "The text does not specify a method for declaring multiple names of the same type."
    },
    "answer": "B"
  },
  {
    "id": "topic9_6",
    "question": "What is a destructor function symbol in the context of the given content?",
    "options": {
      "A": "A function symbol that manipulates terms and appears only in expressions.",
      "B": "A function symbol that is used to construct terms.",
      "C": "A variable that can be substituted by terms.",
      "D": "A type that represents atomic data."
    },
    "answer": "A"
  },
  {
    "id": "topic9_7",
    "question": "What is the role of rewrite rules in defining the behavior of a destructor function symbol?",
    "options": {
      "A": "They are used to define functions from terms to terms.",
      "B": "They are used to define the main process.",
      "C": "They are used to model cryptographic operations.",
      "D": "They are used to define user-defined types."
    },
    "answer": "A"
  },
  {
    "id": "topic9_8",
    "question": "What is a constant in the context of the given formalism?",
    "options": {
      "A": "A function of arity 0.",
      "B": "A destructor function symbol.",
      "C": "A variable that cannot be changed.",
      "D": "A constructor function symbol."
    },
    "answer": "A"
  },
  {
    "id": "topic9_9",
    "question": "What is the purpose of extended destructors in the given content?",
    "options": {
      "A": "To define the behavior of destructors using rewrite rules.",
      "B": "To overcome the limitations of representing modular exponentiation.",
      "C": "To provide a small library of cryptographic primitives.",
      "D": "To model the relationships between cryptographic operations."
    },
    "answer": "A"
  },
  {
    "id": "topic9_10",
    "question": "What is the nil process in the context of the given content?",
    "options": {
      "A": "A process that does nothing.",
      "B": "A process that represents failure.",
      "C": "A process that is always true.",
      "D": "A process that is the inverse of a destructor."
    },
    "answer": "A"
  },
  {
    "id": "topic10_1",
    "question": "What is the definition of a ground term in the context of expressions?",
    "options": {
      "A": "A term that contains variables.",
      "B": "A term that contains no variable.",
      "C": "A term that is always equal to fail.",
      "D": "A term that represents a computation failure."
    },
    "answer": "B"
  },
  {
    "id": "topic10_2",
    "question": "In ProVerif, what does the evaluation relation D⇓V signify?",
    "options": {
      "A": "The ground expression D evaluates to the value V.",
      "B": "The value V evaluates to the ground expression D.",
      "C": "The process D evaluates to the value V.",
      "D": "The value V evaluates to the process D."
    },
    "answer": "A"
  },
  {
    "id": "topic10_3",
    "question": "Which of the following is an example of a term that can be evaluated using the core calculus?",
    "options": {
      "A": "A variable.",
      "B": "A function call.",
      "C": "A tuple construction.",
      "D": "All of the above."
    },
    "answer": "D"
  },
  {
    "id": "topic10_4",
    "question": "What is the purpose of introducing additional expression evaluations in ProVerif?",
    "options": {
      "A": "To simplify the syntax of expressions.",
      "B": "To allow expressions to contain constructs from processes.",
      "C": "To restrict the use of variables in expressions.",
      "D": "To prevent the evaluation of expressions."
    },
    "answer": "B"
  },
  {
    "id": "topic10_5",
    "question": "In the syntax of processes, what does the construct 'out(D,D′); P' represent?",
    "options": {
      "A": "An input operation with pattern matching.",
      "B": "An output operation with two expressions.",
      "C": "A conditional operation with two expressions.",
      "D": "A parallel composition of processes."
    },
    "answer": "B"
  },
  {
    "id": "topic10_6",
    "question": "What is the role of the 'fail' constant in expressions?",
    "options": {
      "A": "It represents a successful computation.",
      "B": "It represents the failure of a computation.",
      "C": "It is used to indicate a variable.",
      "D": "It is used to represent a ground term."
    },
    "answer": "B"
  },
  {
    "id": "topic10_7",
    "question": "In ProVerif, which of the following is not allowed in 'reduc' and 'equation' declarations?",
    "options": {
      "A": "Constructors.",
      "B": "Infix symbols.",
      "C": "The 'fail' constant.",
      "D": "Names as function symbols."
    },
    "answer": "D"
  },
  {
    "id": "topic10_8",
    "question": "What is the term 'new a: T; M' used for in ProVerif?",
    "options": {
      "A": "To declare a new variable 'a' of type 'T'.",
      "B": "To construct a new tuple of type 'T'.",
      "C": "To create a new name 'a' of type 'T' and evaluate the term 'M'.",
      "D": "To assign the value of 'M' to the variable 'a'."
    },
    "answer": "C"
  },
  {
    "id": "topic10_9",
    "question": "What is the syntax for pattern-matching in input and expression evaluation constructs?",
    "options": {
      "A": "in(D,pat); P",
      "B": "let pat = D in P else Q",
      "C": "Both A and B",
      "D": "Neither A nor B"
    },
    "answer": "C"
  },
  {
    "id": "topic10_10",
    "question": "What is the precedence order for infix symbols in the ProVerif core language?",
    "options": {
      "A": "=, <>, <=, >=, <, >, +, -",
      "B": "||, &&, =, <>, <=, >=, <, >, +, -",
      "C": "+, -, =, <>, <=, >=, <, >, ||, &&",
      "D": "Both A and B"
    },
    "answer": "B"
  },
  {
    "id": "topic11_1",
    "question": "What is a constant in the context of ProVerif's input language?",
    "options": {
      "A": "A variable that can change its value during execution.",
      "B": "A function with arity 0.",
      "C": "A process that does nothing.",
      "D": "A special type of destructor."
    },
    "answer": "B"
  },
  {
    "id": "topic11_2",
    "question": "Which of the following is a specific construct for constants in ProVerif?",
    "options": {
      "A": "`var c : t`",
      "B": "`fun c() : t`",
      "C": "`const c : t`",
      "D": "`proc c : t`"
    },
    "answer": "C"
  },
  {
    "id": "topic11_3",
    "question": "In ProVerif, what is the nil process represented by?",
    "options": {
      "A": "A process that performs a specific task.",
      "B": "A process that does nothing.",
      "C": "A process that represents an error state.",
      "D": "A process that terminates immediately."
    },
    "answer": "B"
  },
  {
    "id": "topic11_4",
    "question": "What does the syntax of terms and processes in ProVerif's input language assume?",
    "options": {
      "A": "A set of symbols for constructors and destructors.",
      "B": "A set of symbols for variables and names.",
      "C": "A set of symbols for control flow statements.",
      "D": "A set of symbols for input and output operations."
    },
    "answer": "A"
  },
  {
    "id": "topic11_5",
    "question": "How does ProVerif handle the limitation of representing modular exponentiation in its framework?",
    "options": {
      "A": "It uses destructors defined by rewrite rules.",
      "B": "It supports equations as explained in §2.5.1.",
      "C": "It uses the nil process to overcome the limitation.",
      "D": "It cannot represent modular exponentiation."
    },
    "answer": "B"
  },
  {
    "id": "topic11_6",
    "question": "What is the purpose of process macros in ProVerif?",
    "options": {
      "A": "To define destructors for cryptographic primitives.",
      "B": "To ease the development by allowing sub-processes to be defined.",
      "C": "To model the handshake protocol.",
      "D": "To represent atomic data such as keys and nonces."
    },
    "answer": "B"
  },
  {
    "id": "topic11_7",
    "question": "What does the phase construct in ProVerif represent?",
    "options": {
      "A": "A local synchronization between processes.",
      "B": "A global synchronization that increments phases.",
      "C": "A way to model different stages of a protocol.",
      "D": "A construct to represent the end of a process."
    },
    "answer": "C"
  },
  {
    "id": "topic11_8",
    "question": "In ProVerif, what is the purpose of the event construct?",
    "options": {
      "A": "To execute a certain program point with specific values.",
      "B": "To record that a certain program point has been reached.",
      "C": "To model the input on a channel.",
      "D": "To represent the output of a message."
    },
    "answer": "B"
  },
  {
    "id": "topic11_9",
    "question": "How does ProVerif internally evaluate a [Query] provided by the user?",
    "options": {
      "A": "By proving that a state in which a property is violated is reachable.",
      "B": "By attempting to reconstruct a violated property.",
      "C": "By proving that a state in which a property is violated is unreachable.",
      "D": "By directly executing the query without analysis."
    },
    "answer": "C"
  },
  {
    "id": "topic11_10",
    "question": "What is the role of auxiliary events in ProVerif's process calculus?",
    "options": {
      "A": "To execute specific program points with values.",
      "B": "To model the input and output operations.",
      "C": "To specify security properties related to the execution of events.",
      "D": "To represent the termination of a process."
    },
    "answer": "C"
  },
  {
    "id": "topic12_1",
    "question": "What is the purpose of process macros in ProVerif?",
    "options": {
      "A": "To encode the behavior of cryptographic primitives.",
      "B": "To define sub-processes to ease development.",
      "C": "To model the registration phase of a protocol.",
      "D": "To represent the abstract representation of protocols by Horn clauses."
    },
    "answer": "B"
  },
  {
    "id": "topic12_2",
    "question": "In ProVerif, how are sub-processes defined?",
    "options": {
      "A": "By using a single main process.",
      "B": "By using process macros of the form let R(x1 : t1, ..., xn : tn) = P.",
      "C": "By using the phase construct.",
      "D": "By using the typed pi calculus."
    },
    "answer": "B"
  },
  {
    "id": "topic12_3",
    "question": "What is the role of free variables in process macros?",
    "options": {
      "A": "They are used to represent the type of the macro.",
      "B": "They are used to represent the name of the macro.",
      "C": "They are used to represent the parameters of the sub-process being defined.",
      "D": "They are used to represent the return value of the sub-process."
    },
    "answer": "C"
  },
  {
    "id": "topic12_4",
    "question": "How does the macro expansion R(M1, ..., Mn) work in ProVerif?",
    "options": {
      "A": "It expands to P with M1, ..., Mn substituted for x1, ..., xn.",
      "B": "It expands to P with x1, ..., xn substituted for M1, ..., Mn.",
      "C": "It expands to P with M1, ..., Mn substituted for t1, ..., tn.",
      "D": "It expands to P with t1, ..., tn substituted for M1, ..., Mn."
    },
    "answer": "A"
  },
  {
    "id": "topic12_5",
    "question": "What is the purpose of the phase construct in ProVerif?",
    "options": {
      "A": "To model the registration phase of a protocol.",
      "B": "To model global synchronization in protocols.",
      "C": "To define sub-processes.",
      "D": "To represent the abstract representation of protocols."
    },
    "answer": "B"
  },
  {
    "id": "topic12_6",
    "question": "In ProVerif, what happens when a phase n construct is reached?",
    "options": {
      "A": "All processes that did not reach phase n are discarded.",
      "B": "All processes that did not reach phase n are expanded.",
      "C": "All processes that did not reach phase n are merged.",
      "D": "All processes that did not reach phase n are ignored."
    },
    "answer": "A"
  },
  {
    "id": "topic12_7",
    "question": "What is the purpose of the def construct in ProVerif?",
    "options": {
      "A": "To define process macros.",
      "B": "To define the security assumptions on primitives.",
      "C": "To define the behavior of cryptographic primitives.",
      "D": "To define the registration phase of a protocol."
    },
    "answer": "B"
  },
  {
    "id": "topic12_8",
    "question": "How are user-defined types declared in ProVerif?",
    "options": {
      "A": "Using the syntax type t.",
      "B": "Using the syntax free n : t.",
      "C": "Using the syntax let R(x1 : t1, ..., xn : tn) = P.",
      "D": "Using the syntax def name(i1, ..., in) {declarations}."
    },
    "answer": "A"
  },
  {
    "id": "topic12_9",
    "question": "What is the purpose of the \"at {n}\" annotation in ProVerif?",
    "options": {
      "A": "To indicate the program point between braces in the process.",
      "B": "To indicate the location of a variable in the process.",
      "C": "To indicate the copy of the process where an event is executed.",
      "D": "To indicate the scope of a variable."
    },
    "answer": "C"
  },
  {
    "id": "topic12_10",
    "question": "What is the abstract representation of protocols used by ProVerif?",
    "options": {
      "A": "Tree-automata.",
      "B": "Horn clauses.",
      "C": "Typed pi calculus.",
      "D": "ProVerif's own language."
    },
    "answer": "B"
  },
  {
    "id": "topic13_1",
    "question": "In the context of process declarations, what is the requirement for variables and names before they are used?",
    "options": {
      "A": "They can be used without any declaration.",
      "B": "They must be declared with their types before use.",
      "C": "They are automatically inferred and do not require declaration.",
      "D": "Declaration is only necessary if they are used in a loop."
    },
    "answer": "B"
  },
  {
    "id": "topic13_2",
    "question": "What is the purpose of the 'forall' quantifier in the context of variables in process declarations?",
    "options": {
      "A": "It is used to define the scope of variables.",
      "B": "It is used to declare the type of variables.",
      "C": "It is used to indicate that variables are universally quantified.",
      "D": "It is used to specify the order of variables in a process."
    },
    "answer": "C"
  },
  {
    "id": "topic13_3",
    "question": "When can the 'forall x1 : t1, ..., xn : tn;' part be omitted in a process declaration?",
    "options": {
      "A": "When the variables are locally scoped.",
      "B": "When the variables are not used in the process.",
      "C": "When F1, ..., Fm, F contain no variables.",
      "D": "When the variables are of a specific, predefined type."
    },
    "answer": "C"
  },
  {
    "id": "topic13_4",
    "question": "What does the special value 'fail' represent in the context of types?",
    "options": {
      "A": "A successful operation.",
      "B": "An error state that can be taken by a variable.",
      "C": "A variable that has not been initialized.",
      "D": "A type that is not allowed in the process."
    },
    "answer": "B"
  },
  {
    "id": "topic13_5",
    "question": "What is the significance of the scope of a name in a process?",
    "options": {
      "A": "It determines the visibility of the name within the process.",
      "B": "It has no impact on the process behavior.",
      "C": "It is used to calculate the efficiency of the process.",
      "D": "It is used to determine the process's termination."
    },
    "answer": "A"
  },
  {
    "id": "topic13_6",
    "question": "What is the recommended practice to avoid confusion between names and variables?",
    "options": {
      "A": "Using the same naming convention for both.",
      "B": "Annotating both with their types.",
      "C": "Using distinct naming for names and variables.",
      "D": "Omitting the declaration of either names or variables."
    },
    "answer": "C"
  },
  {
    "id": "topic13_7",
    "question": "What is the role of the 'free' keyword in process declarations?",
    "options": {
      "A": "It is used to declare variables that can take any value.",
      "B": "It is used to declare names that are not bound to any specific value.",
      "C": "It is used to release memory allocated to a variable.",
      "D": "It is used to declare functions that can be freely used."
    },
    "answer": "B"
  },
  {
    "id": "topic13_8",
    "question": "What is the purpose of annotating restrictions with variables in the internal representation of fresh names?",
    "options": {
      "A": "To ensure that the names are globally unique.",
      "B": "To avoid false attacks due to mismatched arguments in biprocess components.",
      "C": "To optimize the process execution speed.",
      "D": "To limit the scope of the names to specific variables."
    },
    "answer": "B"
  },
  {
    "id": "topic13_9",
    "question": "What is the effect of omitting 'else 0' in the if-then-else construct?",
    "options": {
      "A": "It causes the else clause to apply to the entire if statement.",
      "B": "It makes the else clause apply only to the most recent if statement.",
      "C": "It results in a syntax error.",
      "D": "It has no effect on the process behavior."
    },
    "answer": "B"
  },
  {
    "id": "topic13_10",
    "question": "What is the significance of the 'precise' annotation in input to ProVerif?",
    "options": {
      "A": "It tells ProVerif to ignore the input during verification.",
      "B": "It instructs ProVerif to generate axioms for the input.",
      "C": "It is used to mark inputs that are not relevant to the process.",
      "D": "It is used to indicate that the input should be considered as a variable."
    },
    "answer": "B"
  },
  {
    "id": "topic14_1",
    "question": "What is a destructor function symbol in the context of ProVerif?",
    "options": {
      "A": "A function that adds elements to a data structure.",
      "B": "A function that removes elements from a data structure.",
      "C": "A function that can be cast as a mayfailterm and does not contain destructor function symbols.",
      "D": "A function that is used to manipulate terms formed by constructors."
    },
    "answer": "D"
  },
  {
    "id": "topic14_2",
    "question": "What is a simple pattern in the context of pattern matching?",
    "options": {
      "A": "A pattern that contains destructor function symbols.",
      "B": "A pattern that does not contain destructor function symbols.",
      "C": "A pattern that matches any term regardless of its structure.",
      "D": "A pattern that is complex and contains multiple nested patterns."
    },
    "answer": "B"
  },
  {
    "id": "topic14_3",
    "question": "In ProVerif, what happens when a destructor function symbol is applied to a term that fails?",
    "options": {
      "A": "The pattern matching succeeds.",
      "B": "The pattern matching fails.",
      "C": "The pattern matching is undefined.",
      "D": "The pattern matching is skipped."
    },
    "answer": "B"
  },
  {
    "id": "topic14_4",
    "question": "What is the requirement for a converter function in ProVerif?",
    "options": {
      "A": "It must be the same as its argument.",
      "B": "It must be different from its argument and values of the same type obtained without applying the type converter function.",
      "C": "It must identify which type converter function was applied, but this information does not need to be checked upon pattern-matching.",
      "D": "It must be the same as the type of its arguments."
    },
    "answer": "B"
  },
  {
    "id": "topic14_5",
    "question": "What is the role of a data constructor in ProVerif?",
    "options": {
      "A": "It is used to represent data structures.",
      "B": "It is used to destroy data structures.",
      "C": "It is used to convert data types.",
      "D": "It is used to evaluate expressions."
    },
    "answer": "A"
  },
  {
    "id": "topic14_6",
    "question": "In ProVerif, what must be true for a function to be considered a data constructor?",
    "options": {
      "A": "It must have a single associated destructor.",
      "B": "It must have associated destructors defined for each argument.",
      "C": "It must be of arity n and come with associated destructors defined for each argument.",
      "D": "It must not have any associated destructors."
    },
    "answer": "C"
  },
  {
    "id": "topic14_7",
    "question": "What is the requirement for the arguments of a destructor in ProVerif?",
    "options": {
      "A": "They must all be of different types.",
      "B": "They must all be of the same type.",
      "C": "They can be of any type.",
      "D": "They must be of the same type as the arguments of the constructor."
    },
    "answer": "B"
  },
  {
    "id": "topic14_8",
    "question": "In ProVerif, what is the condition for a function to be a destructor?",
    "options": {
      "A": "It must be declared with the reduc declaration.",
      "B": "It must be declared with the fun declaration with reduc.",
      "C": "It must be a built-in function.",
      "D": "All of the above."
    },
    "answer": "D"
  },
  {
    "id": "topic14_9",
    "question": "What is the requirement for the return type and arguments of a destructor in ProVerif?",
    "options": {
      "A": "The return type must be different from the argument types.",
      "B": "The return type and all argument types must be the same.",
      "C": "The return type must be the same as the argument types.",
      "D": "There is no requirement for the return type and argument types."
    },
    "answer": "B"
  },
  {
    "id": "topic14_10",
    "question": "In ProVerif, what is the significance of the pattern f(pat1,...,patn)?",
    "options": {
      "A": "It matches terms of the form f(M1,...,Mn) when pati does not match Mi.",
      "B": "It matches terms of the form f(M1,...,Mn) when pati matches Mi for all i≤n.",
      "C": "It is used to represent data structures.",
      "D": "It is used to convert data types."
    },
    "answer": "B"
  },
  {
    "id": "topic15_1",
    "question": "What is the primary capability of ProVerif when it comes to security properties?",
    "options": {
      "A": "Verifying correspondences",
      "B": "Proving reachability properties",
      "C": "Ensuring equivalences",
      "D": "Testing for strong secrecy"
    },
    "answer": "B"
  },
  {
    "id": "topic15_2",
    "question": "In ProVerif, how is the secrecy of a term M evaluated in a model?",
    "options": {
      "A": "By analyzing the term's complexity",
      "B": "By checking the term's visibility to an attacker",
      "C": "By comparing it with other terms",
      "D": "By evaluating its computational cost"
    },
    "answer": "B"
  },
  {
    "id": "topic15_3",
    "question": "What kind of term M is used in the query to test secrecy in ProVerif?",
    "options": {
      "A": "A term with destructors",
      "B": "A ground term without destructors",
      "C": "A term with private names only",
      "D": "A term with free names and destructors"
    },
    "answer": "B"
  },
  {
    "id": "topic15_4",
    "question": "According to the content, which property does ProVerif start with when dealing with security properties?",
    "options": {
      "A": "Equivalences",
      "B": "Correspondences",
      "C": "Secrecy",
      "D": "Authentication"
    },
    "answer": "C"
  },
  {
    "id": "topic15_5",
    "question": "What is the simplest class of equivalences that ProVerif verifies?",
    "options": {
      "A": "Strong secrecy",
      "B": "Weak secrecy",
      "C": "Partial secrecy",
      "D": "Total secrecy"
    },
    "answer": "A"
  },
  {
    "id": "topic15_6",
    "question": "In the context of ProVerif, what does strong secrecy mean?",
    "options": {
      "A": "The adversary can distinguish two versions of the protocol using different secret values",
      "B": "The protocol's security is dependent on the strength of the cryptographic primitives",
      "C": "The adversary cannot distinguish two versions of the protocol using different secret values",
      "D": "The protocol's secrecy is only as strong as the weakest link in its cryptographic chain"
    },
    "answer": "C"
  },
  {
    "id": "topic15_7",
    "question": "What is the symbolic model, also known as the Dolev-Yao model, in the context of security protocols?",
    "options": {
      "A": "A model where cryptographic primitives are considered as perfect blackboxes",
      "B": "A model that focuses on the physical implementation of cryptographic primitives",
      "C": "A model that simulates the behavior of attackers in real-time",
      "D": "A model that predicts the future evolution of cryptographic algorithms"
    },
    "answer": "A"
  },
  {
    "id": "topic15_8",
    "question": "In ProVerif, what is the term used to describe an entity that can compute using cryptographic primitives?",
    "options": {
      "A": "Adversary",
      "B": "Eavesdropper",
      "C": "Cryptanalyst",
      "D": "Intruder"
    },
    "answer": "A"
  },
  {
    "id": "topic15_9",
    "question": "What is the main reference for the proof of secrecy and correspondences in ProVerif?",
    "options": {
      "A": "Blanchet, 2004",
      "B": "Blanchet et al., 2008",
      "C": "Blanchet, 2009",
      "D": "Abadi and Blanchet, 2003"
    },
    "answer": "C"
  },
  {
    "id": "topic15_10",
    "question": "In ProVerif, what is the term used for the process that preserves the strong secrecy of a protocol?",
    "options": {
      "A": "Correspondence process",
      "B": "Authentication process",
      "C": "Equivalence process",
      "D": "Closed process P0"
    },
    "answer": "D"
  },
  {
    "id": "topic16_1",
    "question": "What is the primary purpose of correspondence assertions in the context of authentication verification?",
    "options": {
      "A": "To verify the computational complexity of protocols.",
      "B": "To ensure that if client A thinks she executes the protocol with server B, then she really does so.",
      "C": "To measure the efficiency of cryptographic algorithms.",
      "D": "To prove the equivalence of different security protocols."
    },
    "answer": "B"
  },
  {
    "id": "topic16_2",
    "question": "Which tool is mentioned for verifying protocols for an unbounded number of sessions, often relying on user-provided lemmas?",
    "options": {
      "A": "ProVerif",
      "B": "Tamarin",
      "C": "Isabelle",
      "D": "Horn"
    },
    "answer": "B"
  },
  {
    "id": "topic16_3",
    "question": "What does ProVerif translate the protocol and security properties into for analysis?",
    "options": {
      "A": "Natural language sentences.",
      "B": "A set of Horn clauses.",
      "C": "A series of mathematical equations.",
      "D": "A graphical representation."
    },
    "answer": "B"
  },
  {
    "id": "topic16_4",
    "question": "What type of properties does Tamarin prove, similar to ProVerif?",
    "options": {
      "A": "Only secrecy properties.",
      "B": "Only authentication properties.",
      "C": "Both trace properties and some equivalences.",
      "D": "Only observational equivalence properties."
    },
    "answer": "C"
  },
  {
    "id": "topic16_5",
    "question": "What is the significance of the Horn clause method in verifying security protocols?",
    "options": {
      "A": "It allows for the verification of only a limited number of protocols.",
      "B": "It enables the verification of an unbounded number of sessions and message space.",
      "C": "It requires manual construction of clauses for each protocol.",
      "D": "It is only applicable to protocols with public-key encryption."
    },
    "answer": "B"
  },
  {
    "id": "topic16_6",
    "question": "What is one of the capabilities of ProVerif that is particularly useful in the computer security domain?",
    "options": {
      "A": "It can only analyze secrecy properties.",
      "B": "It can analyze secrecy, authentication properties, and emerging properties like privacy and traceability.",
      "C": "It can only verify protocols in the computational model.",
      "D": "It can only prove equivalences between protocols."
    },
    "answer": "B"
  },
  {
    "id": "topic16_7",
    "question": "According to the text, which property does the verifier struggle to prove in a fully automatic way?",
    "options": {
      "A": "Correspondence assertions.",
      "B": "Equivalences.",
      "C": "Secrecy.",
      "D": "Authentication."
    },
    "answer": "B"
  },
  {
    "id": "topic16_8",
    "question": "What is the computational soundness result shown by Canetti and Herzog (2006) for a restricted class of protocols?",
    "options": {
      "A": "A proof in the Dolev-Yao model implies security in the computational model.",
      "B": "A proof in the computational model implies security in the Dolev-Yao model.",
      "C": "A proof in the universal composability framework implies security in the Dolev-Yao model.",
      "D": "A proof in the Dolev-Yao model implies security in the universal composability framework."
    },
    "answer": "A"
  },
  {
    "id": "topic16_9",
    "question": "What is the role of correspondence assertions in verifying the certified email protocol?",
    "options": {
      "A": "They are not used in the verification process.",
      "B": "They are used to verify the integrity of the email system.",
      "C": "They are used to verify the certified email protocol.",
      "D": "They are used to prove the equivalence of different email protocols."
    },
    "answer": "C"
  },
  {
    "id": "topic16_10",
    "question": "What is the focus of the chapter on verifying security properties using ProVerif?",
    "options": {
      "A": "The use of natural language for protocol analysis.",
      "B": "The translation of protocols into a formal model.",
      "C": "The use of Horn clauses for verifying protocols.",
      "D": "The manual construction of clauses for each protocol."
    },
    "answer": "C"
  },
  {
    "id": "topic1_1",
    "question": "What is the basis for ProVerif's formal description language?",
    "options": {
      "A": "Pure pi calculus",
      "B": "Applied pi calculus with equational theories",
      "C": "Simple pi calculus",
      "D": "Extended pi calculus with Horn clauses"
    },
    "answer": "B"
  },
  {
    "id": "topic1_2",
    "question": "What is a key difference between ProVerif and the applied pi calculus?",
    "options": {
      "A": "ProVerif uses only equational theories",
      "B": "ProVerif supports all equational theories",
      "C": "ProVerif uses destructors in addition to equational theories",
      "D": "ProVerif does not support cryptographic primitives"
    },
    "answer": "C"
  },
  {
    "id": "topic1_3",
    "question": "What type of cryptographic primitives can ProVerif model?",
    "options": {
      "A": "Only symmetric key cryptography",
      "B": "Only asymmetric key cryptography",
      "C": "A wide variety of cryptographic primitives using rewrite rules or equations",
      "D": "No cryptographic primitives"
    },
    "answer": "C"
  },
  {
    "id": "topic1_4",
    "question": "What is one of the security properties that ProVerif can verify?",
    "options": {
      "A": "Only secrecy",
      "B": "Only authentication",
      "C": "Secrecy, authentication, and observational equivalence properties",
      "D": "None of the above"
    },
    "answer": "C"
  },
  {
    "id": "topic1_5",
    "question": "What is the structure of ProVerif represented in?",
    "options": {
      "A": "Figure 1.2",
      "B": "Figure 1.1",
      "C": "Table 2.1",
      "D": "Section 5.4"
    },
    "answer": "B"
  },
  {
    "id": "topic1_6",
    "question": "How does ProVerif handle equations?",
    "options": {
      "A": "Using only equational theories",
      "B": "Using only destructors",
      "C": "Using both equational theories and destructors",
      "D": "Not handling equations at all"
    },
    "answer": "C"
  },
  {
    "id": "topic1_7",
    "question": "What is the relationship between ProVerif's calculus and the applied pi calculus?",
    "options": {
      "A": "They are identical",
      "B": "They are similar but with some differences",
      "C": "ProVerif's calculus is a subset of the applied pi calculus",
      "D": "ProVerif's calculus is a superset of the applied pi calculus"
    },
    "answer": "B"
  },
  {
    "id": "topic1_8",
    "question": "What can ProVerif take as input?",
    "options": {
      "A": "Only a model of the protocol",
      "B": "Only the security properties to prove",
      "C": "A model of the protocol and security properties",
      "D": "Neither a model of the protocol nor security properties"
    },
    "answer": "C"
  },
  {
    "id": "topic1_9",
    "question": "What type of properties can ProVerif prove?",
    "options": {
      "A": "Only secrecy properties",
      "B": "Only authentication properties",
      "C": "Various security properties, including secrecy and authentication",
      "D": "No security properties"
    },
    "answer": "C"
  },
  {
    "id": "topic1_10",
    "question": "What is the role of Horn clauses in ProVerif?",
    "options": {
      "A": "To define the protocol",
      "B": "To specify the security properties",
      "C": "To derive queries for verification",
      "D": "To reconstruct attacks"
    },
    "answer": "C"
  },
  {
    "id": "topic2_1",
    "question": "What is the primary goal of ProVerif?",
    "options": {
      "A": "To design new cryptographic protocols",
      "B": "To verify the correctness of software implementations",
      "C": "To analyze and verify cryptographic protocols",
      "D": "To develop new cryptographic primitives"
    },
    "answer": "C"
  },
  {
    "id": "topic2_2",
    "question": "Which of the following protocols has been verified using ProVerif?",
    "options": {
      "A": "Only authentication protocols",
      "B": "Only voting protocols",
      "C": "A variety of protocols, including authentication protocols, voting protocols, and security protocols",
      "D": "Only e-voting protocols"
    },
    "answer": "C"
  },
  {
    "id": "topic2_3",
    "question": "What type of calculus is used by ProVerif to model protocols?",
    "options": {
      "A": "Pi calculus with cryptography",
      "B": "Lambda calculus",
      "C": "Tree automata",
      "D": "Horn clauses only"
    },
    "answer": "A"
  },
  {
    "id": "topic2_4",
    "question": "What are the main security properties that ProVerif can prove?",
    "options": {
      "A": "Secrecy and authentication only",
      "B": "Observational equivalences only",
      "C": "Secrecy, authentication, and observational equivalences",
      "D": "Reachability and correspondences only"
    },
    "answer": "C"
  },
  {
    "id": "topic2_5",
    "question": "How does ProVerif translate protocols into an internal representation?",
    "options": {
      "A": "Using tree automata",
      "B": "Using Horn clauses",
      "C": "Using lambda calculus",
      "D": "Using pi calculus"
    },
    "answer": "B"
  },
  {
    "id": "topic2_6",
    "question": "What is the name of the attack model assumed by ProVerif?",
    "options": {
      "A": "Dolev-Yao model",
      "B": "Man-in-the-middle model",
      "C": "Replay attack model",
      "D": "Side-channel attack model"
    },
    "answer": "A"
  },
  {
    "id": "topic2_7",
    "question": "What is one of the applications of ProVerif mentioned in the text?",
    "options": {
      "A": "Verifying a certified email web service",
      "B": "Developing new cryptographic primitives",
      "C": "Designing new security protocols",
      "D": "Analyzing software implementations"
    },
    "answer": "A"
  },
  {
    "id": "topic2_8",
    "question": "How many protocols were tested in (Blanchet, 2009) using ProVerif?",
    "options": {
      "A": "10 protocols",
      "B": "19 protocols",
      "C": "50 protocols",
      "D": "100 protocols"
    },
    "answer": "B"
  },
  {
    "id": "topic2_9",
    "question": "What is the purpose of the resolution with selection algorithm used in ProVerif?",
    "options": {
      "A": "To prove secrecy properties only",
      "B": "To prove authentication properties only",
      "C": "To prove various security properties, including secrecy and authentication",
      "D": "To optimize protocol performance"
    },
    "answer": "C"
  },
  {
    "id": "topic2_10",
    "question": "Which of the following is a feature of ProVerif?",
    "options": {
      "A": "It can only handle a bounded number of sessions",
      "B": "It can only handle a bounded message space",
      "C": "It can handle an unbounded number of sessions and an unbounded message space",
      "D": "It can only verify secrecy properties"
    },
    "answer": "C"
  },
  {
    "id": "topic3_1",
    "question": "What character set is allowed for constructing identifiers in the given formalism?",
    "options": {
      "A": "Only letters (a-z, A-Z)",
      "B": "Letters (a-z, A-Z), digits (0-9), underscores (_), single-quotes (’), and accented letters from the ISO Latin 1 character set",
      "C": "Only digits (0-9) and underscores (_)",
      "D": "Only special characters like !, @, #"
    },
    "answer": "B"
  },
  {
    "id": "topic3_2",
    "question": "What is the rule for the first character of an identifier?",
    "options": {
      "A": "It can be a digit",
      "B": "It must be a letter",
      "C": "It can be a special character",
      "D": "It must be an underscore"
    },
    "answer": "B"
  },
  {
    "id": "topic3_3",
    "question": "Are identifiers case sensitive in the given formalism?",
    "options": {
      "A": "No, they are case insensitive",
      "B": "Yes, they are case sensitive",
      "C": "It depends on the context",
      "D": "Only some identifiers are case sensitive"
    },
    "answer": "B"
  },
  {
    "id": "topic3_4",
    "question": "Which of the following is a reserved word and cannot be used as an identifier?",
    "options": {
      "A": "data",
      "B": "let",
      "C": "both A and B",
      "D": "x1"
    },
    "answer": "C"
  },
  {
    "id": "topic3_5",
    "question": "What is the purpose of declaring a variable or name with its type?",
    "options": {
      "A": "To improve code readability",
      "B": "To avoid type errors during the process",
      "C": "To make the code run faster",
      "D": "To increase memory allocation"
    },
    "answer": "B"
  },
  {
    "id": "topic3_6",
    "question": "In the given formalism, what is the recommendation for naming names and variables?",
    "options": {
      "A": "Use similar names for variables and names",
      "B": "Use distinct names for names and variables",
      "C": "Use numbers as prefixes for variables",
      "D": "Use special characters for names"
    },
    "answer": "B"
  },
  {
    "id": "topic3_7",
    "question": "Which of the following can be used as an identifier?",
    "options": {
      "A": "let",
      "B": "a variable name starting with a digit",
      "C": "a name consisting of letters, digits, and underscores",
      "D": "a reserved word like \"if\""
    },
    "answer": "C"
  },
  {
    "id": "topic3_8",
    "question": "How should comments be included in input files?",
    "options": {
      "A": "Surrounded by // and *",
      "B": "Surrounded by /* and */",
      "C": "Surrounded by (* and *)",
      "D": "Not allowed"
    },
    "answer": "C"
  },
  {
    "id": "topic3_9",
    "question": "What is the restriction on the length of an identifier?",
    "options": {
      "A": "It must be exactly 5 characters long",
      "B": "There is no restriction on the length",
      "C": "It must be at most 10 characters long",
      "D": "It must be at least 5 characters long"
    },
    "answer": "B"
  },
  {
    "id": "topic3_10",
    "question": "Can identifiers be reused as reserved words?",
    "options": {
      "A": "Yes, it is recommended to reuse them",
      "B": "No, it is strongly discouraged",
      "C": "Only some identifiers can be reused",
      "D": "It depends on the context"
    },
    "answer": "B"
  },
  {
    "id": "topic4_1",
    "question": "What is the requirement for the first character of an identifier in the given formalism?",
    "options": {
      "A": "It can be a digit or a special character.",
      "B": "It must be a letter.",
      "C": "It must be an underscore.",
      "D": "It can be a reserved word."
    },
    "answer": "B"
  },
  {
    "id": "topic4_2",
    "question": "Which of the following is a valid ⟨typeid⟩?",
    "options": {
      "A": "channel",
      "B": "if",
      "C": "event",
      "D": "function"
    },
    "answer": "A"
  },
  {
    "id": "topic4_3",
    "question": "What is the purpose of ⟨gbinding⟩ in the given formalism?",
    "options": {
      "A": "To declare a new variable.",
      "B": "To define a function.",
      "C": "To specify a type for an identifier.",
      "D": "To bind a value to a variable."
    },
    "answer": "D"
  },
  {
    "id": "topic4_4",
    "question": "What is the syntax for an empty sequence of X?",
    "options": {
      "A": "seq⟨X ⟩ = ⟨X ⟩",
      "B": "seq⟨X ⟩ = (⟨X ⟩,)∗⟨X ⟩",
      "C": "seq⟨X ⟩ = ⟨X ⟩, . . .,⟨X ⟩",
      "D": "seq⟨X ⟩ = ⟨X ⟩;"
    },
    "answer": "B"
  },
  {
    "id": "topic4_5",
    "question": "Which of the following is a valid ⟨gterm⟩?",
    "options": {
      "A": "⟨ident⟩(seq⟨gterm⟩)",
      "B": "⟨ident⟩ ==> ⟨gterm⟩",
      "C": "event(seq⟨gterm⟩) [@⟨ident⟩]",
      "D": "All of the above."
    },
    "answer": "D"
  },
  {
    "id": "topic4_6",
    "question": "What is the precedence of the infix symbol \"+\"?",
    "options": {
      "A": "Higher than \"*\"",
      "B": "Lower than \"==\"",
      "C": "Same as \"-\"",
      "D": "Higher than \"==>\""
    },
    "answer": "C"
  },
  {
    "id": "topic4_7",
    "question": "What is the purpose of the ⟨lemma⟩ production in the given formalism?",
    "options": {
      "A": "To define a new function.",
      "B": "To specify a type for an identifier.",
      "C": "To state a lemma or a theorem.",
      "D": "To declare a new variable."
    },
    "answer": "C"
  },
  {
    "id": "topic4_8",
    "question": "Which of the following is a valid ⟨pattern⟩?",
    "options": {
      "A": "⟨ident⟩[: ⟨typeid⟩]",
      "B": "⟨nat⟩",
      "C": "⟨pattern⟩ + ⟨nat⟩",
      "D": "All of the above."
    },
    "answer": "D"
  },
  {
    "id": "topic4_9",
    "question": "What is the syntax for a ⟨failtypedecl⟩?",
    "options": {
      "A": "seq+⟨ident⟩: ⟨typeid⟩",
      "B": "seq+⟨ident⟩: ⟨typeid⟩[or fail]",
      "C": "seq+⟨ident⟩: ⟨typeid⟩[,⟨failtypedecl⟩]",
      "D": "seq+⟨ident⟩: ⟨typeid⟩[or fail][,⟨failtypedecl⟩]"
    },
    "answer": "D"
  },
  {
    "id": "topic4_10",
    "question": "Which of the following is a valid ⟨nounifdecl⟩?",
    "options": {
      "A": "A sequence of ⟨ident⟩.",
      "B": "A sequence of ⟨gterm⟩.",
      "C": "A sequence of ⟨term⟩.",
      "D": "A declaration of a new variable."
    },
    "answer": "A"
  },
  {
    "id": "topic5_1",
    "question": "What is the purpose of the `set predicatesImplementable` option in ProVerif?",
    "options": {
      "A": "To check if predicate calls are implementable",
      "B": "To optimize the performance of the analysis",
      "C": "To adjust the precision of the analysis",
      "D": "To define new function symbols"
    },
    "answer": "A"
  },
  {
    "id": "topic5_2",
    "question": "Which of the following is a reserved word in ProVerif?",
    "options": {
      "A": "`letfun`",
      "B": "`new`",
      "C": "`else`",
      "D": "All of the above"
    },
    "answer": "D"
  },
  {
    "id": "topic5_3",
    "question": "What is the difference between the applied pi calculus and ProVerif's calculus?",
    "options": {
      "A": "ProVerif uses equations instead of destructors",
      "B": "ProVerif uses destructors instead of equational theories",
      "C": "ProVerif uses replication instead of parallel composition",
      "D": "ProVerif uses terms instead of patterns"
    },
    "answer": "B"
  },
  {
    "id": "topic5_4",
    "question": "What is the purpose of the `movenew` option in ProVerif?",
    "options": {
      "A": "To adjust the precision of the analysis",
      "B": "To optimize the performance of the analysis",
      "C": "To define new function symbols",
      "D": "To check if predicate calls are implementable"
    },
    "answer": "A"
  },
  {
    "id": "topic5_5",
    "question": "Which of the following is a valid term in ProVerif?",
    "options": {
      "A": "`M = N`",
      "B": "`M <> N`",
      "C": "`M && N`",
      "D": "All of the above"
    },
    "answer": "D"
  },
  {
    "id": "topic5_6",
    "question": "What is the default behavior of ProVerif regarding the implementability of predicate calls?",
    "options": {
      "A": "It checks if predicate calls are implementable",
      "B": "It does not check if predicate calls are implementable",
      "C": "It optimizes the performance of the analysis",
      "D": "It adjusts the precision of the analysis"
    },
    "answer": "A"
  },
  {
    "id": "topic5_7",
    "question": "What is the purpose of the `allowDiffPatterns` option in ProVerif?",
    "options": {
      "A": "To allow the use of `diff` and `choice` in patterns",
      "B": "To optimize the performance of the analysis",
      "C": "To adjust the precision of the analysis",
      "D": "To define new function symbols"
    },
    "answer": "A"
  },
  {
    "id": "topic5_8",
    "question": "How does ProVerif represent fresh names?",
    "options": {
      "A": "As functions of the variables bound above the new",
      "B": "As terms of the process calculus",
      "C": "As patterns",
      "D": "As function symbols"
    },
    "answer": "A"
  },
  {
    "id": "topic5_9",
    "question": "What is the effect of setting `movenew` to `true` in ProVerif?",
    "options": {
      "A": "It decreases the precision of the analysis",
      "B": "It increases the performance of the analysis",
      "C": "It yields the most precise analysis",
      "D": "It has no effect on the analysis"
    },
    "answer": "C"
  },
  {
    "id": "topic5_10",
    "question": "Which of the following is a process in ProVerif?",
    "options": {
      "A": "`in(M, x: t); P`",
      "B": "`out(M, N); P`",
      "C": "`if M then P else Q`",
      "D": "All of the above"
    },
    "answer": "D"
  },
  {
    "id": "topic6_1",
    "question": "What is the definition of an identifier in the given formalism?",
    "options": {
      "A": "A sequence of digits and underscores.",
      "B": "An unlimited sequence of letters, digits, underscores, single-quotes, and accented letters from the ISO Latin 1 character set, starting with a letter.",
      "C": "A single letter or digit.",
      "D": "A reserved word."
    },
    "answer": "B"
  },
  {
    "id": "topic6_2",
    "question": "What is the purpose of comments in input files?",
    "options": {
      "A": "To declare variables.",
      "B": "To provide additional information about data types.",
      "C": "To explain the code, surrounded by (* and *).",
      "D": "To define function symbols."
    },
    "answer": "C"
  },
  {
    "id": "topic6_3",
    "question": "What is the syntax for declaring a new variable or name in a process?",
    "options": {
      "A": "Using the keyword \"let\".",
      "B": "Using the keyword \"new\" followed by the identifier and its type.",
      "C": "Directly using the variable or name without declaration.",
      "D": "Using the keyword \"declare\"."
    },
    "answer": "B"
  },
  {
    "id": "topic6_4",
    "question": "What is the precedence of the infix symbol \"&&\" in the given formalism?",
    "options": {
      "A": "Higher than \"||\".",
      "B": "Lower than \"||\".",
      "C": "Same as \"=\".",
      "D": "Same as \">\"."
    },
    "answer": "B"
  },
  {
    "id": "topic6_5",
    "question": "What is the definition of ⟨gbinding⟩?",
    "options": {
      "A": "A sequence of ⟨ident⟩ and ⟨gterm⟩ separated by commas.",
      "B": "A single ⟨ident⟩ or ⟨gterm⟩.",
      "C": "!⟨nat⟩ = ⟨gterm⟩ [; ⟨gbinding⟩] or ⟨ident⟩ = ⟨gterm⟩ [; ⟨gbinding⟩].",
      "D": "A list of ⟨ident⟩."
    },
    "answer": "C"
  },
  {
    "id": "topic6_6",
    "question": "What is the purpose of the \"noninterf\" statement?",
    "options": {
      "A": "To declare a new variable.",
      "B": "To specify a type for an identifier.",
      "C": "To check for interference between processes.",
      "D": "To define a new function symbol."
    },
    "answer": "C"
  },
  {
    "id": "topic6_7",
    "question": "What is the syntax for a term ⟨term⟩?",
    "options": {
      "A": "Defined in Figure A.4.",
      "B": "A sequence of ⟨ident⟩ and ⟨gterm⟩.",
      "C": "A single ⟨gterm⟩.",
      "D": "Not explicitly defined."
    },
    "answer": "A"
  },
  {
    "id": "topic6_8",
    "question": "How are names and variables treated in the formalism?",
    "options": {
      "A": "They are interchangeable.",
      "B": "Names represent atomic data and variables can be substituted by terms.",
      "C": "Names and variables have the same type.",
      "D": "Names are not allowed in declarations."
    },
    "answer": "B"
  },
  {
    "id": "topic6_9",
    "question": "What is the definition of a ⟨typeid⟩?",
    "options": {
      "A": "An identifier ⟨ident⟩ or the reserved word \"channel\".",
      "B": "A natural number ⟨nat⟩.",
      "C": "A sequence of ⟨ident⟩.",
      "D": "A single ⟨ident⟩."
    },
    "answer": "A"
  },
  {
    "id": "topic6_10",
    "question": "What happens when a \"let\" expression is evaluated in a process?",
    "options": {
      "A": "It is substituted with a value if the value is not fail.",
      "B": "It is substituted with a value only if the value is a natural number.",
      "C": "It is evaluated to fail if the value is not a natural number.",
      "D": "It is not allowed in the formalism."
    },
    "answer": "A"
  },
  {
    "id": "topic7_1",
    "question": "What is the purpose of the `new` keyword in ProVerif?",
    "options": {
      "A": "To declare a new variable",
      "B": "To create a fresh name",
      "C": "To define a new process",
      "D": "To specify a channel"
    },
    "answer": "B"
  },
  {
    "id": "topic7_2",
    "question": "Which of the following is a reserved word in ProVerif?",
    "options": {
      "A": "`letfun`",
      "B": "`const`",
      "C": "`event`",
      "D": "All of the above"
    },
    "answer": "D"
  },
  {
    "id": "topic7_3",
    "question": "What is the purpose of the `event` keyword in ProVerif?",
    "options": {
      "A": "To specify a new process",
      "B": "To declare a variable",
      "C": "To mark a specific point in the protocol",
      "D": "To define a new type"
    },
    "answer": "C"
  },
  {
    "id": "topic7_4",
    "question": "What is the result of the analysis when ProVerif attempts to show `not attacker(M)`?",
    "options": {
      "A": "It proves the secrecy of `M` is not preserved",
      "B": "It proves the secrecy of `M` is preserved",
      "C": "It generates a warning message",
      "D": "It terminates with an error"
    },
    "answer": "B"
  },
  {
    "id": "topic7_5",
    "question": "How does ProVerif handle syntax errors?",
    "options": {
      "A": "It indicates the line and column numbers of the error",
      "B": "It provides a warning message",
      "C": "It terminates with an error message",
      "D": "It ignores the error"
    },
    "answer": "A"
  },
  {
    "id": "topic7_6",
    "question": "What is the purpose of the `let` keyword in ProVerif?",
    "options": {
      "A": "To declare a new variable",
      "B": "To define a new process",
      "C": "To specify a conditional statement",
      "D": "To perform pattern-matching"
    },
    "answer": "A"
  },
  {
    "id": "topic7_7",
    "question": "What is the effect of setting `movenew` to `true` in ProVerif?",
    "options": {
      "A": "It decreases the precision of the analysis",
      "B": "It increases the precision of the analysis",
      "C": "It has no effect on the analysis",
      "D": "It terminates the analysis"
    },
    "answer": "B"
  },
  {
    "id": "topic7_8",
    "question": "What is the purpose of the `process macros` in ProVerif?",
    "options": {
      "A": "To define new types",
      "B": "To specify cryptographic primitives",
      "C": "To ease the development of sub-processes",
      "D": "To declare new variables"
    },
    "answer": "C"
  },
  {
    "id": "topic7_9",
    "question": "What is the distribution license of the ProVerif software?",
    "options": {
      "A": "GNU general public license",
      "B": "MIT license",
      "C": "Apache license",
      "D": "Proprietary license"
    },
    "answer": "A"
  },
  {
    "id": "topic7_10",
    "question": "What is the role of whitespace characters in ProVerif?",
    "options": {
      "A": "They are ignored by the compiler",
      "B": "They are used to specify the syntax of terms",
      "C": "They are used to separate keywords",
      "D": "They affect the semantics of the language"
    },
    "answer": "A"
  },
  {
    "id": "topic8_1",
    "question": "What is the purpose of declaring a constant in ProVerif?",
    "options": {
      "A": "To define a function with arguments",
      "B": "To represent atomic data such as keys and nonces",
      "C": "To declare a variable that can be substituted by terms",
      "D": "To specify a type for a process"
    },
    "answer": "B"
  },
  {
    "id": "topic8_2",
    "question": "How are names and variables declared in ProVerif?",
    "options": {
      "A": "With a set of function symbols",
      "B": "With their type",
      "C": "Using a specific construct for constants",
      "D": "As a list of declarations"
    },
    "answer": "B"
  },
  {
    "id": "topic8_3",
    "question": "What does the syntax `h(T1,...,Tn) : T` mean?",
    "options": {
      "A": "A function `h` takes no arguments",
      "B": "A function `h` takes `n` arguments of types `T1,...,Tn` respectively, and returns a value of type `T`",
      "C": "A constant `h` of type `T`",
      "D": "A variable `h` of type `T`"
    },
    "answer": "B"
  },
  {
    "id": "topic8_4",
    "question": "What is the purpose of the `type` declaration in ProVerif?",
    "options": {
      "A": "To declare a constant",
      "B": "To declare a function symbol",
      "C": "To declare a new type",
      "D": "To specify a type for a process"
    },
    "answer": "C"
  },
  {
    "id": "topic8_5",
    "question": "How are free names declared in ProVerif?",
    "options": {
      "A": "Using the `const` keyword",
      "B": "Using the `free` keyword",
      "C": "Using the `fun` keyword",
      "D": "Using the `type` keyword"
    },
    "answer": "B"
  },
  {
    "id": "topic8_6",
    "question": "What is the role of function symbols in ProVerif?",
    "options": {
      "A": "To represent atomic data",
      "B": "To declare new types",
      "C": "To construct and deconstruct terms",
      "D": "To specify a type for a process"
    },
    "answer": "C"
  },
  {
    "id": "topic8_7",
    "question": "What is the purpose of the `const` declaration in ProVerif?",
    "options": {
      "A": "To declare a variable",
      "B": "To declare a constant",
      "C": "To declare a function symbol",
      "D": "To declare a new type"
    },
    "answer": "B"
  },
  {
    "id": "topic8_8",
    "question": "Can identifiers be reused as identifiers in ProVerif?",
    "options": {
      "A": "Yes, it is recommended to reuse identifiers",
      "B": "No, identifiers should be unique",
      "C": "Yes, but it is strongly discouraged",
      "D": "No, identifiers are reserved for specific use"
    },
    "answer": "C"
  },
  {
    "id": "topic8_9",
    "question": "What is the purpose of the `free` declaration in ProVerif?",
    "options": {
      "A": "To declare a constant",
      "B": "To declare a function symbol",
      "C": "To declare a free name",
      "D": "To specify a type for a process"
    },
    "answer": "C"
  },
  {
    "id": "topic8_10",
    "question": "What is the general form of a declaration in ProVerif?",
    "options": {
      "A": "`⟨decl⟩ ::= type ⟨ident⟩ ⟨options⟩`",
      "B": "`⟨decl⟩ ::= const seq+⟨ident⟩: ⟨typeid⟩ ⟨options⟩`",
      "C": "`⟨decl⟩ ::= fun ⟨ident⟩(seq⟨typeid⟩): ⟨typeid⟩ ⟨options⟩`",
      "D": "Various forms, including `type`, `const`, `fun`, etc."
    },
    "answer": "D"
  },
  {
    "id": "topic9_1",
    "question": "What is the purpose of declaring free names in a process declaration?",
    "options": {
      "A": "To define a new constructor function symbol",
      "B": "To associate a type with a name",
      "C": "To specify a rewrite rule for a destructor",
      "D": "To declare a new variable"
    },
    "answer": "B"
  },
  {
    "id": "topic9_2",
    "question": "How are user-defined types declared in the language?",
    "options": {
      "A": "Using the `const` keyword",
      "B": "Using the `type` keyword",
      "C": "Using the `fun` keyword",
      "D": "Using the `reduc` keyword"
    },
    "answer": "B"
  },
  {
    "id": "topic9_3",
    "question": "What is the role of a destructor function symbol in the language?",
    "options": {
      "A": "To construct new terms from variables and names",
      "B": "To manipulate terms formed by constructors",
      "C": "To define new constants",
      "D": "To specify equations between terms"
    },
    "answer": "B"
  },
  {
    "id": "topic9_4",
    "question": "How are the behaviors of destructor function symbols defined?",
    "options": {
      "A": "Using a set of equations",
      "B": "Using a set of rewrite rules",
      "C": "Using a set of conditional statements",
      "D": "Using a set of loops"
    },
    "answer": "B"
  },
  {
    "id": "topic9_5",
    "question": "What is the purpose of the `forall` keyword in the definition of a destructor?",
    "options": {
      "A": "To specify a universal quantifier",
      "B": "To declare a new variable",
      "C": "To define a new constructor function symbol",
      "D": "To specify the types of the arguments of a destructor"
    },
    "answer": "D"
  },
  {
    "id": "topic9_6",
    "question": "Can a destructor function symbol be applied to any term?",
    "options": {
      "A": "Yes, without any restrictions",
      "B": "No, only to terms of a specific type",
      "C": "Yes, but only if it is defined by a rewrite rule",
      "D": "No, only to constants"
    },
    "answer": "B"
  },
  {
    "id": "topic9_7",
    "question": "What is the difference between a constructor and a destructor?",
    "options": {
      "A": "A constructor builds new terms, while a destructor manipulates existing terms",
      "B": "A constructor manipulates existing terms, while a destructor builds new terms",
      "C": "A constructor is used for pattern matching, while a destructor is not",
      "D": "A constructor is used for rewrite rules, while a destructor is not"
    },
    "answer": "A"
  },
  {
    "id": "topic9_8",
    "question": "How are constants defined in the language?",
    "options": {
      "A": "Using the `fun` keyword with arity 0",
      "B": "Using the `const` keyword",
      "C": "Using the `type` keyword",
      "D": "Using the `reduc` keyword"
    },
    "answer": "B"
  },
  {
    "id": "topic9_9",
    "question": "What is the purpose of the `reduc` keyword in the language?",
    "options": {
      "A": "To define a new constructor function symbol",
      "B": "To define a new destructor function symbol",
      "C": "To specify a rewrite rule for a destructor",
      "D": "To declare a new variable"
    },
    "answer": "C"
  },
  {
    "id": "topic9_10",
    "question": "Can modular exponentiation be directly represented in the framework of the language?",
    "options": {
      "A": "Yes, using a built-in constructor",
      "B": "Yes, using a user-defined destructor",
      "C": "No, it is not supported",
      "D": "Yes, using a rewrite rule"
    },
    "answer": "C"
  },
  {
    "id": "topic10_1",
    "question": "What is the purpose of the evaluation relation D⇓V in the given formalism?",
    "options": {
      "A": "To define the syntax of expressions",
      "B": "To specify the semantics of expressions",
      "C": "To declare new names",
      "D": "To evaluate the type of a term"
    },
    "answer": "B"
  },
  {
    "id": "topic10_2",
    "question": "Which of the following is a type of value in the given formalism?",
    "options": {
      "A": "A term with variables",
      "B": "A ground term or fail",
      "C": "A process with a conditional statement",
      "D": "A function application"
    },
    "answer": "B"
  },
  {
    "id": "topic10_3",
    "question": "What is the result of evaluating a conditional statement if M then N else N′ when M fails?",
    "options": {
      "A": "N",
      "B": "N′",
      "C": "fail",
      "D": "The evaluation loops indefinitely"
    },
    "answer": "C"
  },
  {
    "id": "topic10_4",
    "question": "How are expressions evaluated in the given formalism?",
    "options": {
      "A": "By rewriting them until a value is obtained",
      "B": "By applying a set of predefined rules",
      "C": "By using a recursive function",
      "D": "By evaluating the type of the expression"
    },
    "answer": "A"
  },
  {
    "id": "topic10_5",
    "question": "What is the purpose of the let x: T = D in P else Q construct?",
    "options": {
      "A": "To declare a new name",
      "B": "To evaluate an expression and bind the result to x",
      "C": "To specify a conditional statement",
      "D": "To define a new function"
    },
    "answer": "B"
  },
  {
    "id": "topic10_6",
    "question": "Which of the following is an example of a destructor?",
    "options": {
      "A": "A function application",
      "B": "A tuple construction",
      "C": "A conditional statement",
      "D": "A restriction"
    },
    "answer": "A"
  },
  {
    "id": "topic10_7",
    "question": "What is the type of the tuple constructor tupleT1,...,Tn?",
    "options": {
      "A": "bitstring",
      "B": "term",
      "C": "expression",
      "D": "process"
    },
    "answer": "A"
  },
  {
    "id": "topic10_8",
    "question": "How are processes that contain expressions with conditionals and expression evaluations handled?",
    "options": {
      "A": "They are transformed into processes without such expressions",
      "B": "They are evaluated directly",
      "C": "They are rejected by the formalism",
      "D": "They are rewritten using a set of predefined rules"
    },
    "answer": "A"
  },
  {
    "id": "topic10_9",
    "question": "What is the purpose of the new a: T; P construct?",
    "options": {
      "A": "To declare a new name a of type T",
      "B": "To evaluate an expression",
      "C": "To specify a conditional statement",
      "D": "To define a new function"
    },
    "answer": "A"
  },
  {
    "id": "topic10_10",
    "question": "What happens when no rewrite rule applies during the evaluation of g(D1,...,Dn)?",
    "options": {
      "A": "The evaluation succeeds with a default value",
      "B": "The evaluation fails and evaluates to the constant fail",
      "C": "The evaluation loops indefinitely",
      "D": "The evaluation is undefined"
    },
    "answer": "B"
  },
  {
    "id": "topic11_1",
    "question": "What is the purpose of the `phase` construct in ProVerif?",
    "options": {
      "A": "To model a single process execution",
      "B": "To specify a global synchronization point",
      "C": "To define a new constant",
      "D": "To declare a variable"
    },
    "answer": "B"
  },
  {
    "id": "topic11_2",
    "question": "Which process construct is used to execute an event and then continue with the rest of the process?",
    "options": {
      "A": "`event(e(M1,...,M n)); P`",
      "B": "`in(M, x); P`",
      "C": "`out(M, N); P`",
      "D": "`if M then P else Q`"
    },
    "answer": "A"
  },
  {
    "id": "topic11_3",
    "question": "What is the effect of the `phase n; P` construct on process execution?",
    "options": {
      "A": "It discards all processes that have not reached phase n",
      "B": "It starts a new process with name n",
      "C": "It executes process P only if phase n has been reached",
      "D": "It increments the phase number by n"
    },
    "answer": "A"
  },
  {
    "id": "topic11_4",
    "question": "Which of the following is a standard construct in the pi calculus?",
    "options": {
      "A": "`phase n; P`",
      "B": "`event(e(M1,...,M n)); P`",
      "C": "`in(M, x); P`",
      "D": "`let x: T = D in D′else D′′`"
    },
    "answer": "C"
  },
  {
    "id": "topic11_5",
    "question": "What is the purpose of the `begin(M ).P` and `end(M ).P` constructs?",
    "options": {
      "A": "To specify a conditional statement",
      "B": "To execute an event and then continue with the rest of the process",
      "C": "To model input/output operations",
      "D": "To express correspondence properties"
    },
    "answer": "D"
  },
  {
    "id": "topic11_6",
    "question": "How does ProVerif handle the evaluation of expressions?",
    "options": {
      "A": "It uses a separate evaluation function",
      "B": "It extends the syntax of expressions with constructs from processes",
      "C": "It only allows simple arithmetic expressions",
      "D": "It does not support expression evaluation"
    },
    "answer": "B"
  },
  {
    "id": "topic11_7",
    "question": "What is the role of the `new n : t; P` construct?",
    "options": {
      "A": "To declare a new variable",
      "B": "To restrict the scope of a name",
      "C": "To output a message on a channel",
      "D": "To input a message on a channel"
    },
    "answer": "B"
  },
  {
    "id": "topic11_8",
    "question": "Which process construct is used to model parallel composition?",
    "options": {
      "A": "`P | Q`",
      "B": "`!P`",
      "C": "`in(M, x); P`",
      "D": "`out(M, N); P`"
    },
    "answer": "A"
  },
  {
    "id": "topic11_9",
    "question": "What happens to processes that do not reach a `phase n` construct with n ≥ 1?",
    "options": {
      "A": "They continue executing normally",
      "B": "They are discarded",
      "C": "They are paused until phase n is reached",
      "D": "They are duplicated"
    },
    "answer": "B"
  },
  {
    "id": "topic11_10",
    "question": "What is the purpose of the `event(e(M1,...,M n)); P` construct?",
    "options": {
      "A": "To record that a certain program point has been reached",
      "B": "To output a message on a channel",
      "C": "To input a message on a channel",
      "D": "To specify a conditional statement"
    },
    "answer": "A"
  },
  {
    "id": "topic12_1",
    "question": "What is the primary purpose of using process macros in ProVerif?",
    "options": {
      "A": "To define the security assumptions on primitives",
      "B": "To encode protocols into a single main process",
      "C": "To ease development by specifying sub-processes",
      "D": "To model the behavior of cryptographic primitives"
    },
    "answer": "C"
  },
  {
    "id": "topic12_2",
    "question": "How are user-defined types declared in ProVerif?",
    "options": {
      "A": "Using the syntax `type t = ...`",
      "B": "Using the syntax `type t .`",
      "C": "Using the syntax `let t = ...`",
      "D": "Using the syntax `def t = ...`"
    },
    "answer": "B"
  },
  {
    "id": "topic12_3",
    "question": "What is the effect of the `phase` construct in ProVerif?",
    "options": {
      "A": "It acts as a local synchronization mechanism",
      "B": "It acts as a global synchronization mechanism",
      "C": "It is used to define a new type",
      "D": "It is used to declare a free name"
    },
    "answer": "B"
  },
  {
    "id": "topic12_4",
    "question": "How are macros expanded in ProVerif?",
    "options": {
      "A": "By replacing the macro name with its definition",
      "B": "By using a separate compiler",
      "C": "By using a different programming language",
      "D": "By manual expansion"
    },
    "answer": "A"
  },
  {
    "id": "topic12_5",
    "question": "What is the purpose of the `def` construct in ProVerif?",
    "options": {
      "A": "To define a new type",
      "B": "To define a macro name with a set of declarations",
      "C": "To declare a free name",
      "D": "To specify a sub-process"
    },
    "answer": "B"
  },
  {
    "id": "topic12_6",
    "question": "What happens to processes that do not reach a `phase n` construct with `n ≥ 1`?",
    "options": {
      "A": "They continue running",
      "B": "They are discarded",
      "C": "They are paused",
      "D": "They are restarted"
    },
    "answer": "B"
  },
  {
    "id": "topic12_7",
    "question": "How are free names declared in ProVerif?",
    "options": {
      "A": "Using the syntax `free n`",
      "B": "Using the syntax `free n : t`",
      "C": "Using the syntax `let n = ...`",
      "D": "Using the syntax `def n = ...`"
    },
    "answer": "B"
  },
  {
    "id": "topic12_8",
    "question": "What is the benefit of using process macros in ProVerif?",
    "options": {
      "A": "They improve performance",
      "B": "They simplify the code",
      "C": "They ease development by specifying sub-processes",
      "D": "They are not useful"
    },
    "answer": "C"
  },
  {
    "id": "topic12_9",
    "question": "What is the purpose of the `phase` construct in modeling protocols?",
    "options": {
      "A": "To model situations with multiple phases",
      "B": "To define a new type",
      "C": "To declare a free name",
      "D": "To specify a sub-process"
    },
    "answer": "A"
  },
  {
    "id": "topic12_10",
    "question": "How does ProVerif represent protocols?",
    "options": {
      "A": "Using tree-automata",
      "B": "Using Horn clauses",
      "C": "Using a different formalism",
      "D": "Using a programming language"
    },
    "answer": "B"
  },
  {
    "id": "topic13_1",
    "question": "What is the purpose of the `forall` quantifier in a process declaration?",
    "options": {
      "A": "To specify the type of a variable",
      "B": "To universally quantify variables over a specific type",
      "C": "To declare a new name",
      "D": "To define a function symbol"
    },
    "answer": "B"
  },
  {
    "id": "topic13_2",
    "question": "How are names and variables declared in the given formalism?",
    "options": {
      "A": "Names and variables are declared with their types using the `type` keyword",
      "B": "Names and variables are declared with their types using the `free` keyword",
      "C": "Names and variables are declared with their types using the `forall` quantifier",
      "D": "Names and variables do not need to be declared"
    },
    "answer": "B"
  },
  {
    "id": "topic13_3",
    "question": "What is the scope of a variable or name in a process declaration?",
    "options": {
      "A": "It is determined by the position of the variable or name in the process",
      "B": "It is determined by the `forall` quantifier",
      "C": "It is determined by the type of the variable or name",
      "D": "It is determined by the keyword `process`"
    },
    "answer": "B"
  },
  {
    "id": "topic13_4",
    "question": "What is the purpose of annotating restrictions with variables in the internal representation of fresh names?",
    "options": {
      "A": "To avoid false attacks due to names with different arguments",
      "B": "To improve the performance of the verification phase",
      "C": "To reduce the number of clauses in the process",
      "D": "To increase the scope of variables"
    },
    "answer": "A"
  },
  {
    "id": "topic13_5",
    "question": "How are function symbols declared in the given formalism?",
    "options": {
      "A": "Using the `type` keyword",
      "B": "Using the `free` keyword",
      "C": "Using the `forall` quantifier",
      "D": "With their types, e.g., `h(T1,...,Tn) : T`"
    },
    "answer": "D"
  },
  {
    "id": "topic13_6",
    "question": "What is the convention for omitting `else 0` in the if-then-else construct?",
    "options": {
      "A": "It is always omitted",
      "B": "It is never omitted",
      "C": "It is omitted only in certain contexts",
      "D": "It is not clear which `if` the `else` applies to"
    },
    "answer": "D"
  },
  {
    "id": "topic13_7",
    "question": "What is the purpose of the `precise` annotation in input declarations?",
    "options": {
      "A": "To specify the type of the input",
      "B": "To indicate that the input should be taken into account as precisely as possible",
      "C": "To declare a new name",
      "D": "To define a function symbol"
    },
    "answer": "B"
  },
  {
    "id": "topic13_8",
    "question": "How are free names declared in the given formalism?",
    "options": {
      "A": "Using the `type` keyword",
      "B": "Using the `free` keyword",
      "C": "Using the `forall` quantifier",
      "D": "Using the `process` keyword"
    },
    "answer": "B"
  },
  {
    "id": "topic13_9",
    "question": "What is the purpose of the `maxSubset` declaration?",
    "options": {
      "A": "To specify the type of a variable",
      "B": "To declare a new name",
      "C": "To define a function symbol",
      "D": "To specify the lemma declaration"
    },
    "answer": "D"
  },
  {
    "id": "topic13_10",
    "question": "What is the requirement for identifiers in the given formalism?",
    "options": {
      "A": "They must be unique within a process",
      "B": "They must be declared before use",
      "C": "They must be declared with their types",
      "D": "They can be used without prior declaration"
    },
    "answer": "B"
  },
  {
    "id": "topic14_1",
    "question": "What is a requirement for a destructor function symbol in a process term?",
    "options": {
      "A": "It must be used with a single argument.",
      "B": "It must be declared with its type before use.",
      "C": "It must be used with a specific set of predefined types.",
      "D": "It can be used without any prior declaration."
    },
    "answer": "B"
  },
  {
    "id": "topic14_2",
    "question": "Which of the following is a characteristic of a simple pattern in the context of pattern-matching?",
    "options": {
      "A": "It contains at least one destructor function symbol.",
      "B": "It does not contain any destructor function symbols.",
      "C": "It can only be used with data constructors.",
      "D": "It must be used with a conditional statement."
    },
    "answer": "B"
  },
  {
    "id": "topic14_3",
    "question": "What happens when a destructor fails during pattern-matching?",
    "options": {
      "A": "The process terminates normally.",
      "B": "The pattern-matching fails.",
      "C": "The process continues with the next rewrite rule.",
      "D": "A runtime error occurs."
    },
    "answer": "B"
  },
  {
    "id": "topic14_4",
    "question": "What is a data constructor in the context of pattern-matching?",
    "options": {
      "A": "A constructor that comes with associated destructors.",
      "B": "A destructor that can be used with multiple arguments.",
      "C": "A function symbol that represents a data structure.",
      "D": "A built-in constructor."
    },
    "answer": "A"
  },
  {
    "id": "topic14_5",
    "question": "What is the purpose of a reduc declaration in ProVerif?",
    "options": {
      "A": "To define a new function symbol.",
      "B": "To specify a rewrite rule for a destructor.",
      "C": "To declare a variable.",
      "D": "To define a data constructor."
    },
    "answer": "B"
  },
  {
    "id": "topic14_6",
    "question": "How are destructors modeled in ProVerif?",
    "options": {
      "A": "Using rewrite rules of the form: `forall x1,1 : t1,1, . . . , x1,n1 : t1,n1 ; g(M1,1, . . . , M1,k) = M1,0;`",
      "B": "Using equations of the form `M = N`.",
      "C": "Using conditional statements.",
      "D": "Using function macros."
    },
    "answer": "A"
  },
  {
    "id": "topic14_7",
    "question": "What is a requirement for the arguments of a destructor?",
    "options": {
      "A": "They must have different types.",
      "B": "They must have the same type.",
      "C": "They can have different types.",
      "D": "They are optional."
    },
    "answer": "B"
  },
  {
    "id": "topic14_8",
    "question": "What is the purpose of a type converter function in ProVerif?",
    "options": {
      "A": "To convert a term from one type to another.",
      "B": "To define a new data constructor.",
      "C": "To specify a rewrite rule for a destructor.",
      "D": "To check the type of a term during pattern-matching."
    },
    "answer": "D"
  },
  {
    "id": "topic14_9",
    "question": "Which of the following is a built-in destructor in ProVerif?",
    "options": {
      "A": "`equal`",
      "B": "`not`",
      "C": "`is nat`",
      "D": "All of the above."
    },
    "answer": "D"
  },
  {
    "id": "topic14_10",
    "question": "What happens when a term is encountered during execution that can be reduced according to a rewrite rule?",
    "options": {
      "A": "It is replaced by a new term.",
      "B": "It is evaluated to a boolean value.",
      "C": "It is checked for type consistency.",
      "D": "The process terminates normally."
    },
    "answer": "A"
  },
  {
    "id": "topic15_1",
    "question": "What is the primary capability of ProVerif in verifying security properties?",
    "options": {
      "A": "Verifying authentication protocols",
      "B": "Proving reachability properties and evaluating secrecy of terms",
      "C": "Analyzing security protocols with secrecy types and logic programs",
      "D": "Modeling security protocols in the computational model"
    },
    "answer": "B"
  },
  {
    "id": "topic15_2",
    "question": "How is the secrecy of a term M in a model tested using ProVerif?",
    "options": {
      "A": "By including the query `query attacker (M)` in the input file before the main process",
      "B": "By using a different query for each type of security property",
      "C": "By modeling the protocol in the computational model",
      "D": "By analyzing the protocol's authentication properties"
    },
    "answer": "A"
  },
  {
    "id": "topic15_3",
    "question": "What is the Dolev-Yao model, also known as the symbolic model, used for in security protocol verification?",
    "options": {
      "A": "To model cryptographic primitives as imperfect blackboxes",
      "B": "To consider messages as terms on these primitives and the adversary's ability to compute using these primitives",
      "C": "To verify authentication protocols",
      "D": "To analyze security protocols with secrecy types and logic programs"
    },
    "answer": "B"
  },
  {
    "id": "topic15_4",
    "question": "What is strong secrecy in the context of security protocol verification?",
    "options": {
      "A": "The adversary can distinguish two versions of the protocol that use different values of the secret",
      "B": "The adversary cannot distinguish two versions of the protocol that use different values of the secret",
      "C": "The protocol preserves the secrecy of a term only if it is not used in a conditional statement",
      "D": "The protocol preserves the secrecy of a term only if it is used in a specific process"
    },
    "answer": "B"
  },
  {
    "id": "topic15_5",
    "question": "What is the purpose of the query `query attacker (M)` in ProVerif?",
    "options": {
      "A": "To verify the authentication properties of a protocol",
      "B": "To test the secrecy of a term M in a model",
      "C": "To analyze the protocol's behavior in the computational model",
      "D": "To model security protocols in the symbolic model"
    },
    "answer": "B"
  },
  {
    "id": "topic15_6",
    "question": "Which of the following is a reference for the proof of secrecy and correspondences in ProVerif?",
    "options": {
      "A": "Blanchet (2004)",
      "B": "Blanchet et al. (2008)",
      "C": "Blanchet (2009)",
      "D": "Abadi and Blanchet (2003)"
    },
    "answer": "C"
  },
  {
    "id": "topic15_7",
    "question": "What is the core calculus used in ProVerif for verifying security properties?",
    "options": {
      "A": "§2.1",
      "B": "§2.3",
      "C": "§2.4",
      "D": "§2.5"
    },
    "answer": "A"
  },
  {
    "id": "topic15_8",
    "question": "What is the name of the conference where a paper on security protocol verification was presented in 2012?",
    "options": {
      "A": "POST'12",
      "B": "FOSAD 2012/2013",
      "C": "SAS'03",
      "D": "FoSSaCS'01"
    },
    "answer": "A"
  },
  {
    "id": "topic15_9",
    "question": "What is the title of the tutorial lectures on security analysis and design, where ProVerif is discussed?",
    "options": {
      "A": "Foundations of Security Analysis and Design VII",
      "B": "Foundations and Trends in Privacy and Security",
      "C": "Automatic Verification of Security Protocols",
      "D": "Modeling and Verifying Security Protocols with the Applied Pi Calculus and ProVerif"
    },
    "answer": "A"
  },
  {
    "id": "topic15_10",
    "question": "In what year was a paper on secrecy types for asymmetric communication published?",
    "options": {
      "A": "2005",
      "B": "2008",
      "C": "2003",
      "D": "2014"
    },
    "answer": "A"
  },
  {
    "id": "topic16_1",
    "question": "What is the primary purpose of using correspondence assertions in authentication verification?",
    "options": {
      "A": "To prove the secrecy property of a protocol",
      "B": "To verify the integrity of a file system",
      "C": "To ensure that if event e1 has been executed, then event e2 has or will be executed",
      "D": "To analyze the computational soundness of a protocol"
    },
    "answer": "C"
  },
  {
    "id": "topic16_2",
    "question": "Which of the following tools uses an algorithm based on resolution to verify security properties?",
    "options": {
      "A": "Tamarin",
      "B": "ProVerif",
      "C": "Isabelle",
      "D": "Blanchet's verifier"
    },
    "answer": "B"
  },
  {
    "id": "topic16_3",
    "question": "What is the approach used by ProVerif to verify protocols?",
    "options": {
      "A": "It uses a model checking approach",
      "B": "It translates protocols into a set of Horn clauses and security properties into derivability queries",
      "C": "It relies on manual proofs of security properties",
      "D": "It uses a computational soundness approach"
    },
    "answer": "B"
  },
  {
    "id": "topic16_4",
    "question": "What is the main limitation of using Horn clauses for verifying protocols?",
    "options": {
      "A": "It can only prove secrecy properties",
      "B": "It requires manual guidance for proof",
      "C": "It cannot prove properties in a fully automatic way",
      "D": "It is limited to a specific class of protocols"
    },
    "answer": "C"
  },
  {
    "id": "topic16_5",
    "question": "Which protocol was analyzed by Abadi, Blanchet & Fournet using ProVerif?",
    "options": {
      "A": "JFK (Just Fast Keying) protocol",
      "B": "Certified email protocol",
      "C": "Plutus file system",
      "D": "Direct Anonymous Attestation (DAA) protocol"
    },
    "answer": "A"
  },
  {
    "id": "topic16_6",
    "question": "What is the purpose of correspondence assertions in the context of authentication verification?",
    "options": {
      "A": "To prove the secrecy property of a protocol",
      "B": "To verify the authentication properties of a protocol",
      "C": "To analyze the computational soundness of a protocol",
      "D": "To ensure the integrity of a file system"
    },
    "answer": "B"
  },
  {
    "id": "topic16_7",
    "question": "Which of the following is a feature of the Tamarin tool?",
    "options": {
      "A": "It verifies protocols for a bounded number of sessions",
      "B": "It relies on the user to provide lemmas to guide the proof",
      "C": "It can only prove secrecy properties",
      "D": "It uses a model checking approach"
    },
    "answer": "B"
  },
  {
    "id": "topic16_8",
    "question": "What is the relationship between the Dolev-Yao model and the computational model?",
    "options": {
      "A": "The Dolev-Yao model is more secure than the computational model",
      "B": "A proof in the Dolev-Yao model implies security in the computational model",
      "C": "The Dolev-Yao model is used for verifying secrecy properties only",
      "D": "The computational model is used for verifying authentication properties only"
    },
    "answer": "B"
  },
  {
    "id": "topic16_9",
    "question": "What is the output of ProVerif when verifying a protocol?",
    "options": {
      "A": "A set of Horn clauses representing the protocol",
      "B": "A proof that the protocol is secure",
      "C": "A set of derivability queries on the clauses",
      "D": "A report indicating if the protocol is insecure"
    },
    "answer": "C"
  },
  {
    "id": "topic16_10",
    "question": "Which of the following researchers have contributed to the development of ProVerif?",
    "options": {
      "A": "Blanchet, Chaudhuri, and Fournet",
      "B": "Abadi, Blanchet, and Herzog",
      "C": "Canetti, Herzog, and Guttman",
      "D": "Backes, Schmid, and Smyth"
    },
    "answer": "A"
  }
]