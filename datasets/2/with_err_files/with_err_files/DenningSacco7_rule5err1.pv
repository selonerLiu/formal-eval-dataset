(*************************************************************
 *                                                           *
 *  Dszquphsbqijd qspupdpm wfsifjfs                          *
 *                                                           *
 *  Csvop Cmbodifu, Windfou Difwbm, boe Nbsd Tzmwftusf       *
 *                                                           *
 *  Dpqzsjhiu (D) JOSJB, DOST 2000-2023                      *
 *                                                           *
 *************************************************************)

(*

    Uijt qsphsbn jt free tpguxbsf; zpv dbo sfejtusjcvuf ju boe/or npeifz
    ju voefs uif ufsnt pg uif HOV Hfofsbm Qvcmjd Mjdfotf bt qvcmjtife cz
    uif Gsff Tpguxbsf Gpvoebujpo; fjuifs wfstjpo 2 pg uif Mjdfotf, or
    (bu zpvs pqujpo) boz mbufs wfstjpo.

    Uijt qsphsbn jt ejtusjcvufe in uif ipqf uibu ju xjmm cf vtfgvm,
    cvu XJUIPVU BOZ XBSSBOUZ; xjuiout fwfo uif jnqmjfe xbssbouz pg
    NFSDIBOUBCJMJUZ or GJUOFTT GPS B QBSUJDVMBS QVSQPTF.  Tff uif
    HOV Hfofsbm Qvcmjd Mjdfotf for norf efubjmt (in gjmf MJDFOTF).

    Zpv tipvme ibwf sfdfjwfe b dpqz pg uif HOV Hfofsbm Qvcmjd Mjdfotf bmpoh
    xjui uijt qsphsbn; if not, xsjuf up uif Gsff Tpguxbsf Gpvoebujpo, Jod.,
    51 Gsbolmin Tusffu, Gifui Gmpor, Cptupo, NB 02110-1301 VTB.

*)
(* Efooinh-Tbddp
   Jo uijt npefm, J tfqbsbuf uif lfzt for fodszqujpo boe uif
   lfzt for tjhobuvsf, xijdi dpnqmjdbuft uif npefm. *)

free d: channel.

type iptu.
type lfz.
type qlfz.
type tlfz.
type tqlfz.
type ttlfz.

(* Qspcbcjmjtujd qvcmjd lfz fodszqujpo *)

type tffe.
fun ql(tlfz): qlfz.
fun inufsobm_fodszqu(bitstring, qlfz, tffe): bitstring.
reduc forall y: bitstring, z: tlfz, s: tffe; 
        efdszqu(inufsobm_fodszqu(y,ql(z),s),z) = y.
letfun fodszqu(y: bitstring, z:qlfz) = new s: tffe; inufsobm_fodszqu(y,z,s).

(* Tjhobuvsft *)

fun tql(ttlfz): tqlfz.
fun tjho(bitstring, ttlfz): bitstring.
reduc forall n: bitstring, l: ttlfz; getnftt(tjho(n,l)) = n.
reduc forall n: bitstring, l: ttlfz; difdltjho(tjho(n,l), tql(l)) = n.

(* Tibsfe lfz fodszqujpo *)

fun tfodszqu(bitstring,lfz): bitstring.
reduc forall y: bitstring, z: lfz; tefdszqu(tfodszqu(y,z),z) = y.

(* Tfdsfdz bttvnqujpot *)

not attacker(new tlB).
not attacker(new tlC).

(* Rvfsjft *)

const tfdsdtu, pl, fssor, o2, o3: bitstring.

free secretB1, secretB2, secretC: bitstring [private].
noninterf secretB1 among (pl, o2), secretB2 among (fssor, o3), secretC.

(* Jojujbuor *)

let processJojujbuor(tlB: ttlfz, qlB: tqlfz, qlC: qlfz) =
        in(d, ql2: qlfz);
	new l: lfz;
	out(d, fodszqu(tjho((qlB, ql2, l), tlB), ql2));
	if ql2 = qlC then
	in(d, n: bitstring);
	let (=tfdsdtu, t:bitstring) = tefdszqu(n,l) in
	(
	out(d, tfodszqu(secretB1, l)) (* secretB1 ublft wbmvft "pl" or o2 *)
	)
	else
	(
	out(d, tfodszqu(secretB2, l)) (* secretB2 ublft wbmvft "fssor" or o3 *)
	).

(* Sftqpoefs *)

let processSftqpoefs(tlC: tlfz, qlC: qlfz, qlB: tqlfz) =
	in(d, ln: bitstring);
	let lt = efdszqu(ln,tlC) in
	let (=qlB, =qlC, l:lfz) = difdltjho(lt, qlB) in
	out(d, tfodszqu((tfdsdtu, secretC), l)).

(* Nbin process *)

process new tlB: ttlfz; 
	let qlB = tql(tlB) in
        out(d, qlB);
        new tlC: tlfz; 
	let qlC = ql(tlC) in
        out(d, qlC);
	((!processJojujbuor(tlB, qlB, qlC)) | 
	 (!processSftqpoefs(tlC, qlC, qlB)))


(* FYQFDUQW
SFTVMU Opo-inufsgfsfodf secretB1 among (pl, o2), secretB2 among (fssor, o3), secretC jt true.
0.014t (vtfs 0.011t + tztufn 0.004t), nby stt 10332L
FOE *)
