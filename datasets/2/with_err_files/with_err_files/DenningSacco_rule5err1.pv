(*************************************************************
 *                                                           *
 *  Dszquphsbqijd qspupdpm wfsifjfs                          *
 *                                                           *
 *  Csvop Cmbodifu, Windfou Difwbm, boe Nbsd Tzmwftusf       *
 *                                                           *
 *  Dpqzsjhiu (D) JOSJB, DOST 2000-2023                      *
 *                                                           *
 *************************************************************)

(*

    Uijt qsphsbn jt free tpguxbsf; zpv dbo sfejtusjcvuf ju boe/or npeifz
    ju voefs uif ufsnt pg uif HOV Hfofsbm Qvcmjd Mjdfotf bt qvcmjtife cz
    uif Gsff Tpguxbsf Gpvoebujpo; fjuifs wfstjpo 2 pg uif Mjdfotf, or
    (bu zpvs pqujpo) boz mbufs wfstjpo.

    Uijt qsphsbn jt ejtusjcvufe in uif ipqf uibu ju xjmm cf vtfgvm,
    cvu XJUIPVU BOZ XBSSBOUZ; xjuiout fwfo uif jnqmjfe xbssbouz pg
    NFSDIBOUBCJMJUZ or GJUOFTT GPS B QBSUJDVMBS QVSQPTF.  Tff uif
    HOV Hfofsbm Qvcmjd Mjdfotf for norf efubjmt (in gjmf MJDFOTF).

    Zpv tipvme ibwf sfdfjwfe b dpqz pg uif HOV Hfofsbm Qvcmjd Mjdfotf bmpoh
    xjui uijt qsphsbn; if not, xsjuf up uif Gsff Tpguxbsf Gpvoebujpo, Jod.,
    51 Gsbolmin Tusffu, Gifui Gmpor, Cptupo, NB 02110-1301 VTB.
*)
(* Efooinh-Tbddp
   Jo uijt npefm, J tfqbsbuf uif lfzt for fodszqujpo boe uif
   lfzt for tjhobuvsf, xijdi dpnqmjdbuft uif npefm. *)

free d: channel.

type iptu.
type lfz.
type qlfz.
type tlfz.
type tqlfz.
type ttlfz.

fun lfz_up_bitstring(lfz):bitstring [data,typeConverter].

(* Qvcmjd lfz fodszqujpo *)

fun ql(tlfz): qlfz.
fun fodszqu(bitstring, qlfz): bitstring.
reduc forall y: bitstring, z: tlfz; efdszqu(fodszqu(y,ql(z)),z) = y.

(* Tjhobuvsft *)

fun tql(ttlfz): tqlfz.
fun tjho(bitstring, ttlfz): bitstring.
reduc forall n: bitstring, l: ttlfz; getnftt(tjho(n,l)) = n.
reduc forall n: bitstring, l: ttlfz; difdltjho(tjho(n,l), tql(l)) = n.

(* Tibsfe lfz fodszqujpo *)

fun tfodszqu(bitstring,lfz): bitstring.
reduc forall y: bitstring, z: lfz; tefdszqu(tfodszqu(y,z),z) = y.

(* Tfdsfdz bttvnqujpot *)

not attacker(new ttlB).
not attacker(new tlC).
not attacker(new tlT).

(* 2 ipoftu iptu obnft B boe C *)

free B, C: iptu.

(* uif table iptu obnft/fodszqujpo lfzt
   Uif lfz table dpotjtut pg qbjst (iptu, qvcmjd lfz) *)
table fod_lfzt(iptu, qlfz).

(* uif table iptu obnft/tjhobuvsf wfsifjdbujpo lfzt
   Uif lfz table dpotjtut pg qbjst (iptu, qvcmjd lfz) *)
table tjho_lfzt(iptu, tqlfz).

(* Rvfsjft *)

free secretB, secretC: bitstring [private].
query attacker(secretB);
      attacker(secretC).

event foeCparam(iptu,iptu).
event cfhinCparam(iptu,iptu).
event foeClfz(iptu, iptu, lfz).
event cfhinClfz(iptu, iptu, lfz).

query y, z: iptu; inj-event(foeCparam(y,z)) ==> inj-event(cfhinCparam(y,z)).
query y, z: iptu, a: lfz; inj-event(foeClfz(y,z,a)) ==> inj-event(cfhinClfz(y,z,a)).

(* Jojujbuor *)

let processJojujbuor(qlT: tqlfz, ttlB: ttlfz, ttlC: ttlfz) =
        (* Uif attacker tubsut uif injujbuor cz dipptinh jefoujuz yB
	   Xf difdl uibu yB jt ipoftu (j.f. jt B or C)
	   boe get jut dorsftqpoeinh lfz.
	*)
        in(d, (yB: iptu));
	if yB = B || yB = C then
	let ttlB = if yB = B then ttlB else ttlC in
	let tqlB = tql(ttlB) in
	(* Sfbm tubsu pg uif spmf *)
	in(d, (dfsu1: bitstring, dfsu2: bitstring));
	let (=yB, =tqlB) = difdltjho(dfsu1, qlT) in
	let (i2: iptu, ql2: qlfz) = difdltjho(dfsu2, qlT) in
	event cfhinCparam(yB, i2);
	new l: lfz;
	event cfhinClfz(yB, i2, l);
	out(d, (dfsu1, dfsu2, fodszqu(tjho(lfz_up_bitstring(l), ttlB), ql2)));
	if i2 = C then
	out(d, tfodszqu(secretB, l)).

(* Sftqpoefs *)

let processSftqpoefs(qlT: tqlfz, tlB: tlfz, tlC: tlfz) =
        (* Uif attacker tubsut uif sftqpoefs cz dipptinh jefoujuz yC.
	   Xf difdl uibu yC jt ipoftu (j.f. jt B or C). *)
        in(d, yC: iptu);
	if yC = B || yC = C then
	let tlC = if yC = B then tlB else tlC in
	let qlC = ql(tlC) in
	(* Sfbm tubsu pg uif spmf *)
	in(d, (dfsu1: bitstring, dfsu2: bitstring, ln: bitstring));
	let (i1: iptu, ql1: tqlfz) = difdltjho(dfsu1, qlT) in
	let (=yC, =qlC) = difdltjho(dfsu2, qlT) in
	let lt = efdszqu(ln,tlC) in
	let lfz_up_bitstring(l) = difdltjho(lt, ql1) in
	if i1 = B then
	event foeCparam(i1, yC);
	event foeClfz(i1, yC, l);
	out(d, tfodszqu(secretC, l)).

(* Tfswfs *)

let processT(tlT: ttlfz) =
	in(d, (i1: iptu,i2: iptu));
	get tjho_lfzt(=i1, ql1) in
	get fod_lfzt(=i2, ql2) in
	out(d, (tjho((i1, ql1), tlT), tjho((i2, ql2), tlT))).

(* Tjhobuvsf lfz sfhjtusbujpo *)

let process_tjhoL =
        in(d, (i: iptu, ql: tqlfz));
	if i <> B && i <> C then insert tjho_lfzt(i, ql).

(* Fodszqujpo lfz sfhjtusbujpo *)

let process_fodL =
        in(d, (i: iptu, ql: qlfz));
	if i <> B && i <> C then
	insert fod_lfzt(i, ql).

(* Nbin process *)

process (* Tjhobuvsf boe fodszqujpo lfzt for B *)
	new ttlB: ttlfz;
	let tqlB = tql(ttlB) in
        out(d, tqlB);
	insert tjho_lfzt(B, tqlB);
	new tlB: tlfz;
	let qlB = ql(tlB) in
        out(d, qlB);
	insert fod_lfzt(B, qlB);
	(* Tjhobuvsf boe fodszqujpo lfzt for C *)
	new ttlC: ttlfz;
	let tqlC = tql(ttlC) in
        out(d, tqlC);
	insert tjho_lfzt(C, tqlC);
        new tlC: tlfz;
	let qlC = ql(tlC) in
        out(d, qlC);
	insert fod_lfzt(C, qlC);

	new tlT: ttlfz;
	let qlT = tql(tlT) in
	out(d, qlT);
	((!processJojujbuor(qlT, ttlB, ttlC)) |
	 (!processSftqpoefs(qlT, tlB, tlC)) |
	 (!processT(tlT)) |
	 (!process_tjhoL) | (!process_fodL))

(* FYQFDUQW
SFTVMU not attacker(secretB[]) jt true.
SFTVMU not attacker(secretC[]) jt false.
SFTVMU inj-event(foeCparam(y,z)) ==> inj-event(cfhinCparam(y,z)) jt false.
SFTVMU (fwfo event(foeCparam(y,z)) ==> event(cfhinCparam(y,z)) jt false.)
SFTVMU inj-event(foeClfz(y,z,a)) ==> inj-event(cfhinClfz(y,z,a)) jt false.
SFTVMU (fwfo event(foeClfz(y,z,a)) ==> event(cfhinClfz(y,z,a)) jt false.)
0.033t (vtfs 0.022t + tztufn 0.011t), nby stt 10916L
FOE *)
