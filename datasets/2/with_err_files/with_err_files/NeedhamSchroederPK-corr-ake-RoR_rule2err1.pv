

free c: channel.

type host.
type nonce.
type pkey.
type skey.
type spkey.
type sskey.

fun nonce_to_bitstring(nonce): bitstring [data,typeConverter].



fun pk(skey): pkey.
fun encrypt(bitstring, pkey): bitstring.
reduc forall x: bitstring, y: skey; decrypt(encrypt(x,pk(y)),y) = x.



fun spk(sskey): spkey.
fun sign(bitstring, sskey): bitstring.
reduc forall m: bitstring, k: sskey; getmess(sign(m,k)) = m.
reduc forall m: bitstring, k: sskey; checksign(sign(m,k), spk(k)) = m.



reduc forall x: bitstring, y: nonce; sdecrypt(sencrypt(x,y),y) = x.



not attacker(new skA).
not attacker(new skB).
not attacker(new skS).



free A, B: host.


table keys(host, pkey).


fun messtermI(host, host): bitstring [data].
fun messtermR(host, host): bitstring [data].

set ignoreTypes = false.


let processInitiator(pkS: spkey, skA: skey, skB: skey) =
	
	in(c, (xA: host, hostX: host));
	if xA = A || xA = B then
	let skxA = if xA = A then skA else skB in
	let pkxA = pk(skxA) in
	
	
	out(c, (xA, hostX));
	
	in(c, ms: bitstring); 
	let (pkX: pkey, =hostX) = checksign(ms,pkS) in
	
	new Na: nonce;
	let m3 = encrypt((Na, xA), pkX) in
	out(c, m3);
	
	in(c, m: bitstring); 
	let (=Na, NX2: nonce, =hostX) = decrypt(m, skA) in
	let m7 = encrypt(nonce_to_bitstring(NX2), pkX) in
	
	if hostX = A || hostX = B then
	(
	   new random: nonce;
	   out(c, choice[Na, random]);
	   out(c, (m7, messtermI(xA, hostX)))
	)
	else
	(
	   out(c, Na);
	   out(c, (m7, messtermI(xA, hostX)))
	).


let processResponder(pkS: spkey, skA: skey, skB: skey) =
	
	in(c, xB: host);
	if xB = A || xB = B then
	let skxB = if xB = A then skA else skB in
	let pkxB = pk(skxB) in
	
	
	in(c, m: bitstring);
	let (NY: nonce, hostY: host) = decrypt(m, skxB) in
	
	out(c, (xB, hostY));
	
	in(c,ms: bitstring);
	let (pkY: pkey,=hostY) = checksign(ms,pkS) in
	
	new Nb: nonce;
	let m6 = encrypt((NY, Nb, xB), pkY) in
	out(c, m6);
	
	in(c, m3: bitstring);
	if nonce_to_bitstring(Nb) = decrypt(m3, skB) then
	if hostY = A || hostY = B then
	   out(c, messtermR(hostY, xB))
	else
	(
	   out(c, NY);
	   out(c, messtermR(hostY, xB))
	).


let processS(skS: sskey) =  
	in(c,(a: host, b: host)); 
	get keys(=b, sb) in
	out(c,sign((sb,b),skS)).


let processK =
	in(c, (h: host, k: pkey));
	if h <> A && h <> B then insert keys(h,k).


process 
	new skA: skey; let pkA = pk(skA) in out(c, pkA); insert keys(A, pkA);
	new skB: skey; let pkB = pk(skB) in out(c, pkB); insert keys(B, pkB);
	new skS: sskey; let pkS = spk(skS) in out(c, pkS);
	(
	  
	  (!processInitiator(pkS, skA, skB)) | 
	  
	  (!processResponder(pkS, skA, skB)) |
	  
	  (!processS(skS)) |
	  
	  (!processK)
	)
