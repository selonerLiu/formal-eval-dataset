

free c: channel.

type host.
type nonce.
type pkey.
type skey.
type spkey.
type sskey.

fun nonce_to_bitstring(nonce): bitstring [data,typeConverter].



fun pk(skey): pkey.
fun encrypt(bitstring, pkey): bitstring.
reduc forall x: bitstring, y: skey; decrypt(encrypt(x,pk(y)),y) = x.



fun spk(sskey): spkey.
fun sign(bitstring, sskey): bitstring.
reduc forall m: bitstring, k: sskey; getmess(sign(m,k)) = m.
reduc forall m: bitstring, k: sskey; checksign(sign(m,k), spk(k)) = m.



fun sencrypt(bitstring,nonce): bitstring.
reduc forall x: bitstring, y: nonce; sdecrypt(sencrypt(x,y),y) = x.



not attacker(new skA).
not attacker(new skB).
not attacker(new skS).



free A, B: host.


table keys(host, pkey).


free secretA: bitstring [private].
query attacker(secretA).

fun messtermI(host, host): bitstring [data].
fun messtermR(host, host): bitstring [data].

event termI(host, host, bitstring).
event acceptsI(host, host, nonce, bitstring).
event acceptsR(host, host, bitstring).
event termR(host, host, nonce, bitstring).

query x: host, m: bitstring; 
      inj-event(termI(x,B,m)) ==> inj-event(acceptsR(x,B,m)).
query x: host, k:nonce, m: bitstring; 
      inj-event(termR(A,x,k,m)) ==> inj-event(acceptsI(A,x,k,m)).

query x: host, k:nonce, k':nonce, m: bitstring; 
      event(termR(A,x,k,m)) && event(acceptsI(A,x,k',m)) ==> k = k'.


query x: host, y:host, x':host, y':host, k:nonce, k':nonce, 
  m: bitstring, m':bitstring; 
  event(termR(x,y,k,m)) && event(acceptsI(x',y',k,m')) ==> x = x' && y = y'.


let processInitiator(pkS: spkey, skA: skey, skB: skey) =
	
	in(c, (xA: host, hostX: host));
	if xA = A || xA = B then
	let skxA = if xA = A then skA else skB in
	let pkxA = pk(skxA) in
	
	
	out(c, (xA, hostX));
	
	in(c, ms: bitstring); 
	let (pkX: pkey, =hostX) = checksign(ms,pkS) in
	
	new Na: nonce;
	let m3 = encrypt((Na, xA), pkX) in
	out(c, m3);
	
	in(c, m: bitstring); 
	let (=Na, NX2: nonce, =hostX) = decrypt(m, skA) in
	let m7 = encrypt(nonce_to_bitstring(NX2), pkX) in
	event termI(xA, hostX, (m3, m));
	event acceptsI(xA, hostX, Na, (m3, m, m7));
	
	if hostX = A || hostX = B then
	(
	   out(c, sencrypt(secretA, Na));
	   out(c, (m7, messtermI(xA, hostX)))
	)
	else
	(
	   out(c, Na);
	   out(c, (m7, messtermI(xA, hostX)))
	).


let processS(skS: sskey) =  
	in(c,(a: host, b: host)); 
	get keys(=b, sb) in
	out(c,sign((sb,b),skS)).


let processK =
	in(c, (h: host, k: pkey));
	if h <> A && h <> B then insert keys(h,k).


process 
	new skA: skey; let pkA = pk(skA) in out(c, pkA); insert keys(A, pkA);
	new skB: skey; let pkB = pk(skB) in out(c, pkB); insert keys(B, pkB);
	new skS: sskey; let pkS = spk(skS) in out(c, pkS);
	(
	  
	  (!processInitiator(pkS, skA, skB)) | 
	  
	  (!processResponder(pkS, skA, skB)) |
	  
	  (!processS(skS)) |
	  
	  (!processK)
	)
