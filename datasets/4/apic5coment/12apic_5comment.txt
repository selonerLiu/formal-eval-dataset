(*62 lines*)
set ignoreTypes = true.
free c: channel.
type host.
type passwd.
type nonce.
type G.
type exponent.
type key.
fun nonce_to_bitstring(nonce): bitstring [data, typeConverter].
const g: G.
fun exp(G, exponent): G.
equation forall x: exponent, y: exponent; exp(exp(g, x), y) = exp(exp(g, y), x).
fun enc(G, key): G.
fun dec(G, key): G.
equation forall x: G, y: key; dec(enc(x,y),y) = x.
equation forall x: G, y: key; enc(dec(x,y),y) = x.
fun senc(bitstring, G): bitstring.
reduc forall x: bitstring, y: G; sdec(senc(x,y),y) = x.
fun pk(passwd):key.
fun sign(G, passwd): bitstring.
reduc forall x: G, y: passwd; verif(sign(x,y), pk(y),x) = true.
reduc forall x: G, y: passwd; getmess(sign(x,y)) = x.
const A, B: host.
free PAB, PAA, PBB: passwd [private].
weaksecret PAB.
weaksecret PAA.
weaksecret PBB.
let processA(hostA: host, hostX: host, P: passwd) =
    new RA: exponent;
    out(c, (hostA, enc(exp(g,RA), pk(P))));
    in(c, (m1: G, m2: bitstring));
    let gRB = dec(m1, pk(P)) in
    let K = exp(gRB, RA) in
    let nonce_to_bitstring(challengeB) = sdec(m2, K) in
    new challengeA: nonce;
    out(c, senc((challengeA, challengeB), K));
    in(c, m3: bitstring);
    if nonce_to_bitstring(challengeA) = sdec(m3, K) then
    out(c, senc(sign(K,P), K)).
let processB(hostB: host, hostX: host, P: passwd) =
    in(c, (=hostX, m: G));
    let gRA = dec(m, pk(P)) in
    new RB: exponent;
    let K = exp(gRA, RB) in
    new challengeB: nonce;
    out(c, (enc(exp(g, RB), pk(P)), senc(nonce_to_bitstring(challengeB), K)));
    in(c, m4: bitstring);
    let (challengeA: nonce, =challengeB) = sdec(m4, K) in
    out(c, senc(nonce_to_bitstring(challengeA), K));
    in(c, m5: bitstring);
    let fr = sdec(m5, K) in
    if verif(fr,pk(P),K) = true then
    0.
process
    (!processA(A, A, PAA)) |
    (!processB(A, A, PAA)) |
    (!processA(B, B, PBB)) |
    (!processB(B, B, PBB)) |
    (!processA(A, B, PAB)) |
    (!processB(A, B, PAB)) |
    (!processA(B, A, PAB)) |
    (!processB(B, A, PAB))